!function(t){function n(e){if(g[e])return g[e].exports;var I=g[e]={i:e,l:!1,exports:{}};return t[e].call(I.exports,I,I.exports,n),I.l=!0,I.exports}var g={};return n.m=t,n.c=g,n.i=function(t){return t},n.d=function(t,g,e){n.o(t,g)||Object.defineProperty(t,g,{configurable:!1,enumerable:!0,get:e})},n.n=function(t){var g=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(g,"a",g),g},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n.s=28)}([/*!***************************************************!*\
  !*** ../~/vue-loader/lib/component-normalizer.js ***!
  \***************************************************/
function(module,exports){eval("module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzPzdkYTgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICByYXdTY3JpcHRFeHBvcnRzLFxuICBjb21waWxlZFRlbXBsYXRlLFxuICBzY29wZUlkLFxuICBjc3NNb2R1bGVzXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICAvLyBpbmplY3QgY3NzTW9kdWxlc1xuICBpZiAoY3NzTW9kdWxlcykge1xuICAgIHZhciBjb21wdXRlZCA9IG9wdGlvbnMuY29tcHV0ZWQgfHwgKG9wdGlvbnMuY29tcHV0ZWQgPSB7fSlcbiAgICBPYmplY3Qua2V5cyhjc3NNb2R1bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBjc3NNb2R1bGVzW2tleV1cbiAgICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb2R1bGUgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVzTW9kdWxlOiBlc01vZHVsZSxcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},/*!************************!*\
  !*** ./store/store.js ***!
  \************************/
function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\nexports.store = undefined;\n\nvar _vue = __webpack_require__(/*! vue */ 2);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _vuex = __webpack_require__(/*! vuex */ 26);\n\nvar _vuex2 = _interopRequireDefault(_vuex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*=============================================>>>>>\n= STORES =\n===============================================>>>>>*/\n\n_vue2.default.use(_vuex2.default);\n\nvar store = exports.store = new _vuex2.default.Store({\n\tstate: {\n\t\tmenu_activity: false,\n\t\tactive_menu_item: null,\n\t\tbg_url: null\n\t},\n\tgetters: {\n\t\treturnActivity: function returnActivity(state) {\n\t\t\treturn state.active_menu_item;\n\t\t},\n\t\tmenuActivity: function menuActivity(state) {\n\t\t\treturn state.menu_activity;\n\t\t}\n\t},\n\tmutations: {\n\t\ttriggerMenu: function triggerMenu(state) {\n\t\t\tvar menu_activity = state.menu_activity;\n\n\t\t\tstate.menu_activity = !menu_activity;\n\t\t},\n\t\tsetMenuActivity: function setMenuActivity(state, item) {\n\t\t\tstate.active_menu_item = item;\n\t\t}\n\t}\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9zdG9yZS9zdG9yZS5qcyJdLCJuYW1lcyI6WyJ1c2UiLCJzdG9yZSIsIlN0b3JlIiwic3RhdGUiLCJtZW51X2FjdGl2aXR5IiwiYWN0aXZlX21lbnVfaXRlbSIsImJnX3VybCIsImdldHRlcnMiLCJyZXR1cm5BY3Rpdml0eSIsIm1lbnVBY3Rpdml0eSIsIm11dGF0aW9ucyIsInRyaWdnZXJNZW51Iiwic2V0TWVudUFjdGl2aXR5IiwiaXRlbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUlBOzs7O0FBQ0E7Ozs7OztBQUxBOzs7O0FBT0EsY0FBSUEsR0FBSjs7QUFFTyxJQUFNQyx3QkFBUSxJQUFJLGVBQUtDLEtBQVQsQ0FBZTtBQUNuQ0MsUUFBTztBQUNOQyxpQkFBZSxLQURUO0FBRU5DLG9CQUFrQixJQUZaO0FBR05DLFVBQVE7QUFIRixFQUQ0QjtBQU1uQ0MsVUFBUztBQUNSQyxrQkFBZ0IsK0JBQVM7QUFDeEIsVUFBT0wsTUFBTUUsZ0JBQWI7QUFDQSxHQUhPO0FBSVJJLGdCQUFjLDZCQUFTO0FBQ3RCLFVBQU9OLE1BQU1DLGFBQWI7QUFDQTtBQU5PLEVBTjBCO0FBY25DTSxZQUFXO0FBQ1ZDLGVBQWEsNEJBQVM7QUFBQSxPQUNkUCxhQURjLEdBQ0dELEtBREgsQ0FDZEMsYUFEYzs7QUFFckJELFNBQU1DLGFBQU4sR0FBc0IsQ0FBQ0EsYUFBdkI7QUFDQSxHQUpTO0FBS1ZRLG1CQUFpQix5QkFBQ1QsS0FBRCxFQUFRVSxJQUFSLEVBQWlCO0FBQ2pDVixTQUFNRSxnQkFBTixHQUF5QlEsSUFBekI7QUFDQTtBQVBTO0FBZHdCLENBQWYsQ0FBZCIsImZpbGUiOiJzdG9yZS5qcyIsInNvdXJjZVJvb3QiOiIvbWVkaWEvZXh0X2Rpc2svQ09ERUFSTUFEQS9odHRwL2V4cGVyaW1lbnRzL3Z1ZS9hcHAiLCJzb3VyY2VzQ29udGVudCI6WyIvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT4+Pj4+XG49IFNUT1JFUyA9XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT4+Pj4+Ki9cblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IFZ1ZXggZnJvbSAndnVleCc7XG5cblZ1ZS51c2UoVnVleCk7XG5cbmV4cG9ydCBjb25zdCBzdG9yZSA9IG5ldyBWdWV4LlN0b3JlKHtcblx0c3RhdGU6IHtcblx0XHRtZW51X2FjdGl2aXR5OiBmYWxzZSxcblx0XHRhY3RpdmVfbWVudV9pdGVtOiBudWxsLFxuXHRcdGJnX3VybDogbnVsbCxcblx0fSxcblx0Z2V0dGVyczoge1xuXHRcdHJldHVybkFjdGl2aXR5OiBzdGF0ZSA9PiB7XG5cdFx0XHRyZXR1cm4gc3RhdGUuYWN0aXZlX21lbnVfaXRlbTtcblx0XHR9LFxuXHRcdG1lbnVBY3Rpdml0eTogc3RhdGUgPT4ge1xuXHRcdFx0cmV0dXJuIHN0YXRlLm1lbnVfYWN0aXZpdHk7XG5cdFx0fSxcblx0fSxcblx0bXV0YXRpb25zOiB7XG5cdFx0dHJpZ2dlck1lbnU6IHN0YXRlID0+IHtcblx0XHRcdGNvbnN0IHttZW51X2FjdGl2aXR5fSA9IHN0YXRlO1xuXHRcdFx0c3RhdGUubWVudV9hY3Rpdml0eSA9ICFtZW51X2FjdGl2aXR5O1xuXHRcdH0sXG5cdFx0c2V0TWVudUFjdGl2aXR5OiAoc3RhdGUsIGl0ZW0pID0+IHtcblx0XHRcdHN0YXRlLmFjdGl2ZV9tZW51X2l0ZW0gPSBpdGVtO1xuXHRcdH0sXG5cdH0sXG59KTtcbiJdfQ==//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0b3JlL3N0b3JlLmpzPzFlOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zdG9yZSA9IHVuZGVmaW5lZDtcblxudmFyIF92dWUgPSByZXF1aXJlKCd2dWUnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxudmFyIF92dWV4ID0gcmVxdWlyZSgndnVleCcpO1xuXG52YXIgX3Z1ZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVleCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Pj4+Pj5cbj0gU1RPUkVTID1cbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Pj4+Pj4qL1xuXG5fdnVlMi5kZWZhdWx0LnVzZShfdnVleDIuZGVmYXVsdCk7XG5cbnZhciBzdG9yZSA9IGV4cG9ydHMuc3RvcmUgPSBuZXcgX3Z1ZXgyLmRlZmF1bHQuU3RvcmUoe1xuXHRzdGF0ZToge1xuXHRcdG1lbnVfYWN0aXZpdHk6IGZhbHNlLFxuXHRcdGFjdGl2ZV9tZW51X2l0ZW06IG51bGwsXG5cdFx0YmdfdXJsOiBudWxsXG5cdH0sXG5cdGdldHRlcnM6IHtcblx0XHRyZXR1cm5BY3Rpdml0eTogZnVuY3Rpb24gcmV0dXJuQWN0aXZpdHkoc3RhdGUpIHtcblx0XHRcdHJldHVybiBzdGF0ZS5hY3RpdmVfbWVudV9pdGVtO1xuXHRcdH0sXG5cdFx0bWVudUFjdGl2aXR5OiBmdW5jdGlvbiBtZW51QWN0aXZpdHkoc3RhdGUpIHtcblx0XHRcdHJldHVybiBzdGF0ZS5tZW51X2FjdGl2aXR5O1xuXHRcdH1cblx0fSxcblx0bXV0YXRpb25zOiB7XG5cdFx0dHJpZ2dlck1lbnU6IGZ1bmN0aW9uIHRyaWdnZXJNZW51KHN0YXRlKSB7XG5cdFx0XHR2YXIgbWVudV9hY3Rpdml0eSA9IHN0YXRlLm1lbnVfYWN0aXZpdHk7XG5cblx0XHRcdHN0YXRlLm1lbnVfYWN0aXZpdHkgPSAhbWVudV9hY3Rpdml0eTtcblx0XHR9LFxuXHRcdHNldE1lbnVBY3Rpdml0eTogZnVuY3Rpb24gc2V0TWVudUFjdGl2aXR5KHN0YXRlLCBpdGVtKSB7XG5cdFx0XHRzdGF0ZS5hY3RpdmVfbWVudV9pdGVtID0gaXRlbTtcblx0XHR9XG5cdH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTl6ZEc5eVpTOXpkRzl5WlM1cWN5SmRMQ0p1WVcxbGN5STZXeUoxYzJVaUxDSnpkRzl5WlNJc0lsTjBiM0psSWl3aWMzUmhkR1VpTENKdFpXNTFYMkZqZEdsMmFYUjVJaXdpWVdOMGFYWmxYMjFsYm5WZmFYUmxiU0lzSW1KblgzVnliQ0lzSW1kbGRIUmxjbk1pTENKeVpYUjFjbTVCWTNScGRtbDBlU0lzSW0xbGJuVkJZM1JwZG1sMGVTSXNJbTExZEdGMGFXOXVjeUlzSW5SeWFXZG5aWEpOWlc1MUlpd2ljMlYwVFdWdWRVRmpkR2wyYVhSNUlpd2lhWFJsYlNKZExDSnRZWEJ3YVc1bmN5STZJanM3T3pzN096dEJRVWxCT3pzN08wRkJRMEU3T3pzN096dEJRVXhCT3pzN08wRkJUMEVzWTBGQlNVRXNSMEZCU2pzN1FVRkZUeXhKUVVGTlF5eDNRa0ZCVVN4SlFVRkpMR1ZCUVV0RExFdEJRVlFzUTBGQlpUdEJRVU51UTBNc1VVRkJUenRCUVVOT1F5eHBRa0ZCWlN4TFFVUlVPMEZCUlU1RExHOUNRVUZyUWl4SlFVWmFPMEZCUjA1RExGVkJRVkU3UVVGSVJpeEZRVVEwUWp0QlFVMXVRME1zVlVGQlV6dEJRVU5TUXl4clFrRkJaMElzSzBKQlFWTTdRVUZEZUVJc1ZVRkJUMHdzVFVGQlRVVXNaMEpCUVdJN1FVRkRRU3hIUVVoUE8wRkJTVkpKTEdkQ1FVRmpMRFpDUVVGVE8wRkJRM1JDTEZWQlFVOU9MRTFCUVUxRExHRkJRV0k3UVVGRFFUdEJRVTVQTEVWQlRqQkNPMEZCWTI1RFRTeFpRVUZYTzBGQlExWkRMR1ZCUVdFc05FSkJRVk03UVVGQlFTeFBRVU5rVUN4aFFVUmpMRWRCUTBkRUxFdEJSRWdzUTBGRFpFTXNZVUZFWXpzN1FVRkZja0pFTEZOQlFVMURMR0ZCUVU0c1IwRkJjMElzUTBGQlEwRXNZVUZCZGtJN1FVRkRRU3hIUVVwVE8wRkJTMVpSTEcxQ1FVRnBRaXg1UWtGQlExUXNTMEZCUkN4RlFVRlJWU3hKUVVGU0xFVkJRV2xDTzBGQlEycERWaXhUUVVGTlJTeG5Ra0ZCVGl4SFFVRjVRbEVzU1VGQmVrSTdRVUZEUVR0QlFWQlRPMEZCWkhkQ0xFTkJRV1lzUTBGQlpDSXNJbVpwYkdVaU9pSnpkRzl5WlM1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJdmJXVmthV0V2WlhoMFgyUnBjMnN2UTA5RVJVRlNUVUZFUVM5b2RIUndMMlY0Y0dWeWFXMWxiblJ6TDNaMVpTOWhjSEFpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lJdktqMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUNCtQajQrWEc0OUlGTlVUMUpGVXlBOVhHNDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDQrUGo0K0tpOWNibHh1YVcxd2IzSjBJRloxWlNCbWNtOXRJQ2QyZFdVbk8xeHVhVzF3YjNKMElGWjFaWGdnWm5KdmJTQW5kblZsZUNjN1hHNWNibFoxWlM1MWMyVW9WblZsZUNrN1hHNWNibVY0Y0c5eWRDQmpiMjV6ZENCemRHOXlaU0E5SUc1bGR5QldkV1Y0TGxOMGIzSmxLSHRjYmx4MGMzUmhkR1U2SUh0Y2JseDBYSFJ0Wlc1MVgyRmpkR2wyYVhSNU9pQm1ZV3h6WlN4Y2JseDBYSFJoWTNScGRtVmZiV1Z1ZFY5cGRHVnRPaUJ1ZFd4c0xGeHVYSFJjZEdKblgzVnliRG9nYm5Wc2JDeGNibHgwZlN4Y2JseDBaMlYwZEdWeWN6b2dlMXh1WEhSY2RISmxkSFZ5YmtGamRHbDJhWFI1T2lCemRHRjBaU0E5UGlCN1hHNWNkRngwWEhSeVpYUjFjbTRnYzNSaGRHVXVZV04wYVhabFgyMWxiblZmYVhSbGJUdGNibHgwWEhSOUxGeHVYSFJjZEcxbGJuVkJZM1JwZG1sMGVUb2djM1JoZEdVZ1BUNGdlMXh1WEhSY2RGeDBjbVYwZFhKdUlITjBZWFJsTG0xbGJuVmZZV04wYVhacGRIazdYRzVjZEZ4MGZTeGNibHgwZlN4Y2JseDBiWFYwWVhScGIyNXpPaUI3WEc1Y2RGeDBkSEpwWjJkbGNrMWxiblU2SUhOMFlYUmxJRDArSUh0Y2JseDBYSFJjZEdOdmJuTjBJSHR0Wlc1MVgyRmpkR2wyYVhSNWZTQTlJSE4wWVhSbE8xeHVYSFJjZEZ4MGMzUmhkR1V1YldWdWRWOWhZM1JwZG1sMGVTQTlJQ0Z0Wlc1MVgyRmpkR2wyYVhSNU8xeHVYSFJjZEgwc1hHNWNkRngwYzJWMFRXVnVkVUZqZEdsMmFYUjVPaUFvYzNSaGRHVXNJR2wwWlcwcElEMCtJSHRjYmx4MFhIUmNkSE4wWVhSbExtRmpkR2wyWlY5dFpXNTFYMmwwWlcwZ1BTQnBkR1Z0TzF4dVhIUmNkSDBzWEc1Y2RIMHNYRzU5S1R0Y2JpSmRmUT09XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdG9yZS9zdG9yZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9')},/*!***********************************!*\
  !*** ../~/vue/dist/vue.common.js ***!
  \***********************************/
function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.1.10\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b)\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) { cb.call(ctx); }\n      if (_resolve) { _resolve(ctx); }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\nvar warn = noop;\nvar formatComponentName;\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n\nvar uid$1 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$1++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set$1 (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set$1(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$3) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    \"production\" !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tidentity: identity,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tisServerRendering: isServerRendering,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    props: props,\n    data: data,\n    parent: context,\n    children: children,\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (\n  vnode,\n  hydrating,\n  parentElm,\n  refElm\n) {\n  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n    var child = vnode.componentInstance = createComponentInstanceForVnode(\n      vnode,\n      activeInstance,\n      parentElm,\n      refElm\n    );\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.componentInstance = oldVnode.componentInstance;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.componentInstance._isMounted) {\n    vnode.componentInstance._isMounted = true;\n    callHook(vnode.componentInstance, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.componentInstance._inactive = false;\n    callHook(vnode.componentInstance, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.componentInstance._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.componentInstance.$destroy();\n    } else {\n      vnode.componentInstance._inactive = true;\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var once = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once,\n    capture: capture\n  }\n});\n\nfunction createEventHandle (fn) {\n  var handle = {\n    fn: fn,\n    invoker: function () {\n      var arguments$1 = arguments;\n\n      var fn = handle.fn;\n      if (Array.isArray(fn)) {\n        for (var i = 0; i < fn.length; i++) {\n          fn[i].apply(null, arguments$1);\n        }\n      } else {\n        fn.apply(null, arguments);\n      }\n    }\n  };\n  return handle\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (!cur) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      if (!cur.invoker) {\n        cur = on[name] = createEventHandle(cur);\n      }\n      add(event.name, cur.invoker, event.once, event.capture);\n    } else if (cur !== old) {\n      old.fn = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name].invoker, event.capture);\n    }\n  }\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// nomralization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constrcuts that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (c == null || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (last && last.text) {\n        last.text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (c.text && last && last.text) {\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (c.tag && c.key == null && nestedIndex != null) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (data && data.__ob__) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n      typeof children[0] === 'function') {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (vnode.children) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (child.tag && !child.ns) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$options._parentVnode;\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = {};\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (_parentVnode && _parentVnode.data.scopedSlots) {\n      vm.$scopedSlots = _parentVnode.data.scopedSlots;\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (false) {\n          warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n        }\n        throw e\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // convert text to vnode\n  Vue.prototype._v = createTextVNode;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = createEmptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        extend(props, bindObject);\n      }\n      return scopedSlotFn(props) || fallback\n    } else {\n      var slotNodes = this.$slots[name];\n      // warn duplicate slot usage\n      if (slotNodes && \"production\" !== 'production') {\n        slotNodes._rendered && warn(\n          \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n          \"- this will likely cause render errors.\",\n          this\n        );\n        slotNodes._rendered = true;\n      }\n      return slotNodes || fallback\n    }\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        \"production\" !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var type = data.attrs && data.attrs.type;\n            var hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // check v-on keyCodes\n  Vue.prototype._k = function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInAlias\n  ) {\n    var keyCodes = config.keyCodes[key] || builtInAlias;\n    if (Array.isArray(keyCodes)) {\n      return keyCodes.indexOf(eventKeyCode) === -1\n    } else {\n      return keyCodes !== eventKeyCode\n    }\n  };\n}\n\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add$1 (event, fn, once) {\n  if (once) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$2 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add$1, remove$2, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    // optimize hook:event cost by using a boolean flag marked at registration\n    // instead of a hash lookup\n    if (hookRE.test(event)) {\n      vm._hasHookEvent = true;\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      if (false) {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function updateComponent () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (false) {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (false) {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      updateComponentListeners(vm, listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id, vm;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // call updated hooks\n  index = queue.length;\n  while (index--) {\n    watcher = queue[index];\n    vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            \"production\" !== 'production' && warn(\n              (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n              this.vm\n            );\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\nvar isReservedProp = { key: 1, ref: 1, slot: 1 };\n\nfunction initProps (vm, props) {\n  var propsData = vm.$options.propsData || {};\n  var keys = vm.$options._propKeys = Object.keys(props);\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( i ) {\n    var key = keys[i];\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedProp[key]) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n        if (vm.$parent && !observerState.isSettingProps) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n    }\n  };\n\n  for (var i = 0; i < keys.length; i++) loop( i );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm, computed) {\n  for (var key in computed) {\n    /* istanbul ignore if */\n    if (false) {\n      warn(\n        \"existing instance property \\\"\" + key + \"\\\" will be \" +\n        \"overwritten by a computed property with the same name.\",\n        vm\n      );\n    }\n    var userDef = computed[key];\n    if (typeof userDef === 'function') {\n      computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n      computedSharedDefinition.set = noop;\n    } else {\n      computedSharedDefinition.get = userDef.get\n        ? userDef.cache !== false\n          ? makeComputedGetter(userDef.get, vm)\n          : bind$1(userDef.get, vm)\n        : noop;\n      computedSharedDefinition.set = userDef.set\n        ? bind$1(userDef.set, vm)\n        : noop;\n    }\n    Object.defineProperty(vm, key, computedSharedDefinition);\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm, methods) {\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n    if (false) {\n      warn(\n        \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n        \"Did you reference the function correctly?\",\n        vm\n      );\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set$1;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      extendOptions._scopeId = options._scopeId;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$3 (options) {\n  if (false) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else {\n    return pattern.test(name)\n  }\n}\n\nfunction pruneCache (cache, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cachedNode);\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    if (!vnode.componentInstance._inactive) {\n      callHook(vnode.componentInstance, 'deactivated');\n    }\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set$1;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nVue$3.version = '2.1.10';\n\n/*  */\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.componentInstance) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isReactivated) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref) {\n    if (parent) {\n      if (ref) {\n        nodeOps.insertBefore(parent, elm, ref);\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (vnode.parent) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parentElm$1 !== null) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar target$1;\n\nfunction add$2 (\n  event,\n  handler,\n  once,\n  capture\n) {\n  if (once) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      remove$3(event, handler, capture, _target);\n      arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n    };\n  }\n  target$1.addEventListener(event, handler, capture);\n}\n\nfunction remove$3 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  updateListeners(on, oldOn, add$2, remove$3, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(vnode, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n  return document.activeElement !== elm && elm.value !== checkVal\n}\n\nfunction isInputChanged (vnode, newVal) {\n  var value = vnode.elm.value;\n  var modifiers = vnode.elm._vModifiers; // injected by v-model runtime\n  if ((modifiers && modifiers.number) || vnode.elm.type === 'number') {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (modifiers && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var toClass = isAppear ? appearToClass : enterToClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    leaveToClass: (name + \"-leave-to\"),\n    appearToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (!vnode.data.show) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (false) {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (vnode.tag === 'textarea' || el.type === 'text') {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition && !isIE9) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    var key = child.key = child.key == null\n      ? id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.isUnknownElement = isUnknownElement;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch$1 : noop;\n\n// wrap mount\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\nif (false) {\n  console[console.info ? 'info' : 'log'](\n    \"You are running Vue in development mode.\\n\" +\n    \"Make sure to turn on production mode when deploying for production.\\n\" +\n    \"See more tips at https://vuejs.org/guide/deployment.html\"\n  );\n}\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (\n      false\n    ) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar decoder;\n\nfunction decode (html) {\n  decoder = decoder || document.createElement('div');\n  decoder.innerHTML = html;\n  return decoder.textContent\n}\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isScriptOrStyle = makeMap('script,style', true);\nvar reCache = {};\n\nvar ltRE = /&lt;/g;\nvar gtRE = /&gt;/g;\nvar nlRE = /&#10;/g;\nvar ampRE = /&amp;/g;\nvar quoteRE = /&quot;/g;\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  if (shouldDecodeNewlines) {\n    value = value.replace(nlRE, '\\n');\n  }\n  return value\n    .replace(ltRE, '<')\n    .replace(gtRE, '>')\n    .replace(ampRE, '&')\n    .replace(quoteRE, '\"')\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a script or style element\n    if (!lastTag || !isScriptOrStyle(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          continue\n        }\n      }\n\n      var text = (void 0), rest$1 = (void 0), next = (void 0);\n      if (textEnd > 0) {\n        rest$1 = html.slice(textEnd);\n        while (\n          !endTag.test(rest$1) &&\n          !startTagOpen.test(rest$1) &&\n          !comment.test(rest$1) &&\n          !conditionalComment.test(rest$1)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest$1.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest$1 = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var endTagLength = 0;\n      var rest = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest.length;\n      html = rest;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last && options.chars) {\n      options.chars(html);\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n      unarySlash = '';\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !/[\\w$]/.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue parser]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important\n) {\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\nvar bindRE = /^:|^v-bind:/;\nvar onRE = /^@|^v-on:/;\nvar argRE = /:(.*)$/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(decode);\n\n// configurable state\nvar warn$1;\nvar platformGetTagNamespace;\nvar platformMustUseProp;\nvar platformIsPreTag;\nvar preTransforms;\nvar transforms;\nvar postTransforms;\nvar delimiters;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$1 = options.warn || baseWarn;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformIsPreTag = options.isPreTag || no;\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n  delimiters = options.delimiters;\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n  parseHTML(template, {\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$1(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warned = true;\n            warn$1(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes:\\n' + template\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warned = true;\n            warn$1(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements:\\n' + template\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warned = true;\n          warn$1(\n            \"Component template should contain exactly one root element:\" +\n            \"\\n\\n\" + template + \"\\n\\n\" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || 'default';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ') {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          warned = true;\n          warn$1(\n            'Component template requires a root element, rather than just text:\\n\\n' + template\n          );\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || children[children.length - 1].text !== ' ') {\n          currentParent.children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$1(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$1(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$1(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$1(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once = getAndRemoveAttr(el, 'v-once');\n  if (once != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$1(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, arg, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n        }\n        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        if (argMatch && (arg = argMatch[1])) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$1(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (false) {\n      warn$1('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      walkThroughConditionsBlocks(node.ifConditions, isInFor);\n    }\n  }\n}\n\nfunction walkThroughConditionsBlocks (conditionBlocks, isInFor) {\n  for (var i = 1, len = conditionBlocks.length; i < len; i++) {\n    markStaticRoots(conditionBlocks[i].block, isInFor);\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: 'if($event.target !== $event.currentTarget)return;',\n  ctrl: 'if(!$event.ctrlKey)return;',\n  shift: 'if(!$event.shiftKey)return;',\n  alt: 'if(!$event.altKey)return;',\n  meta: 'if(!$event.metaKey)return;'\n};\n\nfunction genHandlers (events, native) {\n  var res = native ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, events[name])) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  } else if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  } else if (!handler.modifiers) {\n    return fnExpRE.test(handler.value) || simplePathRE.test(handler.value)\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\")\n  } else {\n    var code = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        code += modifierCode[key];\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code = genKeyFilter(keys) + code;\n    }\n    var handlerCode = simplePathRE.test(handler.value)\n      ? handler.value + '($event)'\n      : handler.value;\n    return 'function($event){' + code + handlerCode + '}'\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(\" + (keys.map(genFilterCode).join('&&')) + \")return;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction bind$2 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  bind: bind$2,\n  cloak: noop\n};\n\n/*  */\n\n// configurable state\nvar warn$2;\nvar transforms$1;\nvar dataGenFns;\nvar platformDirectives$1;\nvar isPlatformReservedTag$1;\nvar staticRenderFns;\nvar onceCount;\nvar currentOptions;\n\nfunction generate (\n  ast,\n  options\n) {\n  // save previous staticRenderFns so generate calls can be nested\n  var prevStaticRenderFns = staticRenderFns;\n  var currentStaticRenderFns = staticRenderFns = [];\n  var prevOnceCount = onceCount;\n  onceCount = 0;\n  currentOptions = options;\n  warn$2 = options.warn || baseWarn;\n  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n  dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  platformDirectives$1 = options.directives || {};\n  isPlatformReservedTag$1 = options.isReservedTag || no;\n  var code = ast ? genElement(ast) : '_c(\"div\")';\n  staticRenderFns = prevStaticRenderFns;\n  onceCount = prevOnceCount;\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: currentStaticRenderFns\n  }\n}\n\nfunction genElement (el) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el);\n    } else {\n      var data = el.plain ? undefined : genData(el);\n\n      var children = el.inlineTemplate ? null : genChildren(el, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < transforms$1.length; i++) {\n      code = transforms$1[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el) {\n  el.staticProcessed = true;\n  staticRenderFns.push((\"with(this){return \" + (genElement(el)) + \"}\"));\n  return (\"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && warn$2(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el)\n    }\n    return (\"_o(\" + (genElement(el)) + \",\" + (onceCount++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el)\n  }\n}\n\nfunction genIf (el) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice())\n}\n\nfunction genIfConditions (conditions) {\n  if (!conditions.length) {\n    return '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return el.once ? genOnce(el) : genElement(el)\n  }\n}\n\nfunction genFor (el) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genElement(el)) +\n    '})'\n}\n\nfunction genData (el) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < dataGenFns.length; i++) {\n    data += dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots)) + \",\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  return data\n}\n\nfunction genDirectives (el) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, warn$2);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el) {\n  var ast = el.children[0];\n  if (false) {\n    warn$2('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, currentOptions);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (slots) {\n  return (\"scopedSlots:{\" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + \"}\")\n}\n\nfunction genScopedSlot (key, el) {\n  return key + \":function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el) || 'void 0'\n      : genElement(el)) + \"}\"\n}\n\nfunction genChildren (el, checkSkip) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot') {\n      return genElement(el$1)\n    }\n    var normalizationType = getNormalizationType(children);\n    return (\"[\" + (children.map(genNode).join(',')) + \"]\" + (checkSkip\n        ? normalizationType ? (\",\" + normalizationType) : ''\n        : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (children) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction maybeComponent (el) {\n  return !isPlatformReservedTag$1(el.tag)\n}\n\nfunction genNode (node) {\n  if (node.type === 1) {\n    return genElement(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genSlot (el) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (componentName, el) {\n  var children = el.inlineTemplate ? null : genChildren(el, true);\n  return (\"_c(\" + componentName + \",\" + (genData(el)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n/**\n * Compile a template.\n */\nfunction compile$1 (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n}\n\n/*  */\n\n// operators like typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"- invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"- avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + text\n      );\n    } else {\n      errors.push((\"- invalid expression: \" + text));\n    }\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData$1\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$2 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$2\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nvar warn$3;\n\nfunction model$1 (\n  el,\n  dir,\n  _warn\n) {\n  warn$3 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$3(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n  }\n  if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else {\n    genDefaultModel(el, value, modifiers);\n  }\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  if (false) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, 'click',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + value + \"=$$c}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  if (false) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" checked>:\\n\" +\n      \"inline checked attributes will be ignored when using v-model. \" +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n  }\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'click', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  if (false) {\n    if (el.tag === 'input' && el.attrsMap.value) {\n      warn$3(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" value=\\\"\" + (el.attrsMap.value) + \"\\\">:\\n\" +\n        'inline value attributes will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n    if (el.tag === 'textarea' && el.children.length) {\n      warn$3(\n        \"<textarea v-model=\\\"\" + value + \"\\\">:\\n\" +\n        'inline content inside <textarea> will be ignored when using v-model. ' +\n        'Declare initial values in the component\\'s data option instead.'\n      );\n    }\n  }\n\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var event = lazy || (isIE && type === 'range') ? 'change' : 'input';\n  var needCompositionGuard = !lazy && type !== 'range';\n  var isNative = el.tag === 'input' || el.tag === 'textarea';\n\n  var valueExpression = isNative\n    ? (\"$event.target.value\" + (trim ? '.trim()' : ''))\n    : trim ? \"(typeof $event === 'string' ? $event.trim() : $event)\" : \"$event\";\n  valueExpression = number || type === 'number'\n    ? (\"_n(\" + valueExpression + \")\")\n    : valueExpression;\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (isNative && needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  // inputs with type=\"file\" are read only and setting the input's\n  // value will throw an error.\n  if (false) {\n    warn$3(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n      \"File inputs are read only. Use a v-on:change listener instead.\"\n    );\n  }\n\n  addProp(el, 'value', isNative ? (\"_s(\" + value + \")\") : (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number || type === 'number') {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  if (false) {\n    el.children.some(checkOptionWarning);\n  }\n\n  var number = modifiers && modifiers.number;\n  var assignment = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\" +\n    (el.attrsMap.multiple == null ? '[0]' : '');\n\n  var code = genAssignmentCode(value, assignment);\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction checkOptionWarning (option) {\n  if (option.type === 1 &&\n    option.tag === 'option' &&\n    option.attrsMap.selected != null) {\n    warn$3(\n      \"<select v-model=\\\"\" + (option.parent.attrsMap['v-model']) + \"\\\">:\\n\" +\n      'inline selected attributes on <option> will be ignored when using v-model. ' +\n      'Declare initial values in the component\\'s data option instead.'\n    );\n    return true\n  }\n  return false\n}\n\nfunction genAssignmentCode (value, assignment) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return \"var $$exp = \" + (modelRs.exp) + \", $$idx = \" + (modelRs.idx) + \";\" +\n      \"if (!Array.isArray($$exp)){\" +\n        value + \"=\" + assignment + \"}\" +\n      \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\"\n  }\n}\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model$1,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar cache = Object.create(null);\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  staticKeys: genStaticKeys(modules$1),\n  directives: directives$1,\n  isReservedTag: isReservedTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  getTagNamespace: getTagNamespace,\n  isPreTag: isPreTag\n};\n\nfunction compile$$1 (\n  template,\n  options\n) {\n  options = options\n    ? extend(extend({}, baseOptions), options)\n    : baseOptions;\n  return compile$1(template, options)\n}\n\nfunction compileToFunctions (\n  template,\n  options,\n  vm\n) {\n  var _warn = (options && options.warn) || warn;\n  // detect possible CSP restriction\n  /* istanbul ignore if */\n  if (false) {\n    try {\n      new Function('return 1');\n    } catch (e) {\n      if (e.toString().match(/unsafe-eval|CSP/)) {\n        _warn(\n          'It seems you are using the standalone build of Vue.js in an ' +\n          'environment with Content Security Policy that prohibits unsafe-eval. ' +\n          'The template compiler cannot work in this environment. Consider ' +\n          'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n          'templates into render functions.'\n        );\n      }\n    }\n  }\n  var key = options && options.delimiters\n    ? String(options.delimiters) + template\n    : template;\n  if (cache[key]) {\n    return cache[key]\n  }\n  var res = {};\n  var compiled = compile$$1(template, options);\n  res.render = makeFunction(compiled.render);\n  var l = compiled.staticRenderFns.length;\n  res.staticRenderFns = new Array(l);\n  for (var i = 0; i < l; i++) {\n    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]);\n  }\n  if (false) {\n    if (res.render === noop || res.staticRenderFns.some(function (fn) { return fn === noop; })) {\n      _warn(\n        \"failed to compile template:\\n\\n\" + template + \"\\n\\n\" +\n        detectErrors(compiled.ast).join('\\n') +\n        '\\n\\n',\n        vm\n      );\n    }\n  }\n  return (cache[key] = res)\n}\n\nfunction makeFunction (code) {\n  try {\n    return new Function(code)\n  } catch (e) {\n    return noop\n  }\n}\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      var ref = compileToFunctions(template, {\n        warn: warn,\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nmodule.exports = Vue$3;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../webpack/buildin/global.js */ 27)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanM/ZjlhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFZ1ZS5qcyB2Mi4xLjEwXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyogICovXG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIF90b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlJDEgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsdWUgaXMgcHJpbWl0aXZlXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQkMSAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG4gIC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkge1xuICAgIHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcbiAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBPQkpFQ1RfU1RSSU5HID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gT0JKRUNUX1NUUklOR1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogTGlzdCBvZiBhc3NldCB0eXBlcyB0aGF0IGEgY29tcG9uZW50IGNhbiBvd24uXG4gICAqL1xuICBfYXNzZXRUeXBlczogW1xuICAgICdjb21wb25lbnQnLFxuICAgICdkaXJlY3RpdmUnLFxuICAgICdmaWx0ZXInXG4gIF0sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbGlmZWN5Y2xlIGhvb2tzLlxuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBbXG4gICAgJ2JlZm9yZUNyZWF0ZScsXG4gICAgJ2NyZWF0ZWQnLFxuICAgICdiZWZvcmVNb3VudCcsXG4gICAgJ21vdW50ZWQnLFxuICAgICdiZWZvcmVVcGRhdGUnLFxuICAgICd1cGRhdGVkJyxcbiAgICAnYmVmb3JlRGVzdHJveScsXG4gICAgJ2Rlc3Ryb3llZCcsXG4gICAgJ2FjdGl2YXRlZCcsXG4gICAgJ2RlYWN0aXZhdGVkJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBNYXggY2lyY3VsYXIgdXBkYXRlcyBhbGxvd2VkIGluIGEgc2NoZWR1bGVyIGZsdXNoIGN5Y2xlLlxuICAgKi9cbiAgX21heFVwZGF0ZUNvdW50OiAxMDBcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG4vKipcbiAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuICovXG52YXIgbmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG4gIHZhciBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29waWVzW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHZhciBsb2dFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB9O1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcbiAgICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzTmF0aXZlKE11dGF0aW9uT2JzZXJ2ZXIpIHx8XG4gICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgTXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuICApKSB7XG4gICAgLy8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUyBJRTExLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikgeyBjYi5jYWxsKGN0eCk7IH1cbiAgICAgIGlmIChfcmVzb2x2ZSkgeyBfcmVzb2x2ZShjdHgpOyB9XG4gICAgfSk7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyBcIiBcIiArIChcbiAgICAgICAgdm0gPyBmb3JtYXRMb2NhdGlvbihmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJ3Jvb3QgaW5zdGFuY2UnXG4gICAgfVxuICAgIHZhciBuYW1lID0gdm0uX2lzVnVlXG4gICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgOiB2bS5uYW1lO1xuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcImNvbXBvbmVudCA8XCIgKyBuYW1lICsgXCI+XCIpIDogXCJhbm9ueW1vdXMgY29tcG9uZW50XCIpICtcbiAgICAgICh2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlID8gKFwiIGF0IFwiICsgKHZtLiRvcHRpb25zLl9fZmlsZSkpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciBmb3JtYXRMb2NhdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSAnYW5vbnltb3VzIGNvbXBvbmVudCcpIHtcbiAgICAgIHN0ciArPSBcIiAtIHVzZSB0aGUgXFxcIm5hbWVcXFwiIG9wdGlvbiBmb3IgYmV0dGVyIGRlYnVnZ2luZyBtZXNzYWdlcy5cIjtcbiAgICB9XG4gICAgcmV0dXJuIChcIlxcbihmb3VuZCBpbiBcIiArIHN0ciArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlJDEodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIC8vIGF2b2lkIGxlYWtpbmcgYXJndW1lbnRzOlxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcbiAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgdmFyIGluc2VydGVkO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZSxcbiAgaXNTZXR0aW5nUHJvcHM6IGZhbHNlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQkMSAob2JqLCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgb2JqLmxlbmd0aCA9IE1hdGgubWF4KG9iai5sZW5ndGgsIGtleSk7XG4gICAgb2JqLnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gb2JqLl9fb2JfXztcbiAgaWYgKG9iai5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghb2IpIHtcbiAgICBvYmpba2V5XSA9IHZhbDtcbiAgICByZXR1cm5cbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKG9iaiwga2V5KSB7XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmIChvYmouX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bihvYmosIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgb2JqW2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQkMSh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIGNoaWxkVmFsLmNhbGwodGhpcyksXG4gICAgICAgIHBhcmVudFZhbC5jYWxsKHRoaXMpXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHBhcmFtIGF0dHJpYnV0ZXMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbmNvbmZpZy5fbGlmZWN5Y2xlSG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICAgIDogcmVzXG59XG5cbmNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBwYXJlbnRWYWwgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gcGFyZW50VmFsIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGV4dGVuZChyZXQsIGNoaWxkVmFsKTtcbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGlzQnVpbHRJblRhZyhsb3dlcikgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobG93ZXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2lkOiAnICsga2V5XG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMpIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IHR5cGVvZiBleHRlbmRzRnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbS5vcHRpb25zLCB2bSlcbiAgICAgIDogbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgbWl4aW4gPSBjaGlsZC5taXhpbnNbaV07XG4gICAgICBpZiAobWl4aW4ucHJvdG90eXBlIGluc3RhbmNlb2YgVnVlJDMpIHtcbiAgICAgICAgbWl4aW4gPSBtaXhpbi5vcHRpb25zO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgbWl4aW4sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm1ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZtW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wLnR5cGUgIT09IEZ1bmN0aW9uXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuXG5cbnZhciB1dGlsID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMSxcblx0X3RvU3RyaW5nOiBfdG9TdHJpbmcsXG5cdHRvTnVtYmVyOiB0b051bWJlcixcblx0bWFrZU1hcDogbWFrZU1hcCxcblx0aXNCdWlsdEluVGFnOiBpc0J1aWx0SW5UYWcsXG5cdHJlbW92ZTogcmVtb3ZlJDEsXG5cdGhhc093bjogaGFzT3duLFxuXHRpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG5cdGNhY2hlZDogY2FjaGVkLFxuXHRjYW1lbGl6ZTogY2FtZWxpemUsXG5cdGNhcGl0YWxpemU6IGNhcGl0YWxpemUsXG5cdGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuXHRiaW5kOiBiaW5kJDEsXG5cdHRvQXJyYXk6IHRvQXJyYXksXG5cdGV4dGVuZDogZXh0ZW5kLFxuXHRpc09iamVjdDogaXNPYmplY3QsXG5cdGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG5cdHRvT2JqZWN0OiB0b09iamVjdCxcblx0bm9vcDogbm9vcCxcblx0bm86IG5vLFxuXHRpZGVudGl0eTogaWRlbnRpdHksXG5cdGdlblN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGxvb3NlSW5kZXhPZjogbG9vc2VJbmRleE9mLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRkZWY6IGRlZixcblx0cGFyc2VQYXRoOiBwYXJzZVBhdGgsXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdFVBOiBVQSxcblx0aXNJRTogaXNJRSxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0VkZ2U6IGlzRWRnZSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGlzSU9TOiBpc0lPUyxcblx0aXNTZXJ2ZXJSZW5kZXJpbmc6IGlzU2VydmVyUmVuZGVyaW5nLFxuXHRkZXZ0b29sczogZGV2dG9vbHMsXG5cdG5leHRUaWNrOiBuZXh0VGljayxcblx0Z2V0IF9TZXQgKCkgeyByZXR1cm4gX1NldDsgfSxcblx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdHJlc29sdmVBc3NldDogcmVzb2x2ZUFzc2V0LFxuXHRnZXQgd2FybiAoKSB7IHJldHVybiB3YXJuOyB9LFxuXHRnZXQgZm9ybWF0Q29tcG9uZW50TmFtZSAoKSB7IHJldHVybiBmb3JtYXRDb21wb25lbnROYW1lOyB9LFxuXHR2YWxpZGF0ZVByb3A6IHZhbGlkYXRlUHJvcFxufSk7XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgIFwicmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdG8gZGVjbGFyZSByZWFjdGl2ZSBkYXRhIFwiICtcbiAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YScpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBjb250ZXh0LFxuICBjb21wb25lbnRPcHRpb25zXG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9ICcnO1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnNcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMpIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGhvb2tzID0geyBpbml0OiBpbml0LCBwcmVwYXRjaDogcHJlcGF0Y2gsIGluc2VydDogaW5zZXJ0LCBkZXN0cm95OiBkZXN0cm95JDEgfTtcbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhob29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoIUN0b3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIGlmICghQ3Rvci5jaWQpIHtcbiAgICBpZiAoQ3Rvci5yZXNvbHZlZCkge1xuICAgICAgQ3RvciA9IEN0b3IucmVzb2x2ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoQ3RvciwgYmFzZUN0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaXQncyBvayB0byBxdWV1ZSB0aGlzIG9uIGV2ZXJ5IHJlbmRlciBiZWNhdXNlXG4gICAgICAgIC8vICRmb3JjZVVwZGF0ZSBpcyBidWZmZXJlZCBieSB0aGUgc2NoZWR1bGVyLlxuICAgICAgICBjb250ZXh0LiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIUN0b3IpIHtcbiAgICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gZXh0cmFjdCBwcm9wc1xuICB2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzKGRhdGEsIEN0b3IpO1xuXG4gIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIGlmIChDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cbiAgaWYgKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKHByb3BPcHRpb25zKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgZGF0YTogZGF0YSxcbiAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlubGluZVRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBpbml0IChcbiAgdm5vZGUsXG4gIGh5ZHJhdGluZyxcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgIHZub2RlLFxuICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICBwYXJlbnRFbG0sXG4gICAgICByZWZFbG1cbiAgICApO1xuICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGF0Y2ggKFxuICBvbGRWbm9kZSxcbiAgdm5vZGVcbikge1xuICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gIGNoaWxkLl91cGRhdGVGcm9tUGFyZW50KFxuICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICB9XG4gIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGNhbGxIb29rKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSQxICh2bm9kZSkge1xuICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjYlxuKSB7XG4gIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VDdG9yLmV4dGVuZChyZXMpO1xuICAgICAgfVxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIC8vIGhhbmRsZSBwcm9taXNlXG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgIWZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wcyAoZGF0YSwgQ3Rvcikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wT3B0aW9ucykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcbiAgaWYgKGF0dHJzIHx8IHByb3BzIHx8IGRvbVByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBkb21Qcm9wcywga2V5LCBhbHRLZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGhhc2gpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBob29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaywga2V5KSB7XG4gIGtleSA9IGtleSArIGhvb2tLZXk7XG4gIHZhciBpbmplY3RlZEhhc2ggPSBkZWYuX19pbmplY3RlZCB8fCAoZGVmLl9faW5qZWN0ZWQgPSB7fSk7XG4gIGlmICghaW5qZWN0ZWRIYXNoW2tleV0pIHtcbiAgICBpbmplY3RlZEhhc2hba2V5XSA9IHRydWU7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG4gICAgaWYgKG9sZEhvb2spIHtcbiAgICAgIGRlZltob29rS2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2xkSG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZbaG9va0tleV0gPSBob29rO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlLFxuICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SGFuZGxlIChmbikge1xuICB2YXIgaGFuZGxlID0ge1xuICAgIGZuOiBmbixcbiAgICBpbnZva2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBmbiA9IGhhbmRsZS5mbjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZuKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm5baV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhbmRsZVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFjdXIpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIW9sZCkge1xuICAgICAgaWYgKCFjdXIuaW52b2tlcikge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUV2ZW50SGFuZGxlKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLmludm9rZXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbiA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoIW9uW25hbWVdKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLmludm9rZXIsIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vbXJhbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RyY3V0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoYyA9PSBudWxsIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChsYXN0ICYmIGxhc3QudGV4dCkge1xuICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgJiYgYy5jb21wb25lbnRPcHRpb25zOyB9KVswXVxufVxuXG4vKiAgKi9cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xudmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGUsXG4gIGFsd2F5c05vcm1hbGl6ZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBjaGlsZHJlbjtcbiAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYWx3YXlzTm9ybWFsaXplKSB7IG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTsgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoZGF0YSAmJiBkYXRhLl9fb2JfXykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmICh2bm9kZSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmICh2bm9kZS5jaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgJiYgIWNoaWxkLm5zKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0ge307XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJldHVybiBuZXh0VGljayhmbiwgdGhpcylcbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgdmFyIHN0YXRpY1JlbmRlckZucyA9IHJlZi5zdGF0aWNSZW5kZXJGbnM7XG4gICAgdmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgLy8gY2xvbmUgc2xvdCBub2RlcyBvbiByZS1yZW5kZXJzXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG4gICAgICAgIHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICAgIH1cblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlLCB2bSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiRXJyb3Igd2hlbiByZW5kZXJpbmcgXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCI6XCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlXG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gdG9TdHJpbmcgZm9yIG11c3RhY2hlc1xuICBWdWUucHJvdG90eXBlLl9zID0gX3RvU3RyaW5nO1xuICAvLyBjb252ZXJ0IHRleHQgdG8gdm5vZGVcbiAgVnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgLy8gbnVtYmVyIGNvbnZlcnNpb25cbiAgVnVlLnByb3RvdHlwZS5fbiA9IHRvTnVtYmVyO1xuICAvLyBlbXB0eSB2bm9kZVxuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgLy8gbG9vc2UgZXF1YWxcbiAgVnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG4gIC8vIGxvb3NlIGluZGV4T2ZcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcblxuICAvLyByZW5kZXIgc3RhdGljIHRyZWUgYnkgaW5kZXhcbiAgVnVlLnByb3RvdHlwZS5fbSA9IGZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gICAgaW5kZXgsXG4gICAgaXNJbkZvclxuICApIHtcbiAgICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfTtcblxuICAvLyBtYXJrIG5vZGUgYXMgc3RhdGljICh2LW9uY2UpXG4gIFZ1ZS5wcm90b3R5cGUuX28gPSBmdW5jdGlvbiBtYXJrT25jZSAoXG4gICAgdHJlZSxcbiAgICBpbmRleCxcbiAgICBrZXlcbiAgKSB7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRyZWVcbiAgfTtcblxuICBmdW5jdGlvbiBtYXJrU3RhdGljICh0cmVlLCBrZXksIGlzT25jZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICAgIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICAgIG5vZGUua2V5ID0ga2V5O1xuICAgIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xuICB9XG5cbiAgLy8gZmlsdGVyIHJlc29sdXRpb24gaGVscGVyXG4gIFZ1ZS5wcm90b3R5cGUuX2YgPSBmdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbiAgfTtcblxuICAvLyByZW5kZXIgdi1mb3JcbiAgVnVlLnByb3RvdHlwZS5fbCA9IGZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICAgIHZhbCxcbiAgICByZW5kZXJcbiAgKSB7XG4gICAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG5cbiAgLy8gcmVuZGVyU2xvdFxuICBWdWUucHJvdG90eXBlLl90ID0gZnVuY3Rpb24gKFxuICAgIG5hbWUsXG4gICAgZmFsbGJhY2ssXG4gICAgcHJvcHMsXG4gICAgYmluZE9iamVjdFxuICApIHtcbiAgICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gICAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICAgIGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgICBpZiAoc2xvdE5vZGVzICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNsb3ROb2RlcyB8fCBmYWxsYmFja1xuICAgIH1cbiAgfTtcblxuICAvLyBhcHBseSB2LWJpbmQgb2JqZWN0XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBmdW5jdGlvbiBiaW5kUHJvcHMgKFxuICAgIGRhdGEsXG4gICAgdGFnLFxuICAgIHZhbHVlLFxuICAgIGFzUHJvcFxuICApIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgICAgdmFyIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfTtcblxuICAvLyBjaGVjayB2LW9uIGtleUNvZGVzXG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBmdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgICBldmVudEtleUNvZGUsXG4gICAga2V5LFxuICAgIGJ1aWx0SW5BbGlhc1xuICApIHtcbiAgICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG4gICAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICB2YXIgbmFtZSwgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBjaGlsZC5kYXRhICYmIChuYW1lID0gY2hpbGQuZGF0YS5zbG90KSkge1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2luZ2xlIHdoaXRlc3BhY2VcbiAgaWYgKGRlZmF1bHRTbG90Lmxlbmd0aCAmJiAhKFxuICAgIGRlZmF1bHRTbG90Lmxlbmd0aCA9PT0gMSAmJlxuICAgIChkZWZhdWx0U2xvdFswXS50ZXh0ID09PSAnICcgfHwgZGVmYXVsdFNsb3RbMF0uaXNDb21tZW50KVxuICApKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCQxIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQkMSwgcmVtb3ZlJDIsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7KHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICB2YXIgY2I7XG4gICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNiID0gY2JzW2ldO1xuICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgY2JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2JzW2ldLmFwcGx5KHZtLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX21vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZtLiRlbCA9IGVsO1xuICAgIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgICAnb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuICAgIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudCAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9LCBub29wKTtcbiAgICBoeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAgIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XG4gICAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIChcbiAgICBwcm9wc0RhdGEsXG4gICAgbGlzdGVuZXJzLFxuICAgIHBhcmVudFZub2RlLFxuICAgIHJlbmRlckNoaWxkcmVuXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIGhhc0NoaWxkcmVuID0gISEodm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IHJlbmRlckNoaWxkcmVuKTtcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICAgIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG4gICAgLy8gdXBkYXRlIHByb3BzXG4gICAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgICB2bVtrZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgICAgfVxuICAgICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICAgIH1cbiAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICAgIGlmIChoYXNDaGlsZHJlbikge1xuICAgICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUkMShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgIH1cbiAgfVxuICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgcXVldWUgPSBbXTtcbnZhciBoYXMkMSA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG4gIGhhcyQxID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkLCB2bTtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXMkMVtpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhcyQxW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBjb25maWcuX21heFVwZGF0ZUNvdW50KSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGwgdXBkYXRlZCBob29rc1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXMkMVtpZF0gPT0gbnVsbCkge1xuICAgIGhhcyQxW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID49IDAgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShNYXRoLm1heChpLCBpbmRleCkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy52bSwgdGhpcy52bSk7XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZSwgdGhpcy52bSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgICAgICAgKFwiRXJyb3IgaW4gd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSxcbiAgICAgICAgICAgICAgdGhpcy52bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlJDEodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHsga2V5OiAxLCByZWY6IDEsIHNsb3Q6IDEgfTtcblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRQcm9wW2tleV0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgdmFsaWRhdGVQcm9wKGtleSwgcHJvcHMsIHByb3BzRGF0YSwgdm0pLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHZhbGlkYXRlUHJvcChrZXksIHByb3BzLCBwcm9wc0RhdGEsIHZtKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykgbG9vcCggaSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZGF0YS5jYWxsKHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdDpcXG4nICtcbiAgICAgICdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3h5KHZtLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxudmFyIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5IGluIHZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImV4aXN0aW5nIGluc3RhbmNlIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiB3aWxsIGJlIFwiICtcbiAgICAgICAgXCJvdmVyd3JpdHRlbiBieSBhIGNvbXB1dGVkIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZS5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5nZXQgPSBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZiwgdm0pO1xuICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICA/IHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICAgIDogYmluZCQxKHVzZXJEZWYuZ2V0LCB2bSlcbiAgICAgICAgOiBub29wO1xuICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICAgID8gYmluZCQxKHVzZXJEZWYuc2V0LCB2bSlcbiAgICAgICAgOiBub29wO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodm0sIGtleSwgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIgKGdldHRlciwgb3duZXIpIHtcbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBub29wLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgIH1cbiAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZCQxKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgXCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAodm0sIGtleSwgaGFuZGxlcikge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgdm0uJHdhdGNoKGtleSwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFcbiAgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldCQxO1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm94eSAodm0sIGtleSkge1xuICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgICAgIHJldHVybiB2bS5fZGF0YVtrZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICAgIHZtLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlci5vcHRpb25zO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICB2YXIgZXh0ZW5kT3B0aW9ucyA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIGV4dGVuZE9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBleHRlbmRPcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgZXh0ZW5kT3B0aW9ucy5fc2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMykpIHtcbiAgICB3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG4gIH1cbiAgdGhpcy5faW5pdChvcHRpb25zKTtcbn1cblxuaW5pdE1peGluKFZ1ZSQzKTtcbnN0YXRlTWl4aW4oVnVlJDMpO1xuZXZlbnRzTWl4aW4oVnVlJDMpO1xubGlmZWN5Y2xlTWl4aW4oVnVlJDMpO1xucmVuZGVyTWl4aW4oVnVlJDMpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwXTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGZpbHRlcikge1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2luYWN0aXZlKSB7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZVtrZXldKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcbiAgVnVlLnV0aWwgPSB1dGlsO1xuICBWdWUuc2V0ID0gc2V0JDE7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi4xLjEwJztcblxuLyogICovXG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGNoaWxkLmNsYXNzXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG4gIHZhciBkeW5hbWljQ2xhc3MgPSBkYXRhLmNsYXNzO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuICBpZiAoc3RhdGljQ2xhc3MgfHwgZHluYW1pY0NsYXNzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgc3RyaW5naWZpZWQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSkge1xuICAgICAgICBpZiAoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlciwnICtcbiAgJ2ZvbnQtZmFjZSxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWw7XG4gICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3JcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiAnbXVsdGlwbGUnIGluIHZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUkMShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuXG4vKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzJDEgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gaXNVbmRlZiAocykge1xuICByZXR1cm4gcyA9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmIChzKSB7XG4gIHJldHVybiBzICE9IG51bGxcbn1cblxuZnVuY3Rpb24gc2FtZVZub2RlICh2bm9kZTEsIHZub2RlMikge1xuICByZXR1cm4gKFxuICAgIHZub2RlMS5rZXkgPT09IHZub2RlMi5rZXkgJiZcbiAgICB2bm9kZTEudGFnID09PSB2bm9kZTIudGFnICYmXG4gICAgdm5vZGUxLmlzQ29tbWVudCA9PT0gdm5vZGUyLmlzQ29tbWVudCAmJlxuICAgICF2bm9kZTEuZGF0YSA9PT0gIXZub2RlMi5kYXRhXG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcyQxLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzJDFbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChtb2R1bGVzW2pdW2hvb2tzJDFbaV1dICE9PSB1bmRlZmluZWQpIHsgY2JzW2hvb2tzJDFbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rcyQxW2ldXSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLmlzQ29tbWVudCkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzUmVhY3RpdmF0ZWQpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpLmNyZWF0ZSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGkuaW5zZXJ0KSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKHJtIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKCFybSkge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgaGF2ZSBhIHJlY3Vyc2l2ZWx5IHBhc3NlZCBkb3duIHJtIGNhbGxiYWNrXG4gICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgcm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuICAgIHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxtVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAodm5vZGUuaXNTdGF0aWMgJiZcbiAgICAgICAgb2xkVm5vZGUuaXNTdGF0aWMgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKHZub2RlLmlzQ2xvbmVkIHx8IHZub2RlLmlzT25jZSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBoYXNEYXRhID0gaXNEZWYoZGF0YSk7XG4gICAgaWYgKGhhc0RhdGEgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGhhc0RhdGEgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChoYXNEYXRhKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpbml0aWFsICYmIHZub2RlLnBhcmVudCkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBiYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhYmFpbGVkKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmICghdm5vZGUpIHtcbiAgICAgIGlmIChvbGRWbm9kZSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmICghb2xkVm5vZGUpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJykpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJyk7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaHlkcmF0aW5nKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh2bm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudEVsbSQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0LCAnZGlyLWluc2VydCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSwgJ2Rpci1wb3N0cGF0Y2gnKTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKCFvbGRWbm9kZS5kYXRhLmF0dHJzICYmICF2bm9kZS5kYXRhLmF0dHJzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoYXR0cnMuX19vYl9fKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChhdHRyc1trZXldID09IG51bGwpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoIWRhdGEuc3RhdGljQ2xhc3MgJiYgIWRhdGEuY2xhc3MgJiZcbiAgICAgICghb2xkRGF0YSB8fCAoIW9sZERhdGEuc3RhdGljQ2xhc3MgJiYgIW9sZERhdGEuY2xhc3MpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKHRyYW5zaXRpb25DbGFzcykge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGFkZCQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UsXG4gIGNhcHR1cmVcbikge1xuICBpZiAob25jZSkge1xuICAgIHZhciBvbGRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICB2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJlbW92ZSQzKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICAgICAgPyBvbGRIYW5kbGVyKGV2KVxuICAgICAgICA6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMyAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBjYXB0dXJlLFxuICBfdGFyZ2V0XG4pIHtcbiAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDIsIHJlbW92ZSQzLCB2bm9kZS5jb250ZXh0KTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuZG9tUHJvcHMgJiYgIXZub2RlLmRhdGEuZG9tUHJvcHMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAocHJvcHMuX19vYl9fKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmIChwcm9wc1trZXldID09IG51bGwpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIHByb3BzKSB7XG4gICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcbiAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XG4gICAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZCh2bm9kZSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlydHkgKGVsbSwgY2hlY2tWYWwpIHtcbiAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcbiAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkICh2bm9kZSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IHZub2RlLmVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IHZub2RlLmVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IHZub2RlLmVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIGVsLnN0eWxlW25vcm1hbGl6ZShuYW1lKV0gPSB2YWw7XG4gIH1cbn07XG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgdGVzdEVsO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICB0ZXN0RWwgPSB0ZXN0RWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcbiAgICBpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmICghZGF0YS5zdGF0aWNTdHlsZSAmJiAhZGF0YS5zdHlsZSAmJlxuICAgICAgIW9sZERhdGEuc3RhdGljU3R5bGUgJiYgIW9sZERhdGEuc3R5bGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkVm5vZGUuZGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZFZub2RlLmRhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICB2bm9kZS5kYXRhLnN0eWxlID0gc3R5bGUuX19vYl9fID8gZXh0ZW5kKHt9LCBzdHlsZSkgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlW25hbWVdID09IG51bGwpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIWNscy50cmltKCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJyAnO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICFjbHMudHJpbSgpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9ICcgJyArIGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSArICcgJztcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICA6IHNldFRpbWVvdXQ7XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKSkucHVzaChjbHMpO1xuICBhZGRDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUkMShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25lRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbmVEZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGVsLl9sZWF2ZUNiKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwuX2VudGVyQ2IgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgPyBhcHBlYXJDbGFzcyA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyID8gYXBwZWFyQWN0aXZlQ2xhc3MgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyID8gYXBwZWFyVG9DbGFzcyA6IGVudGVyVG9DbGFzcztcbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcikgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcikgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcikgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXIgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKSA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID1cbiAgICBlbnRlckhvb2sgJiZcbiAgICAvLyBlbnRlckhvb2sgbWF5IGJlIGEgYm91bmQgbWV0aG9kIHdoaWNoIGV4cG9zZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcbiAgICAoZW50ZXJIb29rLl9sZW5ndGggfHwgZW50ZXJIb29rLmxlbmd0aCkgPiAxO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSwgJ3RyYW5zaXRpb24taW5zZXJ0Jyk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID1cbiAgICBsZWF2ZSAmJlxuICAgIC8vIGxlYXZlIGhvb2sgbWF5IGJlIGEgYm91bmQgbWV0aG9kIHdoaWNoIGV4cG9zZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcbiAgICAobGVhdmUuX2xlbmd0aCB8fCBsZWF2ZS5sZW5ndGgpID4gMTtcblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVt2bm9kZS5rZXldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGFwcGVhckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgYXBwZWFyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKSxcbiAgICBhcHBlYXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIilcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCQxID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbi8qKlxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICovXG5cbnZhciBtb2RlbGFibGVUYWdSRSA9IC9eaW5wdXR8c2VsZWN0fHRleHRhcmVhfHZ1ZS1jb21wb25lbnQtWzAtOV0rKC1bMC05YS16QS1aXy1dKik/JC87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKGlzSUU5KSB7XG4gIC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgbW9kZWwgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghbW9kZWxhYmxlVGFnUkUudGVzdCh2bm9kZS50YWcpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gZWxlbWVudCB0eXBlOiA8XCIgKyAodm5vZGUudGFnKSArIFwiPi4gXCIgK1xuICAgICAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLFxuICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfTtcbiAgICAgIGNiKCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGNiLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgaWYgKCFpc0FuZHJvaWQpIHtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoaXNJRTkpIHtcbiAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICB2YXIgb2xkVmFsdWUgPSByZWYub2xkVmFsdWU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdLmZuO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICByZXR1cm4gL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpXG4gICAgPyBoKCdrZWVwLWFsaXZlJylcbiAgICA6IG51bGxcbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZzsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIHZhciBrZXkgPSBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9LCBrZXkpO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSwga2V5KTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlLCBrZXkpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkge1xuICAgICAgICAgIGRlbGF5ZWRMZWF2ZSA9IGxlYXZlO1xuICAgICAgICB9LCBrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRpc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHNcbiAgICAgICAgICAgID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG4gICAgICAgICAgICA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgdmFyIGYgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2gkMSA6IG5vb3A7XG5cbi8vIHdyYXAgbW91bnRcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHRoaXMuX21vdW50KGVsLCBoeWRyYXRpbmcpXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgKTtcbn1cblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgaW5Ccm93c2VyICYmICFpc0VkZ2UgJiYgL0Nocm9tZVxcL1xcZCsvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKSB7XG4gICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG59LCAwKTtcblxuLyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5mdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcbiAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIj5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcbn1cblxuLy8gIzM2NjNcbi8vIElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcbiAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcbn1cblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInLFxuICB0cnVlXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnLFxuICB0cnVlXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snLFxuICB0cnVlXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIHNpbmdsZUF0dHJJZGVudGlmaWVyID0gLyhbXlxcc1wiJzw+Lz1dKykvO1xudmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xudmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG4gIC8vIGF0dHIgdmFsdWUgZG91YmxlIHF1b3Rlc1xuICAvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuICAvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG4gIC8nKFteJ10qKScrLy5zb3VyY2UsXG4gIC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuICAvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5dO1xudmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG4gICdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG4gICcoPzpcXFxccyooJyArIHNpbmdsZUF0dHJBc3NpZ24uc291cmNlICsgJyknICtcbiAgJ1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG4pO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG52YXIgbmNuYW1lID0gJ1thLXpBLVpfXVtcXFxcd1xcXFwtXFxcXC5dKic7XG52YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xudmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNTY3JpcHRPclN0eWxlID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgbHRSRSA9IC8mbHQ7L2c7XG52YXIgZ3RSRSA9IC8mZ3Q7L2c7XG52YXIgbmxSRSA9IC8mIzEwOy9nO1xudmFyIGFtcFJFID0gLyZhbXA7L2c7XG52YXIgcXVvdGVSRSA9IC8mcXVvdDsvZztcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIGlmIChzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShubFJFLCAnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2UobHRSRSwgJzwnKVxuICAgIC5yZXBsYWNlKGd0UkUsICc+JylcbiAgICAucmVwbGFjZShhbXBSRSwgJyYnKVxuICAgIC5yZXBsYWNlKHF1b3RlUkUsICdcIicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgc2NyaXB0IG9yIHN0eWxlIGVsZW1lbnRcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzU2NyaXB0T3JTdHlsZShsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPiAwKSB7XG4gICAgICAgIHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCQxKSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0JDEpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QkMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFja2VkVGFnICE9PSAnc2NyaXB0JyAmJiBzdGFja2VkVGFnICE9PSAnc3R5bGUnICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0O1xuICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaHRtbCA9PT0gbGFzdCAmJiBvcHRpb25zLmNoYXJzKSB7XG4gICAgICBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuICAgICAgaWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG4gICAgICAgIGlmIChhcmdzWzNdID09PSAnJykgeyBkZWxldGUgYXJnc1szXTsgfVxuICAgICAgICBpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cbiAgICAgICAgaWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzXG4gICAgICAgIClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIHVuYXJ5U2xhc2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIS9bXFx3JF0vLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXG4pKz8pXFx9XFx9L2c7XG52YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbnZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG4gIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG4gIHZhciBtYXRjaCwgaW5kZXg7XG4gIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgIGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgLy8gcHVzaCB0ZXh0IHRva2VuXG4gICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG4gICAgfVxuICAgIC8vIHRhZyB0b2tlblxuICAgIHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcbiAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH1cbiAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucy5qb2luKCcrJylcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIHBhcnNlcl06IFwiICsgbXNnKSk7XG59XG5cbmZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuICBtb2R1bGVzLFxuICBrZXlcbikge1xuICByZXR1cm4gbW9kdWxlc1xuICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnRcbikge1xuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG4gICAgbmFtZSA9ICchJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG4gIH1cbiAgaWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG4gIHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG4gIHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGhhbmRsZXJzKSB7XG4gICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzW25hbWVdID0gbmV3SGFuZGxlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxudmFyIGxlbjtcbnZhciBzdHI7XG52YXIgY2hyO1xudmFyIGluZGV4JDE7XG52YXIgZXhwcmVzc2lvblBvcztcbnZhciBleHByZXNzaW9uRW5kUG9zO1xuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIHN0ciA9IHZhbDtcbiAgbGVuID0gc3RyLmxlbmd0aDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cDogdmFsLFxuICAgICAgaWR4OiBudWxsXG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcbiAgICBpZHg6IHZhbC5zdWJzdHJpbmcoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcbnZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDE7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBkZWxpbWl0ZXJzO1xuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQxID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICB0eXBlOiAxLFxuICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHBhcmVudDogY3VycmVudFBhcmVudCxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICB9O1xuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAgICAgICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhYXR0cnMubGVuZ3RoO1xuXG4gICAgICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXdhcm5lZCkge1xuICAgICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXM6XFxuJyArIHRlbXBsYXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHM6XFxuJyArIHRlbXBsYXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhd2FybmVkKSB7XG4gICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQ6XCIgK1xuICAgICAgICAgICAgXCJcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnZGVmYXVsdCc7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHBvc3RUcmFuc2Zvcm1zW2kkMl0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVuZDogZnVuY3Rpb24gZW5kICgpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIGxhc3ROb2RlID0gZWxlbWVudC5jaGlsZHJlbltlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnKSB7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBwb3Agc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCAtPSAxO1xuICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uIGNoYXJzICh0ZXh0KSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXdhcm5lZCAmJiB0ZXh0ID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgd2FybiQxKFxuICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0OlxcblxcbicgKyB0ZW1wbGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvLyBJRSB0ZXh0YXJlYSBwbGFjZWhvbGRlciBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICB3YXJuJDEoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDEoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpO1xuICAgIHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIGVsLmFsaWFzID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICBlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG4gICAgICAgIGVsLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbM10udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdFRhcmdldCkge1xuICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIH1cbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzLCBpc1Byb3A7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG4gICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG4gICAgICAgIGlzUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wKSB7XG4gICAgICAgICAgICBpc1Byb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3AgfHwgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgaWYgKGFyZ01hdGNoICYmIChhcmcgPSBhcmdNYXRjaFsxXSkpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBtb2RpZmllcnMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUpIHtcbiAgICAgIHdhcm4kMSgnZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyhyb290KTtcbiAgLy8gc2Vjb25kIHBhc3M6IG1hcmsgc3RhdGljIHJvb3RzLlxuICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEgKGtleXMpIHtcbiAgcmV0dXJuIG1ha2VNYXAoXG4gICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcbiAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgKVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3Mobm9kZS5pZkNvbmRpdGlvbnMsIGlzSW5Gb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3MgKGNvbmRpdGlvbkJsb2NrcywgaXNJbkZvcikge1xuICBmb3IgKHZhciBpID0gMSwgbGVuID0gY29uZGl0aW9uQmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbWFya1N0YXRpY1Jvb3RzKGNvbmRpdGlvbkJsb2Nrc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxudmFyIG1vZGlmaWVyQ29kZSA9IHtcbiAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgc2VsZjogJ2lmKCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0KXJldHVybjsnLFxuICBjdHJsOiAnaWYoISRldmVudC5jdHJsS2V5KXJldHVybjsnLFxuICBzaGlmdDogJ2lmKCEkZXZlbnQuc2hpZnRLZXkpcmV0dXJuOycsXG4gIGFsdDogJ2lmKCEkZXZlbnQuYWx0S2V5KXJldHVybjsnLFxuICBtZXRhOiAnaWYoISRldmVudC5tZXRhS2V5KXJldHVybjsnXG59O1xuXG5mdW5jdGlvbiBnZW5IYW5kbGVycyAoZXZlbnRzLCBuYXRpdmUpIHtcbiAgdmFyIHJlcyA9IG5hdGl2ZSA/ICduYXRpdmVPbjp7JyA6ICdvbjp7JztcbiAgZm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcbiAgICByZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgZXZlbnRzW25hbWVdKSkgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICd9J1xufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChcbiAgbmFtZSxcbiAgaGFuZGxlclxuKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH0gZWxzZSBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKSB8fCBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKVxuICAgICAgPyBoYW5kbGVyLnZhbHVlXG4gICAgICA6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG4gICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgY29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIGNvZGUgPSBnZW5LZXlGaWx0ZXIoa2V5cykgKyBjb2RlO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlckNvZGUgPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKVxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBoYW5kbGVyLnZhbHVlO1xuICAgIHJldHVybiAnZnVuY3Rpb24oJGV2ZW50KXsnICsgY29kZSArIGhhbmRsZXJDb2RlICsgJ30nXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG4gIHJldHVybiAoXCJpZihcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybjtcIilcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBhbGlhcyA9IGtleUNvZGVzW2tleV07XG4gIHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQyIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgYmluZDogYmluZCQyLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciB0cmFuc2Zvcm1zJDE7XG52YXIgZGF0YUdlbkZucztcbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMkMTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcbnZhciBzdGF0aWNSZW5kZXJGbnM7XG52YXIgb25jZUNvdW50O1xudmFyIGN1cnJlbnRPcHRpb25zO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIC8vIHNhdmUgcHJldmlvdXMgc3RhdGljUmVuZGVyRm5zIHNvIGdlbmVyYXRlIGNhbGxzIGNhbiBiZSBuZXN0ZWRcbiAgdmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gIHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG4gIHZhciBwcmV2T25jZUNvdW50ID0gb25jZUNvdW50O1xuICBvbmNlQ291bnQgPSAwO1xuICBjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgcGxhdGZvcm1EaXJlY3RpdmVzJDEgPSBvcHRpb25zLmRpcmVjdGl2ZXMgfHwge307XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG4gIHN0YXRpY1JlbmRlckZucyA9IHByZXZTdGF0aWNSZW5kZXJGbnM7XG4gIG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbClcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG4gICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG5cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKGVsKSB7XG4gIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXCJcIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpKVxuICB9XG5cbiAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICBmdW5jdGlvbiBnZW5UZXJuYXJ5RXhwIChlbCkge1xuICAgIHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJ3snO1xuXG4gIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXG4gIHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IGRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cykpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgaWYgKGVsLnNsb3RUYXJnZXQpIHtcbiAgICBkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuICB9XG4gIC8vIHNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICBkYXRhICs9IChnZW5TY29wZWRTbG90cyhlbC5zY29wZWRTbG90cykpICsgXCIsXCI7XG4gIH1cbiAgLy8gaW5saW5lLXRlbXBsYXRlXG4gIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcbiAgICBpZiAoaW5saW5lVGVtcGxhdGUpIHtcbiAgICAgIGRhdGEgKz0gaW5saW5lVGVtcGxhdGUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMik7XG4gICAgfVxuICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcXFwiXCIgKyAoZGlyLmFyZykgKyBcIlxcXCJcIikgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG4gICkpIHtcbiAgICB3YXJuJDIoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcbiAgICByZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6e1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0pOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcbiAgcmV0dXJuIGtleSArIFwiOmZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5hdHRyc01hcC5zY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG4gICAgICA6IGdlbkVsZW1lbnQoZWwpKSArIFwifVwiXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChlbCwgY2hlY2tTa2lwKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGVsJDEuZm9yICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgIGVsJDEudGFnICE9PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsJDEpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuKTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChnZW5Ob2RlKS5qb2luKCcsJykpICsgXCJdXCIgKyAoY2hlY2tTa2lwXG4gICAgICAgID8gbm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJ1xuICAgICAgICA6ICcnKSlcbiAgfVxufVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcbiAgcmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcbiAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gIGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG4gICAgcmVzICs9IFwiLG51bGxcIjtcbiAgfVxuICBpZiAoYXR0cnMpIHtcbiAgICByZXMgKz0gXCIsXCIgKyBhdHRycztcbiAgfVxuICBpZiAoYmluZCQkMSkge1xuICAgIHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuICB9XG4gIHJldHVybiByZXMgKyAnKSdcbn1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuZnVuY3Rpb24gZ2VuQ29tcG9uZW50IChjb21wb25lbnROYW1lLCBlbCkge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIENvbXBpbGUgYSB0ZW1wbGF0ZS5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSQxIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcbiAgb3B0aW1pemUoYXN0LCBvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBvcGVyYXRvcnMgbGlrZSB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcbi8vIGNoZWNrIHZhbGlkIGlkZW50aWZpZXIgZm9yIHYtZm9yXG52YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChpZGVudCwgdHlwZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG4gICAgZXJyb3JzLnB1c2goKFwiLSBpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgdGV4dCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcIi0gYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgdGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goKFwiLSBpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgdGV4dCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgaWYgKGV4cHJlc3Npb24pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDJcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDFcbl07XG5cbi8qICAqL1xuXG52YXIgd2FybiQzO1xuXG5mdW5jdGlvbiBtb2RlbCQxIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDMgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgZHluYW1pY1R5cGUpIHtcbiAgICAgIHdhcm4kMyhcbiAgICAgICAgXCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICBcInYtbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBkeW5hbWljIGlucHV0IHR5cGVzLiBVc2Ugdi1pZiBicmFuY2hlcyBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2Uge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH1cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgZWwuYXR0cnNNYXAuY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY2hlY2tlZD46XFxuXCIgK1xuICAgICAgXCJpbmxpbmUgY2hlY2tlZCBhdHRyaWJ1dGVzIHdpbGwgYmUgaWdub3JlZCB3aGVuIHVzaW5nIHYtbW9kZWwuIFwiICtcbiAgICAgICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJ1xuICAgICk7XG4gIH1cbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gIHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG4gICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjbGljaycsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcbiAgICBcIn1lbHNle1wiICsgdmFsdWUgKyBcIj0kJGN9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGVsLmF0dHJzTWFwLmNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIGNoZWNrZWQ+OlxcblwiICtcbiAgICAgIFwiaW5saW5lIGNoZWNrZWQgYXR0cmlidXRlcyB3aWxsIGJlIGlnbm9yZWQgd2hlbiB1c2luZyB2LW1vZGVsLiBcIiArXG4gICAgICAnRGVjbGFyZSBpbml0aWFsIHZhbHVlcyBpbiB0aGUgY29tcG9uZW50XFwncyBkYXRhIG9wdGlvbiBpbnN0ZWFkLidcbiAgICApO1xuICB9XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjbGljaycsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcgJiYgZWwuYXR0cnNNYXAudmFsdWUpIHtcbiAgICAgIHdhcm4kMyhcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdmFsdWU9XFxcIlwiICsgKGVsLmF0dHJzTWFwLnZhbHVlKSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICAnaW5saW5lIHZhbHVlIGF0dHJpYnV0ZXMgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdXNpbmcgdi1tb2RlbC4gJyArXG4gICAgICAgICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3RleHRhcmVhJyAmJiBlbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHdhcm4kMyhcbiAgICAgICAgXCI8dGV4dGFyZWEgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuICAgICAgICAnaW5saW5lIGNvbnRlbnQgaW5zaWRlIDx0ZXh0YXJlYT4gd2lsbCBiZSBpZ25vcmVkIHdoZW4gdXNpbmcgdi1tb2RlbC4gJyArXG4gICAgICAgICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgZXZlbnQgPSBsYXp5IHx8IChpc0lFICYmIHR5cGUgPT09ICdyYW5nZScpID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgaXNOYXRpdmUgPSBlbC50YWcgPT09ICdpbnB1dCcgfHwgZWwudGFnID09PSAndGV4dGFyZWEnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBpc05hdGl2ZVxuICAgID8gKFwiJGV2ZW50LnRhcmdldC52YWx1ZVwiICsgKHRyaW0gPyAnLnRyaW0oKScgOiAnJykpXG4gICAgOiB0cmltID8gXCIodHlwZW9mICRldmVudCA9PT0gJ3N0cmluZycgPyAkZXZlbnQudHJpbSgpIDogJGV2ZW50KVwiIDogXCIkZXZlbnRcIjtcbiAgdmFsdWVFeHByZXNzaW9uID0gbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInXG4gICAgPyAoXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiKVxuICAgIDogdmFsdWVFeHByZXNzaW9uO1xuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChpc05hdGl2ZSAmJiBuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHR5cGUgPT09ICdmaWxlJykge1xuICAgIHdhcm4kMyhcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgaXNOYXRpdmUgPyAoXCJfcyhcIiArIHZhbHVlICsgXCIpXCIpIDogKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlciB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGVsLmNoaWxkcmVuLnNvbWUoY2hlY2tPcHRpb25XYXJuaW5nKTtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIGFzc2lnbm1lbnQgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIiArXG4gICAgKGVsLmF0dHJzTWFwLm11bHRpcGxlID09IG51bGwgPyAnWzBdJyA6ICcnKTtcblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvbldhcm5pbmcgKG9wdGlvbikge1xuICBpZiAob3B0aW9uLnR5cGUgPT09IDEgJiZcbiAgICBvcHRpb24udGFnID09PSAnb3B0aW9uJyAmJlxuICAgIG9wdGlvbi5hdHRyc01hcC5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgd2FybiQzKFxuICAgICAgXCI8c2VsZWN0IHYtbW9kZWw9XFxcIlwiICsgKG9wdGlvbi5wYXJlbnQuYXR0cnNNYXBbJ3YtbW9kZWwnXSkgKyBcIlxcXCI+OlxcblwiICtcbiAgICAgICdpbmxpbmUgc2VsZWN0ZWQgYXR0cmlidXRlcyBvbiA8b3B0aW9uPiB3aWxsIGJlIGlnbm9yZWQgd2hlbiB1c2luZyB2LW1vZGVsLiAnICtcbiAgICAgICdEZWNsYXJlIGluaXRpYWwgdmFsdWVzIGluIHRoZSBjb21wb25lbnRcXCdzIGRhdGEgb3B0aW9uIGluc3RlYWQuJ1xuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKHZhbHVlLCBhc3NpZ25tZW50KSB7XG4gIHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gIGlmIChtb2RlbFJzLmlkeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwidmFyICQkZXhwID0gXCIgKyAobW9kZWxScy5leHApICsgXCIsICQkaWR4ID0gXCIgKyAobW9kZWxScy5pZHgpICsgXCI7XCIgK1xuICAgICAgXCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG4gICAgICAgIHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuICAgICAgXCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyhtb2R1bGVzJDEpLFxuICBkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIGlzUHJlVGFnOiBpc1ByZVRhZ1xufTtcblxuZnVuY3Rpb24gY29tcGlsZSQkMSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IGV4dGVuZChleHRlbmQoe30sIGJhc2VPcHRpb25zKSwgb3B0aW9ucylcbiAgICA6IGJhc2VPcHRpb25zO1xuICByZXR1cm4gY29tcGlsZSQxKHRlbXBsYXRlLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9ucyxcbiAgdm1cbikge1xuICB2YXIgX3dhcm4gPSAob3B0aW9ucyAmJiBvcHRpb25zLndhcm4pIHx8IHdhcm47XG4gIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICBfd2FybihcbiAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXG4gICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgOiB0ZW1wbGF0ZTtcbiAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gY2FjaGVba2V5XVxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSQkMSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gIHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyKTtcbiAgdmFyIGwgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoO1xuICByZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnNbaV0gPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zW2ldKTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChyZXMucmVuZGVyID09PSBub29wIHx8IHJlcy5zdGF0aWNSZW5kZXJGbnMuc29tZShmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuID09PSBub29wOyB9KSkge1xuICAgICAgX3dhcm4oXG4gICAgICAgIFwiZmFpbGVkIHRvIGNvbXBpbGUgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KS5qb2luKCdcXG4nKSArXG4gICAgICAgICdcXG5cXG4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxufVxuXG5mdW5jdGlvbiBtYWtlRnVuY3Rpb24gKGNvZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgdmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuICAgICAgICB3YXJuOiB3YXJuLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8qKlxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcbiAqIG9mIFNWRyBlbGVtZW50cyBpbiBJRSBhcyB3ZWxsLlxuICovXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG4gIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG4gIH1cbn1cblxuVnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxubW9kdWxlLmV4cG9ydHMgPSBWdWUkMztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");
},/*!***************************************!*\
  !*** ../~/css-loader/lib/css-base.js ***!
  \***************************************/
function(module,exports){eval('/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push("@media " + item[2] + "{" + item[1] + "}");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join("");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === "string")\r\n\t\t\tmodules = [[null, modules, ""]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === "number")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = "(" + item[2] + ") and (" + mediaQuery + ")";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzPzQyY2IiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXHJcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzW2ldO1xyXG5cdFx0XHRpZihpdGVtWzJdKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBpdGVtWzFdICsgXCJ9XCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcclxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XHJcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xyXG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XHJcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcclxuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxyXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xyXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxyXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxyXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xyXG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==')},/*!****************************************************!*\
  !*** ../~/vue-style-loader/lib/addStylesClient.js ***!
  \****************************************************/
function(module,exports,__webpack_require__){eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(/*! ./listToStyles */ 25)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = { css: css, media: media, sourceMap: sourceMap }\n    if (!newStyles[id]) {\n      part.id = parentId + ':0'\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      part.id = parentId + ':' + newStyles[id].parts.length\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n  var hasSSR = styleElement != null\n\n  // if in production mode and style is already provided by SSR,\n  // simply do nothing.\n  if (hasSSR && isProduction) {\n    return noop\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = styleElement || createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (!hasSSR) {\n    update(obj)\n  }\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcz8xNjUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7IGNzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHBhcnQuaWQgPSBwYXJlbnRJZCArICc6MCdcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0LmlkID0gcGFyZW50SWQgKyAnOicgKyBuZXdTdHlsZXNbaWRdLnBhcnRzLmxlbmd0aFxuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcbiAgdmFyIGhhc1NTUiA9IHN0eWxlRWxlbWVudCAhPSBudWxsXG5cbiAgLy8gaWYgaW4gcHJvZHVjdGlvbiBtb2RlIGFuZCBzdHlsZSBpcyBhbHJlYWR5IHByb3ZpZGVkIGJ5IFNTUixcbiAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gIGlmIChoYXNTU1IgJiYgaXNQcm9kdWN0aW9uKSB7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gc3R5bGVFbGVtZW50IHx8IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKCFoYXNTU1IpIHtcbiAgICB1cGRhdGUob2JqKVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},/*!*****************************!*\
  !*** ./components/root.vue ***!
  \*****************************/
function(module,exports,__webpack_require__){eval('var Component = __webpack_require__(/*! ./../../~/vue-loader/lib/component-normalizer */ 0)(\n  /* script */\n  __webpack_require__(/*! !babel-loader!eslint-loader!./../../~/vue-loader/lib/selector?type=script&index=0!./../../~/eslint-loader!./root.vue */ 9),\n  /* template */\n  __webpack_require__(/*! !./../../~/vue-loader/lib/template-compiler?id=data-v-764559c1!./../../~/vue-loader/lib/selector?type=template&index=0!./../../~/eslint-loader!./root.vue */ 21),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = "/media/ext_disk/CODEARMADA/http/experiments/vue/app/src/components/root.vue"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}\nif (Component.options.functional) {console.error("[vue-loader] root.vue: functional components are not supported with templates, they should use render functions.")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require("vue-hot-reload-api")\n  hotAPI.install(require("vue"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord("data-v-764559c1", Component.options)\n  } else {\n    hotAPI.reload("data-v-764559c1", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NvbXBvbmVudHMvcm9vdC52dWU/NTUwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciFlc2xpbnQtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL3Jvb3QudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj9pZD1kYXRhLXYtNzY0NTU5YzEhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9yb290LnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL21lZGlhL2V4dF9kaXNrL0NPREVBUk1BREEvaHR0cC9leHBlcmltZW50cy92dWUvYXBwL3NyYy9jb21wb25lbnRzL3Jvb3QudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gcm9vdC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNzY0NTU5YzFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03NjQ1NTljMVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jb21wb25lbnRzL3Jvb3QudnVlXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},/*!*************************************************************************************************************************************************!*\
  !*** ../~/babel-loader/lib!../~/eslint-loader!../~/vue-loader/lib/selector.js?type=script&index=0!../~/eslint-loader!./components/download.vue ***!
  \*************************************************************************************************************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _store = __webpack_require__(/*! ../store/store */ 1);\n\nexports.default = {\n\tcomputed: {\n\t\tbackGround: function backGround() {\n\t\t\treturn 'img/' + (parseInt(this.$store.getters.returnActivity) + 1) + '.jpg';\n\t\t}\n\t}\n}; //\n//\n//\n//\n//\n//\n//\n////# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9kb3dubG9hZC52dWU/NGJjYyJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGUgbGFuZz1cImh0bWxcIj5cblx0PHNlY3Rpb24gY2xhc3M9XCJEb3dubG9hZFwiXG5cdFx0OnN0eWxlPVwie1xuXHRcdFx0YmFja2dyb3VuZEltYWdlOiBgdXJsKCR7YmFja0dyb3VuZH0pYCxcblx0XHR9XCJcblx0Pjwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBzdG9yZSB9IGZyb20gJy4uL3N0b3JlL3N0b3JlJztcbmV4cG9ydCBkZWZhdWx0IHtcblx0Y29tcHV0ZWQ6IHtcblx0XHRiYWNrR3JvdW5kKCkge1xuXHRcdFx0cmV0dXJuICdpbWcvJyArIChwYXJzZUludCh0aGlzLiRzdG9yZS5nZXR0ZXJzLnJldHVybkFjdGl2aXR5KSArIDEpICsgJy5qcGcnO1xuXHRcdH0sXG5cdH0sXG59XG48L3NjcmlwdD5cblxuPHN0eWxlIGxhbmc9XCJjc3NcIj5cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gZG93bmxvYWQudnVlPzM2MTY3OTNjIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFTQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFIQTtBQURBOzs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==")},/*!*********************************************************************************************************************************************!*\
  !*** ../~/babel-loader/lib!../~/eslint-loader!../~/vue-loader/lib/selector.js?type=script&index=0!../~/eslint-loader!./components/main.vue ***!
  \*********************************************************************************************************************************************/
function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n\nvar _download = __webpack_require__(/*! ./download.vue */ 14);\n\nvar _download2 = _interopRequireDefault(_download);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\tcomponents: {\n\t\tDownload: _download2.default\n\t}\n}; //\n//\n//\n//\n//\n//\n//\n////# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9tYWluLnZ1ZT8wMDMyIl0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZSBsYW5nPVwiaHRtbFwiPlxuXHQ8ZGl2IGNsYXNzPVwiTWFpblwiPlxuXHRcdDxkaXYgY2xhc3M9XCJ3cmFwcGVyXCI+XG5cdFx0XHQ8ZG93bmxvYWQgLz5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGRvd25sb2FkIGZyb20gJy4vZG93bmxvYWQudnVlJ1xuZXhwb3J0IGRlZmF1bHQge1xuXHRjb21wb25lbnRzOiB7XG5cdFx0RG93bmxvYWQgOiBkb3dubG9hZCxcblx0fSxcbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgbGFuZz1cImNzc1wiPlxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBtYWluLnZ1ZT80ODE2YzBiYiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBU0E7QUFDQTs7Ozs7OztBQUdBO0FBREE7QUFEQTs7Ozs7OzsiLCJzb3VyY2VSb290IjoiIn0=')},/*!*********************************************************************************************************************************************!*\
  !*** ../~/babel-loader/lib!../~/eslint-loader!../~/vue-loader/lib/selector.js?type=script&index=0!../~/eslint-loader!./components/menu.vue ***!
  \*********************************************************************************************************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _store = __webpack_require__(/*! ../store/store */ 1);\n\nexports.default = {\n\tdata: function data() {\n\t\treturn {\n\t\t\tmenu_items: [{ title: 'Download Panagia' }, { title: 'Download Xristo' }, { title: 'Download Kantili' }]\n\t\t};\n\t},\n\tcomputed: {\n\t\tmenuActivity: function menuActivity() {\n\t\t\treturn this.$store.getters.menuActivity;\n\t\t},\n\t\titemActivity: function itemActivity() {\n\t\t\treturn this.$store.getters.returnActivity;\n\t\t}\n\t},\n\tmethods: {\n\t\tsetActivity: function setActivity(item) {\n\t\t\tthis.$store.commit('setMenuActivity', item);\n\t\t}\n\t}\n}; //\n//\n//\n//\n//\n//\n//\n//\n////# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9tZW51LnZ1ZT8zZTlmIl0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZSBsYW5nPVwiaHRtbFwiPlxuPGRpdiBjbGFzcz1cIk1lbnVcIiA6Y2xhc3M9XCJ7J3Nob3cnIDogbWVudUFjdGl2aXR5fVwiPlxuXHQ8dWw+XG5cdFx0PGxpIGNsYXNzPVwibWVudV9pdGVtXCIgOmNsYXNzPVwieyAnYWN0aXZlJzogaXRlbUFjdGl2aXR5ID09PSBpbmRleCB9XCIgdi1mb3I9XCIoaXRlbSwgaW5kZXgpIGluIG1lbnVfaXRlbXNcIiBAY2xpY2s9XCJzZXRBY3Rpdml0eShpbmRleClcIj5cblx0XHRcdHt7aXRlbS50aXRsZX19XG5cdFx0PC9saT5cblx0PC91bD5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHN0b3JlIH0gZnJvbSAnLi4vc3RvcmUvc3RvcmUnO1xuXHRleHBvcnQgZGVmYXVsdCB7XG5cdFx0ZGF0YTogKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWVudV9pdGVtcyA6IFtcblx0XHRcdFx0XHR7dGl0bGU6J0Rvd25sb2FkIFBhbmFnaWEnfSxcblx0XHRcdFx0XHR7dGl0bGU6J0Rvd25sb2FkIFhyaXN0byd9LFxuXHRcdFx0XHRcdHt0aXRsZTonRG93bmxvYWQgS2FudGlsaSd9LFxuXHRcdFx0XHRdLFxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29tcHV0ZWQ6IHtcblx0XHRcdG1lbnVBY3Rpdml0eSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMubWVudUFjdGl2aXR5O1xuXHRcdFx0fSxcblx0XHRcdGl0ZW1BY3Rpdml0eSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnMucmV0dXJuQWN0aXZpdHk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0c2V0QWN0aXZpdHkoaXRlbSkge1xuXHRcdFx0XHR0aGlzLiRzdG9yZS5jb21taXQoICdzZXRNZW51QWN0aXZpdHknLCBpdGVtICk7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdH1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG1lbnUudnVlP2YxZTk0Nzc2Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFVQTtBQUNBOztBQUVBOztBQUVBO0FBREE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTs7QUFTQTtBQUNBO0FBQ0E7QUFIQTtBQWxCQTs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9")},/*!*********************************************************************************************************************************************!*\
  !*** ../~/babel-loader/lib!../~/eslint-loader!../~/vue-loader/lib/selector.js?type=script&index=0!../~/eslint-loader!./components/root.vue ***!
  \*********************************************************************************************************************************************/
function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n\tvalue: true\n});\n\nvar _topbar = __webpack_require__(/*! ./topbar.vue */ 17);\n\nvar _topbar2 = _interopRequireDefault(_topbar);\n\nvar _main = __webpack_require__(/*! ./main.vue */ 15);\n\nvar _main2 = _interopRequireDefault(_main);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n\tcomponents: {\n\t\ttopbar: _topbar2.default,\n\t\tmainArea: _main2.default\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yb290LnZ1ZT8zYzgxIl0sInNvdXJjZXNDb250ZW50IjpbIjwhLS0tLT5cbjwhLS0tLT5cblx0PCEtLVJPT1QgVlVFIENPTVBPTkVOVC0tPlxuPCEtLS0tPlxuPCEtLS0tPlxuXG48dGVtcGxhdGU+XG5cdDxkaXYgY2xhc3M9XCJBcHBcIj5cblx0XHQ8dG9wYmFyIC8+XG5cdFx0PG1haW4tYXJlYSAvPlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB0b3BiYXIgZnJvbSAnLi90b3BiYXIudnVlJztcblx0aW1wb3J0IG1haW4gZnJvbSAnLi9tYWluLnZ1ZSc7XG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHR0b3BiYXI6IHRvcGJhcixcblx0XHRcdG1haW5BcmVhOiBtYWluLFxuXHRcdH0sXG5cdH1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHJvb3QudnVlPzE0YTUzMzM3Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFjQTtBQUNBOzs7QUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTtBQUNBO0FBRkE7QUFEQSIsInNvdXJjZVJvb3QiOiIifQ==')},/*!***********************************************************************************************************************************************!*\
  !*** ../~/babel-loader/lib!../~/eslint-loader!../~/vue-loader/lib/selector.js?type=script&index=0!../~/eslint-loader!./components/topbar.vue ***!
  \***********************************************************************************************************************************************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nvar _store = __webpack_require__(/*! ../store/store */ 1);\n\nvar _menu = __webpack_require__(/*! ./menu.vue */ 16);\n\nvar _menu2 = _interopRequireDefault(_menu);\n\nvar _moJs = __webpack_require__(/*! mo-js */ 13);\n\nvar _moJs2 = _interopRequireDefault(_moJs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n\tcomponents: {\n\t\tmenuItems: _menu2.default\n\t},\n\tcomputed: {\n\t\tmenuActivity: function menuActivity() {\n\t\t\treturn this.$store.getters.menuActivity;\n\t\t}\n\t},\n\tmethods: {\n\t\ttoggleMenu: function toggleMenu(el, done) {\n\t\t\tif (this.menuActivity) {\n\t\t\t\tthis.tl_triggerMenu.stop();\n\t\t\t\tthis.tl_untriggerMenu.replayBackward();\n\t\t\t} else {\n\t\t\t\tthis.tl_untriggerMenu.stop();\n\t\t\t\tthis.tl_triggerMenu.replay();\n\t\t\t}\n\t\t\tthis.$store.commit('triggerMenu');\n\t\t\tdone;\n\t\t}\n\t},\n\tmounted: function mounted() {\n\t\tvar DURATION = 300,\n\n\t\t// mojsCurve = new MojsCurveEditor({name: 'opacity'}),\n\t\t// op_curve = mojsCurve.getEasing(),\n\t\top_curve = _moJs2.default.easing.path('M0, 100 C0, 100 21.96339152816756, 60.04660549126827 50, 60 C78.03660847183244, 59.953394508731705 100, 100 100, 100 '),\n\t\t    V_OPTS = {\n\t\t\tfill: 'none',\n\t\t\tstroke: '#fff',\n\t\t\tisTimelineLess: true\n\t\t},\n\t\t    circle = new _moJs2.default.Shape({\n\t\t\tparent: this.$refs.settings,\n\t\t\tshape: 'circle',\n\t\t\tduration: DURATION,\n\t\t\tstroke: '#fff',\n\t\t\tstrokeWidth: { 10: 0 },\n\t\t\tfill: 'none',\n\t\t\tradius: { 5: 25 },\n\t\t\ttop: '50%', left: '50%',\n\t\t\teasing: 'cubic.out'\n\t\t}),\n\t\t    close = new _moJs2.default.Shape({\n\t\t\tparent: this.$refs.settings,\n\t\t\tshape: 'cross',\n\t\t\tstroke: '#fff',\n\t\t\tstrokeWidth: 1,\n\t\t\ttop: '50%', left: '50%',\n\t\t\tangle: { 14: 45 },\n\t\t\tradius: { 0: 12 },\n\t\t\topacity: { 0: 1 },\n\t\t\tduration: DURATION,\n\t\t\tdelay: .2 * DURATION,\n\t\t\teasing: 'back.out',\n\t\t\tbackwardEasing: 'circ.in'\n\t\t}),\n\t\t    BUBBLE_OPTS = _extends({}, V_OPTS, {\n\t\t\tparent: circle.el,\n\t\t\tstrokeWidth: { 5: 0 }\n\t\t}),\n\t\t    burst = new _moJs2.default.Burst({\n\t\t\tparent: close.el,\n\t\t\tradius: { 10: 35 },\n\t\t\tduration: .3 * DURATION,\n\t\t\tchildren: _extends({}, V_OPTS, {\n\t\t\t\tshape: 'line',\n\t\t\t\tscaleY: 1\n\t\t\t})\n\t\t}),\n\t\t    dots = new _moJs2.default.Html({\n\t\t\tel: this.$refs.dots,\n\t\t\tscale: { 1: 0 },\n\t\t\topacity: { 1: 0 },\n\t\t\tduration: .5 * DURATION,\n\t\t\teasing: 'circ.in',\n\t\t\tbackwardEasing: 'back.in'\n\t\t}),\n\t\t    bubbleTimeline = new _moJs2.default.Timeline({ delay: 100 }),\n\t\t    bubble1 = new _moJs2.default.Shape(_extends({}, BUBBLE_OPTS, {\n\t\t\tradius: { 0: 10 },\n\t\t\tleft: '7%', top: '25%'\n\t\t})),\n\t\t    bubble2 = new _moJs2.default.Shape(_extends({}, BUBBLE_OPTS, {\n\t\t\tradius: { 0: 6 },\n\t\t\tdelay: .4 * DURATION,\n\t\t\tleft: '85%', top: '45%'\n\t\t})),\n\t\t    bubble3 = new _moJs2.default.Shape(_extends({}, BUBBLE_OPTS, {\n\t\t\tradius: { 0: 4 },\n\t\t\tdelay: .2 * DURATION,\n\t\t\tleft: '22%', top: '90%'\n\t\t}));\n\t\tbubbleTimeline.add(bubble1, bubble2, bubble3);\n\t\tthis.tl_triggerMenu = new _moJs2.default.Timeline().add(circle, burst, dots, close, bubbleTimeline);\n\t\t// new MojsPlayer({ add: this.tl_triggerMenu });\n\t\tthis.tl_untriggerMenu = new _moJs2.default.Timeline().add(dots, close);\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdG9wYmFyLnZ1ZT8zM2MxIl0sInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZSBsYW5nPVwiaHRtbFwiPlxuPGRpdiBjbGFzcz1cIlRvcGJhclwiPlxuXHQ8ZGl2IGNsYXNzPVwid3JhcHBlclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJsb2dvXCI+XG5cdFx0XHQ8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDE2OC4yNDA0NiAxNjYuNjY3MDFcIj48cGF0aCBmaWxsPVwiIzIxMWMxZFwiIGQ9XCJNMTQwLjg1MDggODAuNTI1NDJjLS4yMTItMS4wMjI2Ny0uNjEwNjYtMS44MzMzMy0uNDI2NjYtMi43NTA2NyAxLjI4MjY2LjI0NTM0IDIuNTA1MzMuNTA1MzQgMy44NDkzMy43MzQ2Ny0uNzMzMzMuNjcyLTEuNjQ5MzMgMS42MDI2Ny0zLjQyMjY3IDIuMDE2em0tMS4zNjkzMy0yMi41MjhjLS44Mzg2Ny0uMjk0NjctMS42Mi0uOTk3MzMtMS45OTA2Ny0xLjc4OTMzIDMuNDUwNjctLjg3NiA2Ljk0OC0xLjU1NiAxMC40MDY2Ny0yLjM0NjcuNDAyNjctLjA5Mi44MTg2Ny0uMDc3NC4yMDQuMjQxMy0yLjMzNiAxLjIxNi04LjAwOCA0LjEwOC04LjYyIDMuODk0NnptLTQuMTkwNjcgMzcuNjJjLTEuMDk4NjYtMi4yNjEzNC0uMTgyNjYtNS40Mzg2Ny0xLjI4MjY2LTcuNzYuNzk0NjYtMS45NTYuNzMzMzMtNC4yNzczMyAxLjc3Mi02LjE3MDY3IDEuNDY2NjYgNC4yNzYgMy42NjUzMyAxMC4yMDQtLjQ4OTM0IDEzLjkzMDY3em0tNi41OTggMTkuNjczMzNjLS4xOTg0LTEuNjQ5MzMtLjQ4OTA2LTMuMDU0NjctLjI0NDgtNC41MjEzMyAxLjM0NDI3LTMuMTc2IDMuNjM2LTYuMjE2IDQuOTQ5NDctOS4xMDRsMS40NjY2NyA2LjcyMTMzYy0xLjg5NDY3IDIuMzgyNjctMi42MjcwNyA2LjIzMzMzLTYuMTcxMzQgNi45MDR6bS01LjEzMjgtNi43MjEzM2MtNC44ODc0Ni0uMzY1MzQtOS42NTMwNi0xLjA5ODY3LTE0LjQ4MDEzLTEuNjQ5MzQtLjEzMzg3LTEuMTEzMzMtLjE2OTg3LTIuMjkyLS4zNDUzMy0zLjQzODY2LS4wNjUwNy0uNDI4LS4zNzA0LS41NDgtLjM5MjI3LS4xNDkzNC0uMDYwOTMgMS4wOTQ2Ny0uMTYzNDcgMi4zMTQ2Ny0uMTYzNDcgMy40MzQ2Ny0yLjQ0NDI2LS4wNTg2Ny00LjcxOTg2LS41MTczMy03LjE2MzYtLjE1MiAyLjE5ODk0IDEuMTYyNjcgNC43NjU2IDEuNDA1MzMgNy4xNDggMi4wNzg2N3YyLjkzMmMtMi45MzI0LS44MzA2Ny01LjkxNTItMi4wNjEzNC04Ljg1Nzg2LTIuNjQ5MzQtLjMwNjgtLjA2MTMzLS4zNjYxNC4yMzQ2Ny0uMDgxNzQuNDE3MzQgMi43MjY1NCAxLjc2MTMzIDYuMDA4MjcgMi43NDI2NiA4LjkzOTYgNC4xMjUzMyAwIDIuOTk0NjcgMCA3LjQ1NDY3LS40MjcwNiAxMC45OTg2Ny0xLjI2MDk0LjI2NjY2LTIuODMxMzQgMS4xNzg2Ni00LjIxOTg3IDEuMjg4LS44MzMzMy4wNjY2Ni0yLjk5MDY3LTEuOTYtMy41NDAxMy0yLjAyMTM0LS4xMDIgMS4xNzA2NyAxLjgzMTMzIDIuODA4LjkyNjY2IDQuMDI4LS4xODE4Ni4yNDUzNC0xLjczNi44NzQ2Ny0yLjY5OTA2LjY3Ni00LjYxNzYtMy4zNzQ2Ni05LjIzNDgtNi45Mi0xNC4wMTk3NC05Ljg2MTMzLS4xNTMyLS4wOTMzMy0uMjM2OTMuMjg5MzMtLjAzMjguNDgxMzMgNC4xMjEzNCAzLjgzNiA4LjY2NjY3IDcuMTA1MzQgMTIuMTU4OCAxMS43MDI2Ny0uNjU2OC44NTQ2Ny0xLjM0NDI2IDEuNTg4LTIuMDc3NiAyLjM4MjY3LTIuMDc2NTMtMS4wMzg2Ny00LjUzNjQtMS4yOTg2Ny02Ljg0MjY2LTEuNjQ5MzQtMi45NzgxNC00LjM1NzMzLTQuNjYyNTQtOS4zMTItNy4xMTg4LTEzLjkyLS4yNjUwNy0uNDk3MzMtLjYwMTQ3LS40NTMzMy0uNDc0OTQuMDU3MzQgMS4xODEyIDQuNzczMzMgMy4xNzAyNyA5LjQyMTMzIDQuNjYwNCAxNC4xNjgtMi4zODI4LjYxMDY2LTQuNDU5ODYgMi4xMzg2Ni02LjE3MDggMy44NDkzMy0yLjAxNjEzLTEuNTI4LTMuNjA1Mi0zLjMtNS4zMTYxMy01LjEzMzMzLjExMjQtNS45ODY2Ny43ODgtMTEuOTIxMzQuOTk0NjctMTcuNzU4NjcuMDE4OC0uNTM3MzMtLjIzMTc0LS42MzItLjM4MDY3LS4wODEzMy0xLjYxNzIgNS45OTQ2Ni0zLjk3NCAxNi40OTYtMy45NzQgMTYuNDk2LTMuMjM4NTMuMjQ1MzMtNy4xNDg0LjkxNzMzLTEwLjI2NCAxLjU4OTMzLS41NTA1My0xLjU4OTMzLTEuNDUxNi0yLjg1NzMzLTMuMTAxMDctNC4yNjI2NyAzLjc3Mjk0LTQuNDcwNjYgNy44OTA2Ny0xMC4wOCAxMC45NTA1NC0xNS4wMjY2Ni4yODQ5My0uNDYxMzQuMTI3Ni0uNjUyLS4yMTgyNy0uMjg1MzQtMy45MzIyNyA0LjE3MDY3LTcuNTk0MjcgOS4yOTMzNC0xMi4wMzEyIDEzLjI4MTM0LTMuMTc3MDctLjU0OTM0LTUuNjIwOC0zLjExNi05LjM0ODQtMi4zMjEzNGwuMjQ0OC00LjRjNC4zNjM0Ny00Ljk1MiA5LjA2NzYtOC41OTYgMTMuMzQ1Mi0xMy4xMjkzMy4xNTQ4LS4xNjQuMTQ2OTMtLjU1ODY3LS4xOTc4Ny0uMzQ5MzMtMi43NSAxLjY4LTEyLjc1IDcuNzk2LTE1LjE5OTQ2IDkuMDg1MzMtMS44Mjg2Ny0yLjIxNDY3LTMuOTg2NTQtNC4xLTUuOTY5ODctNi4xNiAyLjcwMDUzLS4yMzIgOS45MTMwNy0uNDU0NjcgMTMuNzY1Mi0uNTYxMzMgMi4zODk2LS4wNjY2NyAyLS43MjguODQwMTMtLjkwNjY3LTIuMDgwOC0uMzIxMzMtMTEuOTg0OTMtMS42NC0xNi40MjA0LTEuOTA4Ljg1MDU0LTMuMDI4Ljk4MDI3LTcuMDAxMzMtLjEyMjQtOS45NiA1LjQ5NTg3LTIuMzA4IDExLjkzMjI3LTIuMzQyNjcgMTguMTUxMDctMi45MDQuNjkzNzMtLjA2NC42MzE3My0uMzU2LS4wOTQyNy0uNDE4NjctNi4zNzcwNi0uNTU2LTEzLjAxOTMzLS43MTA2Ni0xOS4yMTc3My0xLjI2LTEuNTI3Ni0yLjUwNTMzLTIuODcxODctNS4wNzA2Ni01LjAxMDQtNy4zMzIuODU2MjctMi42MjggMS41ODg1My01Ljk4OCA0LjcwNTItNy4wMjY2NiA2LjY4MDI3LTIuMjI2NjcgMTQuMDU0NjctMi44IDIwLjc3NTYtNC45Ni40NzEzMy0uMTUwNjcuMzYyNC0uMzkwNjctLjE2MzYtLjM1MDY3LTcuMjEzMDcuNTM3MzQtMTUuMDM2OTMuNDg0LTIyLjM4NDQuNDg0LTEuMjgyMjctLjc5NDY2LTIuMDc2NTMtMi4zMjEzMy0yLjYyNjUzLTMuNjY1MzMgMS4yODIyNi0yLjU2NjY3IDMuMTE1Ni00LjgyOCA1LjEzMTczLTcuMDI4IDEuNDMxMzMtMS4zMjUzMyAzLjU1MTYtMS45NiA1LjQ0NDI3LTEuNTA2NjcuMjQ4NTMuMDYgMTAuMjk0MjYgMy40MjY2NyAxNy4xNTEwNiA1LjUzNzM0IDEuMTI3Ni4zNDggMS4yNDM3NC4wNTYuMzMwMjctLjM4OTQtNi4wMTkzMy0yLjkyNjctMTIuMTA0OC02LjItMTguMDk4NTMtOS4zODQgMi4wMjY2Ni0yLjE4MjcgMi4wODkwNi01LjczMiAzLjQ1NDI2LTguMjU0Ny42ODAxNC0xLjI1NiA0LjY0LTMuMDE3NCA1LjIxNTYtMy4xNDggNS42NjE0Ny0xLjI5NiA4Ljg1MjU0LTEuMzI4IDExLjQzMjI3LTYuMTk0NyA1LjMxNTYuOTE3MyA0LjI3OTIgMTUuNjA1MyA0LjQ1MjUzIDE3LjgwOTMuMDUuNjQyNi40NjQ2Ny41Nzg2LjUwMjY3LS4wNzg3LjI5NjkzLTUuMTM3NC4zMzU0Ny0xMC44MTIgMS4wOTM3My0xNS45NTc0IDYuNjkwMTQuMzgxNCAxMy45OTE3NC00LjE1NDYgMTYuMzc0NTQtNS4wMTA2LS4zNTg0IDcuMDEwNi0xLjQ0NTM0IDEzLjg0OTMtMi4yOTEyIDIwLjU4OC0uMTY0IDEuMzA4LjI2MjUzIDEuMzIxMy41ODk2LjAxMiAxLjU1MTA2LTYuMTkzNCAyLjY3MTg2LTEyLjU3NDcgNC4wODQ0LTE4LjgyOCAxLjM1NzczLS42NCAyLjQwMTYuMjM0NiAzLjUyNDkzLjk2OCAxLjQ1OTQ3Ljk1MzMgNC45Njc3MyAxLjM1MzMgNC45Njc3MyAxLjM1MzMgMS4zMjA4IDcuMTgxMyAyLjc1MDU0IDE0LjM2MjcgNC4zOTAxNCAyMS4zOTA3LjI0ODQgMS4wNjkzLjYzOTA2Ljc3MDYuNTUzNi0uNDU4Ny0uMjY5NzQtMy44NzM0LTEuMjY0LTE4LjUwMTQtMS4wNzY1NC0yMS4wNTIgMS43MzA4LS41MDU0IDMuNjc4MTQtMS4xNzc0IDUuMDUzMDctMS45NDI3IDEuNTc3NzMgMi4yNjUzIDQuMjg2IDQuNzk0NiA0LjM5OTYgNy42ODQtLjg2MiA2LjMwMjYtMi42MjY2NyAxMi40MTQ2LTMuOTEwNTMgMTguNTA0LS4xNzI0LjgxNzMuMTI0NTMuOTI2Ni40MTYyNi4xNTczIDIuMDk0NjctNS41Mzg3IDMuNzE0NTQtMTEuMjggNi4xODI4LTE2LjY0NTQuNTEwOTQtLjY1NzQgMS4yNjM0Ny0uNjM3NCAyLjAyMDgtLjQ3Ni41MDgyNy4xMDggNS4xMjc2IDIuNjE0NiA3LjMyNzYgMi44NTg2LjM2NjY3IDMuNjY2NyAyLjE5ODk0IDcuNTE2IDUuNzQyNjcgOS4wNDI3IDAgMC02LjY3NjUzIDkuNDU0Ni0xMC4yOTE2IDE0LjgyOTMtLjcyNzYgMS4wODI2LS41MTA0IDEuMTQ0LjQzMDEzLjI2NjYgNC41NTg5NC00LjI1MDcgNy42NjY2Ny05LjA2NjcgMTIuNzk0MjctMTIuNzEzNC0uNzk0MjcgMS41MjkzLS42NzE4NyAzLjY2NjctLjkxNjY3IDUuMjU2LTQuNDgzODYgMy4yODEzLTkuMDY2MTMgNi42MDkzLTEzLjUyNjUzIDkuNzcwNy0uNTIzNDcuMzcwNi0uMzU3NzMuNTkyLjI0NDguMzIyNiA0LjUzMTItMi4wMjI3IDkuMDgwMjctNC40ODY3IDEzLjc3MTMzLTYuNDI2Ny4zNjYxNCAxLjQ4Ljg1NDY3IDIuMTM3MyAxLjU4OCAzLjExNDYtMS41ODguNjEwNi0zLjQyMTMzLjU0OTMtNS4wMTA0IDEuMTYxMyAxLjg5NDI3Ljg1NDcgNC4xNTQ2Ny42NzIgNi4xNzE4NyAxLjE2MTMtLjMwNjI3IDEuODkzMyAxLjI4MjI3IDMuMjIxMyAyLjE5ODkzIDQuMjc3My0uODU1NiAyLjY4NjYtMi41MDUyIDUuMDA5My0yLjUwNTIgOC4wNjM5Mi01LjUxNDUzLS43NzItMTEuMjI5Ni0yLjA0MjY2LTE2LjYwNDEzLTMuNDA1My0uNTc5Mi0uMTQ4LS42Mzc0Ny4xMDkzLS4wODUzMy4zNzIgNC45NDc4NiAyLjM0NjYzIDEwLjM1MDQgMy45NTczIDE1LjQwNjY2IDYuMjEyIDIuMTk5NDcgMi4zMjEzLjc5NDI3IDYuMTA4IDIuMDE2MTQgOC43OTczLTUuMDYwNC0yLjk0MTMtOS40NC03Ljc1NDY3LTEzLjk1ODgtMTIuMDkwNjctLjE3NC0uMTY2Ny0uNDE0LjA1MDYtLjI2NTA3LjI2MTMgMy44Mjc2IDUuNDEwNjUgOS4xNSAxMC4wOTYgMTIuMjA3NzMgMTUuOHptLjMwNTc0IDE2Ljk4NTMzYy0zLjQ2NzIgMi45OC03Ljg4MTc0IDMuNTQ1MzMtNy44ODE3NCAzLjU0NTMzbDEuODk0MjctNC4xNTYgMy42NjU2LTMuMTc3MzNjLjU1LjA2MjY3IDEuNjUtLjE4MjY3IDIuNTA1Mi0uMzA0LjEyMjQgMS42NDgtLjA2MDkzIDIuNjQyNjctLjE4MzMzIDQuMDkyem0tMTQuNDgwMTQtMTYuNTU2bDEzLjE5NzM0IDMuMjM3MzNjMS4wMzkwNi45MTczNCAxLjAzOTA2IDIuODEwNjcuNTQ5NDYgMy45MTA2N2gtMi4wMTU2bC0xMS40ODY5My0zLjkxMDY3em0yLjQ0MzIgMTYuMjUyYy0uNzMyMjYtLjM2NTMzLTEuNTg3NDYtLjkxNzMzLTEuNTg3NDYtMS44OTQ2N2wtLjYxMTQ3LTkuMjI2NjYgNy4yMDkzMyAyLjYyOGMuOTA3ODcgMS4xNzg2Ni40NTI2NyAxLjg5Ni0uMzUgMi41MTczMy0uODE3NzMuNjM0NjctMy44ODA2NiA0LjE0MjY3LTQuNjYwNCA1Ljk3NnptLTMuMjgxNzMgMTAuMTgyNjdjLS4zMjM0Ny4wODI2Ni0zLjkyNzIuMzI2NjYtNS4wMjc2IDEuMTIxMzNsLTMuOTcxNDctMS4wNGMuOTE2NjctMi40NDQgNC4zMzgxNC0yLjI2IDUuNTYwNTQtNC43MDRsMy42NjUwNi0uOTc4NjdjMS4xNjIuMzA2NjcgMi4yMzEyLjY4OCAzLjU0NDguOTc4NjctMS40NjQ2NiAxLjQ2NC0xLjcyMTMzIDQuMDkwNjctMy43NzEzMyA0LjYyMjY3em0tMTcuMDY0MTMgMy4zMmMtMy4wNTQxNC44NTYtNi4zNTQ2NyAxLjk1Ni05LjcxNDU0IDEuMzQ0Ljg1NTc0LTEuNTg4IDIuNjg4LTIuODEwNjcgNC4zOTg5NC0zLjIzNzM0bDUuNDM4NTMuODU0Njd6bS0xNy4xMzEyIDEuOTA2NjZjLS40MzgtLjIxNzMzLTcuMjQ3NDctMi4wMjkzMy0xMC40MjQ1NC0yLjIxMmwtMi4zODMzMy0yLjYyNjY2YzIuNjI3Ni0uNTUwNjcgNS4zNzc2LS42NzIgOC4wNjU2LTEuMDQgMS42NDk0NyAyLjIgMy45MSAzLjYwNjY2IDUuODY1NzMgNS40NC0uMzI2MTMuNjgtLjcxLjY0MjY2LTEuMTIzNDYuNDM4NjZ6bS0yMy4wNzEzNC02LjQyOGMtMi4zODI5My0xLjY0OTMzLTQuMDk0OC00LjE1NDY2LTUuNDM4NTMtNi40NzYgMi41MDUyLTEuMTYxMzMgNS41OTA1My4zMiA2LjU5ODQgMS44OTQ2N2wyLjIgMy41NDI2N3ptLTE5LjkxODgtMTguMDg1MzNjLjk3NjU0LTIuMzE0NjcuNTI0OTQtNS4xNDY2Ny4yNDg5NC03Ljc2OTMzLS4wNTI1NC0uNDk2LjEyMTg2LS41NzIuMzQxNzMtLjExNiAxLjc5MDUzIDMuNzIyNjYgNy40MjMzMyA3LjkyMjY2IDcuNjM0OCA4LjEzNzMzIDIuMDM0OTMgMi4wODEzMy0uMTQ5NDcgNS4yNDEzMy45OTk0NyA3LjgxMzMzLTQuMTU0MTQtLjczMzMzLTguMjQ3ODctMy43ODgtOS4yMjQ5NC04LjA2NTMzem0tNi43ODI4LTIwLjA0MTMzYy41NTA1NC0yLjg3Mi44NTU3NC02LjE2OTM0LjMwNTc0LTkuMTAyNjdsLjkxNjY3LTEuMzQ0YzEuMzQwNyAxLjkzMiAzLjI0MDcgMy44MTIgNC4yNzE5IDUuOTcwNjcgMS44NjkyIDMuOTEwNjYgMS41NzUgNi41ODEzMy41NTUyIDExLjgwOTMzLTEuMDM5LTIuOTk0NjctMy4zLTUuNzQ0LTYuMDQ5NC03LjMzMzMzem0tMS41ODg1My0yNC4xOTQ2N2wyLjA3NzYtMy42NjY2NmMuNzk0MjcgMS42NDkzIDEuNDY2MTMgMy40MjEzIDIuOTMyOCA0LjgyOC0xLjAzOCAxLjY0OC0yLjE5OTQ2IDMuMjk4Ni0yLjUwNTIgNS4yNTQ2LTEuMjIxODYtMS44MzM0LTIuMTM4NTMtNC4wOTQ3LTIuNTA1Mi02LjQxNnptNS40Mzg1My0yMS41NjkzM2MzLjU0MzItLjczMzMzIDYuMjkyNjctMy4zNiA5LjM0Nzg3LTUuMzE0NjctLjI0NDggMi44NzItMi44NzE4NyA1LjM3Ni0zLjE3NzA3IDguNTUzMzQtMy4xNzcwNiAxLjY0OTMtNi4xMDk4NiA1LjAxMDYtNy45NDMyIDguMDY1My0xLjA5OTQ2LTQuMTUzNCAxLjI4MzM0LTcuNTE0NyAxLjc3MjQtMTEuMzA0ek01Mi4zNDcwNyAzMy4wMDAxYy4yMjk2LjA0NCAyLjA0ODQuNzg0IDIuOTA0NjcuNjAxMzItMS4xNTU3NCAyLjI3MzMzLTMuMjg5MDcgMi42ODI2Ny01LjQ4NDQgMy4wMDEzMy0yLjYxMzYuMzgyNjctNi4wNDA2NyAyLjA4MTM0LTguMTg3NDcgMy42NDI2N2wtLjEzNzA3LS41OTQ2N2MzLjYwNjgtMi4zODUzMyA2LjMyNzYtNy40ODUzMyAxMC45MDQyNy02LjY1MDY2em0xMC4wMDcyLTMuOTA1MzVjMy45NzYxMy02LjQ5NDY2IDEyLjA0MTczLTYuNDg0IDE3LjE4NDQtLjg0LTYuNTY5MiA1LjM0NjY3LTE0LjQ1IDQuMTg0LTE0LjQ1IDQuMTg0LTEuNDY2NjctMS4wMzczMy0zLjE3NzYtMS41ODgtNS4wMTA0LTEuNzY5MzMuNDI3MDctLjQ5MDY3IDEuNTQyMTMtMS4yMDggMi4yNzYtMS41NzQ2N3ptMzQuNjA0MjctMS41MzczM2MuNDc1NDYuMzM4NjcgMy4wMTc2IDIuMzc4NjcgMy4wMTc2IDIuMzc4NjctMy4xNzcwNyAzLjY2NTMtMTIuNTI4MTQgMS41MzczLTE1LjA5MTYtMi4yMDE0IDYuOTMwNjYtMi44NzQ3IDEwLjY0Nzg2LTEuMTk2IDEyLjA3NC0uMTc3NHptMjAuMzA4OCAxMC4zMjEzM2wuNzMzMzMgMy4yMzczNGMtMi4wNzgxMy0xLjEtNC4xNTQ2Ny0yLjE5ODctNi41OTg5My0yLjM4MjctMS40NjYxNC0yLjg3Mi00LjA5Mzc0LTUuNTYxNC02LjE3MDk0LTguMzcwNyAyLjg3MTQ3LS44NTQ3IDcuMDcyLS4xOTc0IDEyLjAzNjU0IDcuNTE2em03LjAyNjUzIDkuMjI2NjdsMi45MzI4LjEyYzEuNDA0NjcgMS43NzMzMyAxLjg3OTIgMy43ODggMi4xOTg5MyA2LjA0OTMzLTEuMzQzNzMtLjg1NDY2LTUuNDM3NDYtMS45NTQ2Ni01LjEzMTczLTYuMTY5MzN6bTguNTUzNiAxMS44NTJjMS4yODMzMyAxLjM0NCAyLjU2NzMzIDMuMzYxMzMgNC4zOTkzMyAzLjg0OTMzLjE4MjY3IDMuMjk4NjctLjI0NCA3LjA4NjY3LTEuMzQ0IDEwLjI2NTM0LTEuMzQ1MzMtLjI0NTQtMi43NDQyNi01LjU2OTQtMy4zMzEzMy02LjgtMS41OTczMy0zLjM1Ni4yNzYtNy4zMTQ3LjI3Ni03LjMxNDd6bTM0Ljc4NDY2IDI1LjI3MmMtNC42MTItMS44MzczMy0xOS4xNDI2Ni02LjQ1NDY3LTE5LjE0MjY2LTYuNDU0NjcgMi4xNTItMS45NTMzMyA0LjU5NDY3LTMuNjU4NjYgNi42NDkzMy01LjY5MDY2LjQ1MDY3LS40NDguMjc2LS43MDI3LS4yMzItLjM1NDctMi43MTYgMS44NjQtNS40MDkzMyAzLjczNi04LjE4OTMzIDUuNDM2LTIuMDE2LS43MzM0LTMuNDgyNjctMS40ODI3LTUuOTg4LTIuNjI4IDIuMTM4NjctNC4yMTYuOTE2LTkuNDA5NCAyLjUwNTMzLTEzLjYyNGwxMi4wMzYtOC45ODE0czQuNjYtMS4yMDggNi41MjUzMy0xLjU5NDdjMS45MDQtLjM5MzQgMi4wNDUzNC0uNzMyLjA2NTM0LS41ODQtMS40NTczNC4xMDgtMy40MzA2Ny4zNzMzLTQuMi40MTIgMS4wMzItLjgxODcgMi4zMDUzMy0xLjc0NCAzLjIzNDY2LTIuNjQ0LjI1Mi0uMjQ0LjM0MjY3LS41NDQtLjE3NzMzLS4yNi0yLjA0IDEuMTEzMy03LjA2NTMzIDMuODU0Ni03LjE2NjY2IDMuODcwNi02LjI3ODY3Ljk0OTMtMTguMDUwNjcgMy4xMjY2LTE4Ljk0MjY3IDEuMTMzMy0xLjA0NTMzLTIuMzMwNy0xLjQxNC00Ljk5MDctMi4zNzI0LTcuMzYxNCA1LjY4MzA3LTYuOTc4NyAxMy4xODMwNy0xMi40MDE0IDE5LjQ4ODQtMTcuOTQyNy41NC0uNDczMy40MzQ2Ny0uODQxMy0uNy0uMDgxMy01LjY1NzMzIDMuNzg5My0yMi4xMyAxNS0yMi41Mjc0NyAxNS4wMjY2LTEuMjAzMDYuMDg2Ni0zLjM0ODQuMjM2LTMuNTE4NjYuMjI5My0xLjM3NjU0LS4wNTQ3LTIuMDE2MTQtLjg3MDctMi4wNjU2LTEuOTgyNy0uMDcxNDctMS41ODgtLjEzMTg3LTMuMTQ5NC0uODE5ODctNC4zNTM0IDMuNzYyNTMtNi43Mzc0IDguMTQ0MjctMTMuNDc2IDExLjgxNjkzLTIwLjA3NDcuMzI0LS41OC4xNjgtLjc0MTMtLjIyNTMzLS4yNDI3LTQuNjQ0NjcgNS44Nzg3LTkuNDQxMDcgMTEuODY1NC0xNC4zNDEwNyAxNy4zODU0LS43NzkyLS41Mi0xLjM3NTQ2LTEuMjQtMS45NDg0LTEuOTk3NC0uOTA5ODYtMS4yMDU0LTUuMDkzMi00LjY3NzQtNi4zOTEyLTUuMDYuMDc2LTEuNjggMy44LTEzLjg0OTQgNS4wNTkzNC0xOC4yNDguMjkyMjYtMS4wMjE0LS4wMTcwNy0uNzMzNC0uMjU2MTQtLjI3Ni0yLjkzMzMzIDUuNi01LjUwNjI2IDExLjU2LTcuOTM0OTMgMTcuMzc4Ni0xLjUyNzYtLjIyOTMtMy41NTg5My0uMzUwNy01LjA4NjUzLjg3MDctMS4wMzkwNy0uMzA2Ny0yLjAxNjE0LTEuMjgyNy0yLjUwNTItMi4yLjk4NDQtNS42OTc0IDIuNjE5ODYtMTMuODI5NCAzLjYyMDQtMTkuNDQ1NC4xNzk2LTEuMDA2Ny4xNjM0Ni0xLjg1NzMtLjM5MjgtLjEzMi0xLjYzNDggNS4wNjgtNS40NjQgMTcuNDYxMy02LjUxNCAxOS4wMDkzLTMuNDE2MTQtMS4yODgtNy41Mjg2Ny0uNzYtMTEuMDcxMzQtLjI4NjctLjY1NDEzLS41NDUzLTQuNTEyNTMtMTMuMTgtNy4wNzQtMjAuNjc4Ny0uMzEwOTMtLjkxMzQtLjY3Ni0xLjQ4OTQtLjM3OTczLjA4OCAxLjE1MzIgNi4xMTg3IDMuODc5NzMgMjEuMDk0NyAzLjA1NDI3IDIxLjYyOTMyLTEuNDY2NjctMS41MjgtNy4yNTU3NC00LjIwMTM3LTkuMjg3MDctNC41ODQtMi45NjE4Ny01Ljg2NzMtNC43OTE2LTEyLjI3OC03LjIxMTQ3LTE4LjQzMjctLjI3Ni0uNzAyNjYtLjUzNDI2LS42NTYtLjM2NjEzLjA2IDEuNDE4MjcgNi4wMjQgMy4yMDEwNyAxMS45MTg2NyAzLjkxMTQ3IDE4LjI1Mi0xLjI1MjU0IDEuMTc4NjctMi43NDg0IDEuNjkwNjctNC4yMjEzNCAyLjI4OC0xLjE4NDkzLjQ3ODY3LTMuODI4NjYgMi4wMzQ2Ny01LjQzMjggNC4xMjY2Ny0zLjM3NDkzLTQuODg4LTYuNDI5NzMtMTAuMjg1My05LjU0NjkzLTE1LjMwNC0uMzczMzMtLjYwNC0uNjQ1NzMtLjQ4MTMtLjM2NTA3LjIyMjcgMi40NjkzNCA2LjIgNi4yNDY5NCAxOC4xOTg2NCA2LjI0Njk0IDE4LjE5ODY0LTYuNzU5ODctMy4xMTYtMTEuNTk2OTQgMi41ODk0LTE2LjMwNjI3IDYuNjcyLTEuMDYwNC45Mi0xLjU4MjguNjg0LTIuMjc1MDcuMy00LjQ5ODQtMi41MDI2LTguMjQ1Mi02LjgyMTMtMTIuMzI2NTMtMTAuMzY1My0uMzQ2NC0uMy0uNTg1MzMtLjE3NDYtLjMxMzA2LjIxMiAzLjI2ODMgNC42NDI3IDEwLjE1OTUgMTIuMDMwNyAxMC40MjA0IDEyLjI3ODcuODQ3OS43OTczIDEuNTIzIDEuNzkzMyAxLjYxNDYgMi43NTYtNC4wMzIyIDEuNzcyLTcuMTQ4OSA2LjE3MDctMTIuMDM2NCA1LjMxNi00LjA0NjktMi41MjI3LTcuNDYwOS02Ljg1MzMtMTAuODI1NS0xMC4xOTQ3LS41NDY4LS41NDI2LTEuMTYxOS0uODg2Ni0uMzk5NC4xNTYgMi43MzI4IDMuNzQxNCA5LjE0MjggMTIuNTQ0IDEwLjQ5MTcgMTQuNjgyNy0xLjUyNzYgNC4wOTMzLTIuOTkzNyA5LjA0MTMtMS4zNDM3IDEzLjUwMjYtMS4zNDQ4IDEuMjgxMy0yLjEzOSAyLjcwNC0yLjkzMzMgNC4yNzYtNi4wMTY3LS43NjQtMTIuMjMxMy0xLjE4OC0xOC4zNzc2LTEuNzA4LS43MTgyLS4wNi0uODYxOS4xNjgtLjIyMTMuMzM4NiA1LjcxMzUgMS41MzIgMTEuMjI5NiAyLjgzNDcgMTcuNDM4NSA0LjczMDctLjEyMjQgNC4xNTQ2IDEuODAxNSA3Ljg5NzMgMy42NjU2IDExLjQyNTMtLjE3MjQuMzEwNi0uNzE3NyAxLjA1MzMtMS4zMjg2IDEuMjA2Ni0zLjM1OTguMjg1My0xMy41NzU1LjY4LTE4Ljg2NDYuOTkzMy0xLjgwNTIuMTA2Ny0xLjU4ODUuNDc4Ny0uNDUxNS41MjggNy40NjI1LjMyNCAxOC4zMjM1IDEuMjQ0IDE4LjMyMzUgMS4yNDQgMS41MjcgMy4yMzg3LjkxNjEgNy43NTg3LS42MTE1IDEwLjg3NDctNS41MzE5IDIuMjAyNy0xMS40MTczIDMuNzc4Ny0xNy4wODk3IDUuNTEzNC0xLjQwNzMuNDI5My0xLjYzOTEuOTQxMy45NzQ0LjM5ODcgNi43OTAxLTEuNDEwNiAxOC41MzYtMy43MzYgMjAuNjc4Ny0yLjA1ODYuODIxOS42NDEzIDYuNjA1OCAxMC41NDEzIDEuNzI5OCAxNC45MDUzLTUuMzY5MyAxLjg3Mi0xNC4yNzE5IDQuNDEyLTE5LjUzOTEgNi4zODQtMS4yNjUxLjQ3Mi0xLjE5MjIuODgxMy4yNjIuNTUwNiA3LjU1ODktMS43MTczIDIxLjA0OS00LjczNiAyMS4wNDktNC43MzYgMS43MTA5IDUuMDEwNyA2LjIzMTcgOC45MiAxMS4xMjAyNyAxMC41NzA3LTQuMDYyOSA2LjAwNC03LjYyOTIgMTMuMjgyNy0xMS4xNjYxIDE5Ljc0OTQtLjYwMDUgMS4wOTg3LS40MTk3IDEuNjI1My41OTE3OC4wNjQgNC4yOTUyLTYuNjMzMyA4Ljg0Mzc4LTEzLjEyNjcgMTMuNjkwNTgtMTkuNTY5MyAxLjM0NDI2IDMuMjk4NjQgNC4wOTM3IDYuMjMyIDYuNzIxMyA4LjY3Ni0zLjUyNiA1Ljc0MjY0LTguNDYyOSAxMC45NDQtMTIuOTI5MDMgMTYuMzI0LS45NTI2NCAxLjE0OC0xLjUwOTQ0IDIuMjYxMy40NTU3Ni40NDI2NCA1Ljg2NzItNS40MzA3IDE3Ljk3NDktMTYuMjc4NyAyMS4yNzEzLTE2LjQ2LjY0MjY3Ljg0MjY1IDEuODQ3ODcgMi44NDQgMi41MDQ2NyAzLjU3MzMuMjI5MiAxLjE0NjYzLTMuMDMwMjIgMTUuOTY0LTQuOTYwOSAyMy45MDY2My0uMjY2NyAxLjEuMDEzNiAxLjE2NC40MDM2LjA4MjY4IDIuNjk5LTcuNDYyNiA1LjE5NTgtMTUuMDQ5MyA4LjM0NjMtMjIuMzA5MyAwIDAgOS4wNDIxNy45NzczNiAxMC43NTI3IDIuNjI4LTIuMjExMSA1LjgwOTM2LTUuNTAzMiAxMS4xNDI3LTguNDkzOSAxNi41ODQtLjU2MjkgMS4wMjUzNi0uMjQ2MiAxLjMwNjcuNDMzOS40MDggNC42NTQ3LTYuMTQ4IDguNzE1Mi0xMi41MTg2NCAxMy4xOTI4LTE4LjcwMjY0IDAgMCAxLjE2MDk3LjM4IDEuMzI4NTcuNjg2Ny4zMTQ3LjU3MzMzLTIuMzYwNCAxMC44NzA2Ni0zLjg5NDYgMTYuODAyNjYtLjU1OTUgMi4xNjI3LS4xMSAyLjExMzQuMzM5NC45MDE0IDIuMjEtNS45NTYgMy44NTYzLTEyLjEwNCA3LjM1ODkzLTE3LjUzNiAzLjY2NjEyLjc5NDcgNi41Mzc0NS0xLjI4NCA5Ljk1OTMyLTEuNTg4IDMuODYzNiAzLjk2OCA2LjIxMzYgOC44MDggOC43NTg5MyAxMy40ODUzNy4zOTMyLjcyNC42ODM3Mi41NDQuMzkxNi0uMjQ5My0yLjA0NDI4LTUuNTYxMzctNS4wNjQ1LTEwLjgwNjctNi40MDEwOC0xNi40NzQ3IDIuNzQ5NDguMTg0IDUuNDM3NDguNDI2NyA3LjMzMTc1IDIuNjI4IDIuMzUzMiA0LjU1MiA1LjAwNTMgOS4wMTczNSA3LjcwNzMgMTMuNDM0Ny41MjUwMy44NTg3Ljg2OTMuODU4Ny40MzcwMy0uMTI4LTIuNDU3OS01LjYwOC02LjI3NzItMTMuNDM0Ni02LjMyMzUtMTMuNjI2Ni0uMzc5Ny0xLjUzNi42MTYyLTEuOTUwNyAxLjkxNzgtMi4xNjE0IDMuMjI0NC0uNTE3MyA2LjMxMjQtMi41Mzg2NiA3LjU2NTEtNS40NjEzIDEuMDk5NS0uMzA2NyAyLjQ0NDMtMS4yMjI3IDMuNTQzNy0uMjQ1MzUgNC41Njc4IDQuMDY1MyA4LjY4MDcgOC44MzIgMTIuODE1NiAxMy4wMTMzLjg5ODQuOTA4IDEuNzY5OSAxLjQxODY1LjM3NzYtLjM3MDctMy40NzgxLTQuNDc0NjYtOS44MTUtMTIuNTczMy0xMS41NjY2LTE0LjQ2MTMgMy4zMzgtLjQ2IDUuODAxMDUtNC4wNDQgOS40ODg1LTMuNjMwNy4xODIzLjAyMTM3IDExLjQxNzUgMy42ODggMTYuODgxNSA1LjQ3MzM3IDEuNzU4NjYuNTczMyAxLjA0OTMuMDE4Ni4xMTItLjQzODctNi4wMDI3LTIuOTQyNy0xMi4wNjgtNS43NDgtMTcuNzIyMTQtOS42MDY3LjE4MzktMS40NTA2OC4yNi0yLjY3Mi0uMDQ1Mi00LjM1MiA0LjU4Mi0uNDI2NjggNy40OTkzNy01LjQ4NCAxMC4wMDQ3LTguNjYxMyA3LjU5NzMtLjUzNiAxNC43MjUzIDEuNDEyIDIyIDIuNjAyNyAxLjAzMzMuMTY5MyAxLjEyOC0uMTIyNy4xMDEzLS40MzM0LTYuODcyLTIuMDgtMTQuNzEzMy00Ljc4NC0yMS40OTA2NC02LjY0NTM2LS4xNTItMi41MjEzLS4xODI3LTQuNTY2NjctMS4xNi03LjQzODY3IDQuMjc2LTQuMjE2IDUuNzQyNjctMTAuODc0NyAzLjQ4MTMtMTYuNTU4NyAxLjcyNjY4LTEuNzQgMy4zLTMuMDU0NyA1LjAxMDY4LTQuMzk4NyAwIDAgMTUuNTEzMzYgNC41NTIgMjAuNTU2IDUuNjYyNy45NzIuMjE0NyAxLjA1Mi0uMTQyNjQuMTc2LS40OTJcIi8+PC9zdmc+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz1cImluZm9cIj48L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPVwiYWN0aW9uc1wiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJzZXR0aW5nc1wiIHJlZj1cInNldHRpbmdzXCIgQGNsaWNrPVwidG9nZ2xlTWVudVwiPlxuXHRcdFx0XHQ8c3ZnIHJlZj1cImRvdHNcIiB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIj48cGF0aCBmaWxsPVwibm9uZVwiIGQ9XCJNMCAwaDI0djI0SDB6XCIvPjxwYXRoIGQ9XCJNMTIgOGMxLjEgMCAyLS45IDItMnMtLjktMi0yLTItMiAuOS0yIDIgLjkgMiAyIDJ6bTAgMmMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTAgNmMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6XCIvPjwvc3ZnPlxuXHRcdFx0PC9zcGFuPlxuXHRcdFx0PG1lbnUtaXRlbXMgLz5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2Rpdj5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuXHRpbXBvcnQgeyBzdG9yZSB9IGZyb20gJy4uL3N0b3JlL3N0b3JlJztcblx0aW1wb3J0IG1lbnUgZnJvbSAnLi9tZW51LnZ1ZSc7XG5cdGltcG9ydCBtb2pzIGZyb20gJ21vLWpzJztcblx0ZXhwb3J0IGRlZmF1bHQge1xuXHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdG1lbnVJdGVtczogbWVudSxcblx0XHR9LFxuXHRcdGNvbXB1dGVkOiB7XG5cdFx0XHRtZW51QWN0aXZpdHkoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzLm1lbnVBY3Rpdml0eTtcblx0XHRcdH0sXG5cdFx0fSxcblx0XHRtZXRob2RzOiB7XG5cdFx0XHR0b2dnbGVNZW51KGVsLCBkb25lKSB7XG5cdFx0XHRcdGlmICh0aGlzLm1lbnVBY3Rpdml0eSkge1xuXHRcdFx0XHRcdHRoaXMudGxfdHJpZ2dlck1lbnUuc3RvcCgpO1xuXHRcdFx0XHRcdHRoaXMudGxfdW50cmlnZ2VyTWVudS5yZXBsYXlCYWNrd2FyZCgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudGxfdW50cmlnZ2VyTWVudS5zdG9wKCk7XG5cdFx0XHRcdFx0dGhpcy50bF90cmlnZ2VyTWVudS5yZXBsYXkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiRzdG9yZS5jb21taXQoJ3RyaWdnZXJNZW51Jyk7XG5cdFx0XHRcdGRvbmU7XG5cdFx0XHR9LFxuXHRcdH0sXG5cdFx0bW91bnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdFxuXHRcdFx0XHREVVJBVElPTiA9IDMwMCxcblx0XHRcdFx0Ly8gbW9qc0N1cnZlID0gbmV3IE1vanNDdXJ2ZUVkaXRvcih7bmFtZTogJ29wYWNpdHknfSksXG5cdFx0XHRcdC8vIG9wX2N1cnZlID0gbW9qc0N1cnZlLmdldEVhc2luZygpLFxuXHRcdFx0XHRvcF9jdXJ2ZSA9IG1vanMuZWFzaW5nLnBhdGgoICdNMCwgMTAwIEMwLCAxMDAgMjEuOTYzMzkxNTI4MTY3NTYsIDYwLjA0NjYwNTQ5MTI2ODI3IDUwLCA2MCBDNzguMDM2NjA4NDcxODMyNDQsIDU5Ljk1MzM5NDUwODczMTcwNSAxMDAsIDEwMCAxMDAsIDEwMCAnICksXG5cdFx0XHRcdFZfT1BUUyA9IHtcblx0XHRcdFx0XHRmaWxsOiAgICAgJ25vbmUnLFxuXHRcdFx0XHRcdHN0cm9rZTogICAnI2ZmZicsXG5cdFx0XHRcdFx0aXNUaW1lbGluZUxlc3M6IHRydWUsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNpcmNsZSA9IG5ldyBtb2pzLlNoYXBlKHtcblx0XHRcdFx0XHRwYXJlbnQ6IHRoaXMuJHJlZnMuc2V0dGluZ3MsXG5cdFx0XHRcdFx0c2hhcGU6ICdjaXJjbGUnLFxuXHRcdFx0XHRcdGR1cmF0aW9uOiBEVVJBVElPTixcblx0XHRcdFx0XHRzdHJva2U6ICcjZmZmJyxcblx0XHRcdFx0XHRzdHJva2VXaWR0aDogIHsgMTAgOiAwIH0sXG5cdFx0XHRcdFx0ZmlsbDogJ25vbmUnLFxuXHRcdFx0XHRcdHJhZGl1czogezU6MjV9LFxuXHRcdFx0XHRcdHRvcDogJzUwJScsIGxlZnQ6ICc1MCUnLFxuXHRcdFx0XHRcdGVhc2luZzogJ2N1YmljLm91dCcsXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRjbG9zZSA9IG5ldyBtb2pzLlNoYXBlKHtcblx0XHRcdFx0XHRwYXJlbnQ6IHRoaXMuJHJlZnMuc2V0dGluZ3MsXG5cdFx0XHRcdFx0c2hhcGU6ICdjcm9zcycsXG5cdFx0XHRcdFx0c3Ryb2tlOiAnI2ZmZicsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGg6IDEsXG5cdFx0XHRcdFx0dG9wOiAnNTAlJywgbGVmdDogJzUwJScsXG5cdFx0XHRcdFx0YW5nbGU6IHsxNDo0NX0sXG5cdFx0XHRcdFx0cmFkaXVzOiB7MDoxMn0sXG5cdFx0XHRcdFx0b3BhY2l0eTogezA6MX0sXG5cdFx0XHRcdFx0ZHVyYXRpb246IERVUkFUSU9OLFxuXHRcdFx0XHRcdGRlbGF5OiAuMipEVVJBVElPTixcblx0XHRcdFx0XHRlYXNpbmc6ICdiYWNrLm91dCcsXG5cdFx0XHRcdFx0YmFja3dhcmRFYXNpbmc6ICdjaXJjLmluJyxcblx0XHRcdFx0fSksXG5cdFx0XHRcdEJVQkJMRV9PUFRTID0ge1xuXHRcdFx0XHRcdC4uLlZfT1BUUyxcblx0XHRcdFx0XHRwYXJlbnQ6ICAgICAgICAgY2lyY2xlLmVsLFxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoOiAgICB7NTowfSxcblx0XHRcdFx0fSxcblx0XHRcdFx0YnVyc3QgPSBuZXcgbW9qcy5CdXJzdCh7XG5cdFx0XHRcdFx0cGFyZW50OiBjbG9zZS5lbCxcblx0XHRcdFx0XHRyYWRpdXM6ICAgICB7IDEwOiAzNSB9LFxuXHRcdFx0XHRcdGR1cmF0aW9uOiAuMypEVVJBVElPTixcblx0XHRcdFx0XHRjaGlsZHJlbjoge1xuXHRcdFx0XHRcdFx0Li4uVl9PUFRTLFxuXHRcdFx0XHRcdFx0c2hhcGU6ICdsaW5lJyxcblx0XHRcdFx0XHRcdHNjYWxlWTogIDEsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSksXG5cdFx0XHRcdGRvdHMgPSBuZXcgbW9qcy5IdG1sKHtcblx0XHRcdFx0XHRlbDogdGhpcy4kcmVmcy5kb3RzLFxuXHRcdFx0XHRcdHNjYWxlOiB7MTowfSxcblx0XHRcdFx0XHRvcGFjaXR5OiB7MTowfSxcblx0XHRcdFx0XHRkdXJhdGlvbjogLjUqRFVSQVRJT04sXG5cdFx0XHRcdFx0ZWFzaW5nOiAnY2lyYy5pbicsXG5cdFx0XHRcdFx0YmFja3dhcmRFYXNpbmc6ICdiYWNrLmluJyxcblx0XHRcdFx0fSksXG5cdFx0XHRcdGJ1YmJsZVRpbWVsaW5lID0gbmV3IG1vanMuVGltZWxpbmUoeyBkZWxheTogMTAwIH0pLFxuXHRcdFx0XHRidWJibGUxID0gbmV3IG1vanMuU2hhcGUoe1xuXHRcdFx0XHRcdC4uLkJVQkJMRV9PUFRTLFxuXHRcdFx0XHRcdHJhZGl1czogICB7IDA6IDEwIH0sXG5cdFx0XHRcdFx0bGVmdDogJzclJywgdG9wOiAnMjUlJyxcblx0XHRcdFx0fSksXG5cdFx0XHRcdGJ1YmJsZTIgPSBuZXcgbW9qcy5TaGFwZSh7XG5cdFx0XHRcdFx0Li4uQlVCQkxFX09QVFMsXG5cdFx0XHRcdFx0cmFkaXVzOiAgIHsgMDogNiB9LFxuXHRcdFx0XHRcdGRlbGF5OiAgICAuNCpEVVJBVElPTixcblx0XHRcdFx0XHRsZWZ0OiAnODUlJywgdG9wOiAnNDUlJyxcblx0XHRcdFx0fSksXG5cdFx0XHRcdGJ1YmJsZTMgPSBuZXcgbW9qcy5TaGFwZSh7XG5cdFx0XHRcdFx0Li4uQlVCQkxFX09QVFMsXG5cdFx0XHRcdFx0cmFkaXVzOiAgIHsgMDogNCB9LFxuXHRcdFx0XHRcdGRlbGF5OiAgICAuMipEVVJBVElPTixcblx0XHRcdFx0XHRsZWZ0OiAnMjIlJywgdG9wOiAnOTAlJyxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJ1YmJsZVRpbWVsaW5lLmFkZCggIGJ1YmJsZTEsIGJ1YmJsZTIsIGJ1YmJsZTMgKTtcblx0XHRcdFx0dGhpcy50bF90cmlnZ2VyTWVudSA9IG5ldyBtb2pzLlRpbWVsaW5lKCkuYWRkKGNpcmNsZSwgYnVyc3QsIGRvdHMsIGNsb3NlLCBidWJibGVUaW1lbGluZSk7XG5cdFx0XHRcdC8vIG5ldyBNb2pzUGxheWVyKHsgYWRkOiB0aGlzLnRsX3RyaWdnZXJNZW51IH0pO1xuXHRcdFx0XHR0aGlzLnRsX3VudHJpZ2dlck1lbnUgPSBuZXcgbW9qcy5UaW1lbGluZSgpLmFkZChkb3RzLCBjbG9zZSk7XG5cdFx0fSxcblx0fVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gdG9wYmFyLnZ1ZT80NTM5OTllNCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7Ozs7QUFHQTtBQURBOztBQUlBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTs7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWVBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFQQTs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2R0EiLCJzb3VyY2VSb290IjoiIn0=")},/*!*******************************************************************************************************************************************************************************************!*\
  !*** ../~/css-loader?sourceMap!../~/vue-loader/lib/style-rewriter.js?id=data-v-0daf62e7!../~/vue-loader/lib/selector.js?type=styles&index=0!../~/eslint-loader!./components/download.vue ***!
  \*******************************************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 3)();\n// imports\n\n\n// module\nexports.push([module.i, "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"download.vue","sourceRoot":"webpack://"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZT8yOGI1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcImZpbGVcIjpcImRvd25sb2FkLnZ1ZVwiLFwic291cmNlUm9vdFwiOlwid2VicGFjazovL1wifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4uL34vdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTBkYWY2MmU3IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLi9+L2VzbGludC1sb2FkZXIhLi9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==')},/*!***************************************************************************************************************************************************************************************!*\
  !*** ../~/css-loader?sourceMap!../~/vue-loader/lib/style-rewriter.js?id=data-v-7fb69b18!../~/vue-loader/lib/selector.js?type=styles&index=0!../~/eslint-loader!./components/main.vue ***!
  \***************************************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 3)();\n// imports\n\n\n// module\nexports.push([module.i, "\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"main.vue","sourceRoot":"webpack://"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlPzU4ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W10sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIlwiLFwiZmlsZVwiOlwibWFpbi52dWVcIixcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi03ZmI2OWIxOCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vfi9lc2xpbnQtbG9hZGVyIS4vY29tcG9uZW50cy9tYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==')},/*!******************************!*\
  !*** ../~/mo-js/build/mo.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mojs\"] = factory();\n\telse\n\t\troot[\"mojs\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"build/\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(53);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(59);\n\t__webpack_require__(58);\n\tmodule.exports = __webpack_require__(61)('iterator');\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _module = __webpack_require__(16);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _thenable = __webpack_require__(12);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tunable = __webpack_require__(13);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _tweenable = __webpack_require__(11);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(19);\n\tvar Bit = __webpack_require__(26);\n\tvar shapesMap = __webpack_require__(20);\n\n\n\t// TODO\n\t//  - refactor\n\t//    - add setIfChanged to Module\n\t//  --\n\t//  - tween for every prop\n\n\tvar Shape = function (_Tunable) {\n\t  (0, _inherits3.default)(Shape, _Tunable);\n\n\t  function Shape() {\n\t    (0, _classCallCheck3.default)(this, Shape);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t  */\n\n\t  Shape.prototype._declareDefaults = function _declareDefaults() {\n\t    // DEFAULTS / APIs\n\t    this._defaults = {\n\t      // where to append the module to [selector, HTMLElement]\n\t      parent: document.body,\n\t      // class name for the `el`\n\t      className: '',\n\t      // Possible values: [circle, line, zigzag, rect, polygon, cross, equal ]\n\t      shape: 'circle',\n\t      // ∆ :: Possible values: [color name, rgb, rgba, hex]\n\t      stroke: 'transparent',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      strokeOpacity: 1,\n\t      // Possible values: ['butt' | 'round' | 'square']\n\t      strokeLinecap: '',\n\t      // ∆ :: Possible values: [ number ]\n\t      strokeWidth: 2,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      strokeDasharray: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      strokeDashoffset: 0,\n\t      // ∆ :: Possible values: [color name, rgb, rgba, hex]\n\t      fill: 'deeppink',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      fillOpacity: 1,\n\t      // {Boolean} - if should hide module with `opacity` instead of `display`\n\t      isSoftHide: true,\n\t      // {Boolean} - if should trigger composite layer for the `el`\n\t      isForce3d: false,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      left: '50%',\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      top: '50%',\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      x: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      y: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      angle: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      scale: 1,\n\t      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.\n\t      scaleX: null,\n\t      // ∆ :: Possible values: [ number ] Fallbacks to `scale`.\n\t      scaleY: null,\n\t      // ∆ :: Possible values: [ number, string ]\n\t      origin: '50% 50%',\n\t      // ∆ :: Possible values: [ 0..1 ]\n\t      opacity: 1,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      rx: 0,\n\t      // ∆ :: Units :: Possible values: [ number, string ]\n\t      ry: 0,\n\t      // ∆ :: Possible values: [ number ]\n\t      points: 3,\n\t      // ∆ :: Possible values: [ number ]\n\t      radius: 50,\n\t      // ∆ :: Possible values: [ number ]\n\t      radiusX: null,\n\t      // ∆ :: Possible values: [ number ]\n\t      radiusY: null,\n\t      // Possible values: [ boolean ]\n\t      isShowStart: false,\n\t      // Possible values: [ boolean ]\n\t      isShowEnd: true,\n\t      // Possible values: [ boolean ]\n\t      isRefreshState: true,\n\t      // Possible values: [ number > 0 ]\n\t      duration: 400,\n\t      // Possible values: [ number ]\n\n\t      /* technical ones: */\n\t      // explicit width of the module canvas\n\t      width: null,\n\t      // explicit height of the module canvas\n\t      height: null,\n\t      // Possible values: [ number ]\n\t      // sizeGap:          0,\n\t      /* [boolean] :: If should have child shape. */\n\t      isWithShape: true,\n\t      // context for all the callbacks\n\t      callbacksContext: this\n\t    };\n\t  };\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @overrides @ Tunable\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\n\n\t  Shape.prototype.tune = function tune(o) {\n\t    _Tunable.prototype.tune.call(this, o);\n\t    // update shapeModule's size to the max in `then` chain\n\t    this._getMaxSizeInChain();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    @overrides @ Thenable\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\n\n\t  Shape.prototype.then = function then(o) {\n\t    // this._makeTimeline()\n\t    _Tunable.prototype.then.call(this, o);\n\t    // update shapeModule's size to the max in `then` chain\n\t    this._getMaxSizeInChain();\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to declare variables.\n\t    @overrides Thenable\n\t  */\n\n\n\t  Shape.prototype._vars = function _vars() {\n\t    // call _vars method on Thenable\n\t    _Tunable.prototype._vars.call(this);\n\t    this._lastSet = {};\n\t    // save previous module in the chain\n\t    this._prevChainModule = this._o.prevChainModule;\n\t    // should draw on foreign svg canvas\n\t    this.isForeign = !!this._o.ctx;\n\t    // this._o.isTimelineLess = true;\n\t    // should take an svg element as self bit\n\t    return this.isForeignBit = !!this._o.shape;\n\t  };\n\t  /*\n\t    Method to initialize modules presentation.\n\t    @private\n\t    @overrides Module\n\t  */\n\n\n\t  Shape.prototype._render = function _render() {\n\t    if (!this._isRendered && !this._isChained) {\n\t      // create `mojs` shape element\n\t      this.el = document.createElement('div');\n\t      // set name on the `el`\n\t      this.el.setAttribute('data-name', 'mojs-shape');\n\t      // set class on the `el`\n\t      this.el.setAttribute('class', this._props.className);\n\t      // create shape module\n\t      this._createShape();\n\t      // append `el` to parent\n\t      this._props.parent.appendChild(this.el);\n\t      // set position styles on the el\n\t      this._setElStyles();\n\t      // set initial position for the first module in the chain\n\t      this._setProgress(0, 0);\n\t      // show at start if `isShowStart`\n\t      if (this._props.isShowStart) {\n\t        this._show();\n\t      } else {\n\t        this._hide();\n\t      }\n\t      // set `_isRendered` hatch\n\t      this._isRendered = true;\n\t    } else if (this._isChained) {\n\t      // save elements from master module\n\t      this.el = this._masterModule.el;\n\t      this.shapeModule = this._masterModule.shapeModule;\n\t    }\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set el styles on initialization.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._setElStyles = function _setElStyles() {\n\t    if (!this.el) {\n\t      return;\n\t    }\n\t    // if (!this.isForeign) {\n\t    var p = this._props,\n\t        style = this.el.style,\n\t        width = p.shapeWidth,\n\t        height = p.shapeHeight;\n\n\t    style.position = 'absolute';\n\t    this._setElSizeStyles(width, height);\n\n\t    if (p.isForce3d) {\n\t      var name = 'backface-visibility';\n\t      style['' + name] = 'hidden';\n\t      style['' + h.prefix.css + name] = 'hidden';\n\t    }\n\t    // }\n\t  };\n\t  /*\n\t    Method to set `width`/`height`/`margins` to the `el` styles.\n\t    @param {Number} Width.\n\t    @param {height} Height.\n\t  */\n\n\n\t  Shape.prototype._setElSizeStyles = function _setElSizeStyles(width, height) {\n\t    var style = this.el.style;\n\t    style.width = width + 'px';\n\t    style.height = height + 'px';\n\t    style['margin-left'] = -width / 2 + 'px';\n\t    style['margin-top'] = -height / 2 + 'px';\n\t  };\n\t  /*\n\t    Method to draw shape.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._draw = function _draw() {\n\t    if (!this.shapeModule) {\n\t      return;\n\t    }\n\n\t    var p = this._props,\n\t        bP = this.shapeModule._props;\n\t    // set props on bit\n\t    // bP.x                    = this._origin.x;\n\t    // bP.y                    = this._origin.y;\n\t    bP.rx = p.rx;\n\t    bP.ry = p.ry;\n\t    bP.stroke = p.stroke;\n\t    bP['stroke-width'] = p.strokeWidth;\n\t    bP['stroke-opacity'] = p.strokeOpacity;\n\t    bP['stroke-dasharray'] = p.strokeDasharray;\n\t    bP['stroke-dashoffset'] = p.strokeDashoffset;\n\t    bP['stroke-linecap'] = p.strokeLinecap;\n\t    bP['fill'] = p.fill;\n\t    bP['fill-opacity'] = p.fillOpacity;\n\t    bP.radius = p.radius;\n\t    bP.radiusX = p.radiusX;\n\t    bP.radiusY = p.radiusY;\n\t    bP.points = p.points;\n\n\t    this.shapeModule._draw();\n\t    this._drawEl();\n\t  };\n\t  /*\n\t    Method to set current modules props to main div el.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._drawEl = function _drawEl() {\n\t    // return;\n\t    if (this.el == null) {\n\t      return true;\n\t    }\n\t    var p = this._props;\n\t    var style = this.el.style;\n\n\t    // style.opacity = p.opacity;\n\t    this._isPropChanged('opacity') && (style.opacity = p.opacity);\n\t    if (!this.isForeign) {\n\t      this._isPropChanged('left') && (style.left = p.left);\n\t      this._isPropChanged('top') && (style.top = p.top);\n\n\t      var isX = this._isPropChanged('x'),\n\t          isY = this._isPropChanged('y'),\n\t          isTranslate = isX || isY,\n\t          isScaleX = this._isPropChanged('scaleX'),\n\t          isScaleY = this._isPropChanged('scaleY'),\n\t          isScale = this._isPropChanged('scale'),\n\t          isScale = isScale || isScaleX || isScaleY,\n\t          isRotate = this._isPropChanged('angle');\n\n\t      if (isTranslate || isScale || isRotate) {\n\t        var transform = this._fillTransform();\n\t        style[h.prefix.css + 'transform'] = transform;\n\t        style['transform'] = transform;\n\t      }\n\n\t      if (this._isPropChanged('origin') || this._deltas['origin']) {\n\t        var origin = this._fillOrigin();\n\t        style[h.prefix.css + 'transform-origin'] = origin;\n\t        style['transform-origin'] = origin;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to check if property changed after the latest check.\n\t    @private\n\t    @param {String} Name of the property to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Shape.prototype._isPropChanged = function _isPropChanged(name) {\n\t    // if there is no recod for the property - create it\n\t    if (this._lastSet[name] == null) {\n\t      this._lastSet[name] = {};\n\t    }\n\t    if (this._lastSet[name].value !== this._props[name]) {\n\t      this._lastSet[name].value = this._props[name];\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  };\n\t  /*\n\t    Method to tune new option on run.\n\t    @private\n\t    @override @ Module\n\t    @param {Object}  Option to tune on run.\n\t  */\n\n\n\t  Shape.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    // call super on Module\n\t    _Tunable.prototype._tuneNewOptions.call(this, o);\n\t    // return if empty object\n\t    if (!(o != null && (0, _keys2.default)(o).length)) {\n\t      return 1;\n\t    }\n\n\t    // this._calcSize();\n\t    this._setElStyles();\n\t  };\n\t  /*\n\t    Method to get max radiusX value.\n\t    @private\n\t    @param {String} Radius name.\n\t  */\n\n\n\t  Shape.prototype._getMaxRadius = function _getMaxRadius(name) {\n\t    var selfSize, selfSizeX;\n\t    selfSize = this._getRadiusSize('radius');\n\t    return this._getRadiusSize(name, selfSize);\n\t  };\n\t  /*\n\t    Method to increase calculated size based on easing.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._increaseSizeWithEasing = function _increaseSizeWithEasing() {\n\t    var p = this._props,\n\t        easing = this._o.easing,\n\t        isStringEasing = easing && typeof easing === 'string';\n\n\t    switch (isStringEasing && easing.toLowerCase()) {\n\t      case 'elastic.out':\n\t      case 'elastic.inout':\n\t        p.size *= 1.25;\n\t        break;\n\t      case 'back.out':\n\t      case 'back.inout':\n\t        p.size *= 1.1;\n\t    }\n\t  };\n\t  /*\n\t    Method to increase calculated size based on bit ratio.\n\t    @private\n\t  */\n\t  // _increaseSizeWithBitRatio () {\n\t  //   var p   = this._props;\n\t  //   // p.size *= this.shape._props.ratio;\n\t  //   p.size += 2 * p.sizeGap;\n\t  // }\n\t  /*\n\t    Method to get maximum radius size with optional fallback.\n\t    @private\n\t    @param {Object}\n\t      @param key {String} Name of the radius - [radius|radiusX|radiusY].\n\t      @param @optional fallback {Number}  Optional number to set if there\n\t                                          is no value for the key.\n\t  */\n\n\n\t  Shape.prototype._getRadiusSize = function _getRadiusSize(name) {\n\t    var fallback = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n\t    var delta = this._deltas[name];\n\t    // if value is delta value\n\t    if (delta != null) {\n\t      // get maximum number between start and end values of the delta\n\t      return Math.max(Math.abs(delta.end), Math.abs(delta.start));\n\t    } else if (this._props[name] != null) {\n\t      // else get the value from props object\n\t      return parseFloat(this._props[name]);\n\t    } else {\n\t      return fallback;\n\t    }\n\t  };\n\t  /*\n\t    Method to get max shape canvas size and save it to _props.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getShapeSize = function _getShapeSize() {\n\t    var p = this._props,\n\n\t    // get maximum stroke value\n\t    stroke = this._getMaxStroke();\n\t    // save shape `width` and `height` to `_props`\n\t    p.shapeWidth = p.width != null ? p.width : 2 * this._getMaxRadius('radiusX') + stroke;\n\n\t    p.shapeHeight = p.height != null ? p.height : 2 * this._getMaxRadius('radiusY') + stroke;\n\t  };\n\t  /*\n\t    Method to create shape.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._createShape = function _createShape() {\n\t    // calculate max shape canvas size and set to _props\n\t    this._getShapeSize();\n\t    // don't create actual shape if !`isWithShape`\n\t    if (!this._props.isWithShape) {\n\t      return;\n\t    }\n\n\t    var p = this._props;\n\t    // get shape's class\n\t    var Shape = shapesMap.getShape(this._props.shape);\n\t    // create `_shape` module\n\t    this.shapeModule = new Shape({\n\t      width: p.shapeWidth,\n\t      height: p.shapeHeight,\n\t      parent: this.el\n\t    });\n\t  };\n\t  /*\n\t    Method to get max size in `then` chain\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getMaxSizeInChain = function _getMaxSizeInChain() {\n\t    var p = this._props,\n\t        maxW = 0,\n\t        maxH = 0;\n\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      this._modules[i]._getShapeSize();\n\t      maxW = Math.max(maxW, this._modules[i]._props.shapeWidth);\n\t      maxH = Math.max(maxH, this._modules[i]._props.shapeHeight);\n\t    }\n\n\t    this.shapeModule && this.shapeModule._setSize(maxW, maxH);\n\t    this._setElSizeStyles(maxW, maxH);\n\t  };\n\t  /*\n\t    Method to get max value of the strokeWidth.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._getMaxStroke = function _getMaxStroke() {\n\t    var p = this._props;\n\t    var dStroke = this._deltas['strokeWidth'];\n\t    return dStroke != null ? Math.max(dStroke.start, dStroke.end) : p.strokeWidth;\n\t  };\n\t  /*\n\t    Method to draw current progress of the deltas.\n\t    @private\n\t    @override @ Module\n\t    @param   {Number}  EasedProgress to set - [0..1].\n\t    @param   {Number}  Progress to set - [0..1].\n\t  */\n\n\n\t  Shape.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    // call the super on Module\n\t    _module2.default.prototype._setProgress.call(this, easedProgress, progress);\n\t    // draw current progress\n\t    this._draw(easedProgress);\n\t  };\n\t  /*\n\t    Method to add callback overrides to passed object.\n\t    @private\n\t    @param {Object} Object to add the overrides to.\n\t  */\n\n\n\t  Shape.prototype._applyCallbackOverrides = function _applyCallbackOverrides(obj) {\n\t    var it = this,\n\t        p = this._props;\n\t    // specify control functions for the module\n\t    obj.callbackOverrides = {\n\t      onUpdate: function onUpdate(ep, p) {\n\t        return it._setProgress(ep, p);\n\t      },\n\t      onStart: function onStart(isFwd) {\n\t        // don't touch main `el` onStart in chained elements\n\t        if (it._isChained) {\n\t          return;\n\t        };\n\t        if (isFwd) {\n\t          it._show();\n\t        } else {\n\t          if (!p.isShowStart) {\n\t            it._hide();\n\t          }\n\t        }\n\t      },\n\t      onComplete: function onComplete(isFwd) {\n\t        // don't touch main `el` if not the last in `then` chain\n\t        if (!it._isLastInChain()) {\n\t          return;\n\t        }\n\t        if (isFwd) {\n\t          if (!p.isShowEnd) {\n\t            it._hide();\n\t          }\n\t        } else {\n\t          it._show();\n\t        }\n\t      },\n\t      onRefresh: function onRefresh(isBefore) {\n\t        p.isRefreshState && isBefore && it._refreshBefore();\n\t      }\n\t    };\n\t  };\n\t  /*\n\t    Method to setup tween and timeline options before creating them.\n\t    @override @ Tweenable\n\t    @private  \n\t  */\n\n\n\t  Shape.prototype._transformTweenOptions = function _transformTweenOptions() {\n\t    this._applyCallbackOverrides(this._o);\n\t  };\n\t  /*\n\t    Method to create transform string.\n\t    @private\n\t    @returns {String} Transform string.\n\t  */\n\n\n\t  Shape.prototype._fillTransform = function _fillTransform() {\n\t    var p = this._props,\n\t        scaleX = p.scaleX != null ? p.scaleX : p.scale,\n\t        scaleY = p.scaleY != null ? p.scaleY : p.scale,\n\t        scale = scaleX + ', ' + scaleY;\n\t    return 'translate(' + p.x + ', ' + p.y + ') rotate(' + p.angle + 'deg) scale(' + scale + ')';\n\t  };\n\t  /*\n\t    Method to create transform-origin string.\n\t    @private\n\t    @returns {String} Transform string.\n\t  */\n\n\n\t  Shape.prototype._fillOrigin = function _fillOrigin() {\n\t    var p = this._props,\n\t        str = '';\n\t    for (var i = 0; i < p.origin.length; i++) {\n\t      str += p.origin[i].string + ' ';\n\t    }\n\t    return str;\n\t  };\n\t  /*\n\t    Method to refresh state befor startTime.\n\t    @private\n\t  */\n\n\n\t  Shape.prototype._refreshBefore = function _refreshBefore() {\n\t    // call setProgress with eased and normal progress\n\t    this._setProgress(this.tween._props.easing(0), 0);\n\n\t    if (this._props.isShowStart) {\n\t      this._show();\n\t    } else {\n\t      this._hide();\n\t    }\n\t  };\n\t  /*\n\t    Method that gets called on `soft` show of the module,\n\t    it should restore transform styles of the module.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Shape.prototype._showByTransform = function _showByTransform() {\n\t    // reset the cache of the scale prop\n\t    this._lastSet.scale = null;\n\t    // draw el accroding to it's props\n\t    this._drawEl();\n\t  };\n\n\t  return Shape;\n\t}(_tunable2.default);\n\n\texports.default = Shape;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _shape = __webpack_require__(2);\n\n\tvar _shape2 = _interopRequireDefault(_shape);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  *TODO:*\n\t  ---\n\t  - tweak then chains\n\t*/\n\n\tvar ShapeSwirl = function (_Shape) {\n\t  (0, _inherits3.default)(ShapeSwirl, _Shape);\n\n\t  function ShapeSwirl() {\n\t    (0, _classCallCheck3.default)(this, ShapeSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Shape.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare _defaults and other default objects.\n\t    @private\n\t    @override @ Shape\n\t  */\n\n\t  ShapeSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _Shape.prototype._declareDefaults.call(this);\n\n\t    /* _DEFAULTS ARE - Shape DEFAULTS + THESE: */\n\n\t    /* [boolean] :: If shape should follow sinusoidal path. */\n\t    this._defaults.isSwirl = true;\n\t    /* ∆ :: [number > 0] :: Degree size of the sinusoidal path. */\n\t    this._defaults.swirlSize = 10;\n\t    /* ∆ :: [number > 0] :: Frequency of the sinusoidal path. */\n\t    this._defaults.swirlFrequency = 3;\n\t    /* ∆ :: [number > 0] :: Sinusoidal path length scale. */\n\t    this._defaults.pathScale = 1;\n\t    /* ∆ :: [number] :: Degree shift for the sinusoidal path. */\n\t    this._defaults.degreeShift = 0;\n\t    /* ∆ :: [number] :: Radius of the shape. */\n\t    this._defaults.radius = 5;\n\t    // ∆ :: Units :: Possible values: [ number, string ]\n\t    this._defaults.x = 0;\n\t    // ∆ :: Units :: Possible values: [ number, string ]\n\t    this._defaults.y = 0;\n\t    // ∆ :: Possible values: [ number ]\n\t    this._defaults.scale = { 1: 0 };\n\t    /* [number: -1, 1] :: Directon of Swirl. */\n\t    this._defaults.direction = 1;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to copy _o options to _props with\n\t    fallback to _defaults.\n\t    @private\n\t    @override @ Module\n\t  */\n\n\n\t  ShapeSwirl.prototype._extendDefaults = function _extendDefaults() {\n\t    _Shape.prototype._extendDefaults.call(this);\n\t    this._calcPosData();\n\t  };\n\t  /*\n\t    Method to tune new oprions to _o and _props object.\n\t    @private\n\t    @overrides @ Module\n\t    @param {Object} Options object to tune to.\n\t  */\n\n\n\t  ShapeSwirl.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    if (o == null) {\n\t      return;\n\t    }\n\n\t    _Shape.prototype._tuneNewOptions.call(this, o);\n\t    if (o.x != null || o.y != null) {\n\t      this._calcPosData();\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate Swirl's position data.\n\t    @private\n\t  */\n\n\n\t  ShapeSwirl.prototype._calcPosData = function _calcPosData() {\n\t    var x = this._getPosValue('x'),\n\t        y = this._getPosValue('y'),\n\t        angle = 90 + Math.atan(y.delta / x.delta || 0) * _h2.default.RAD_TO_DEG;\n\n\t    this._posData = {\n\t      radius: Math.sqrt(x.delta * x.delta + y.delta * y.delta),\n\t      angle: x.delta < 0 ? angle + 180 : angle,\n\t      x: x, y: y\n\t    };\n\t    // set the last position to _props\n\t    // this._calcSwirlXY( 1 );\n\t  };\n\t  /*\n\t    Gets `x` or `y` position value.\n\t    @private\n\t    @param {String} Name of the property.\n\t  */\n\n\n\t  ShapeSwirl.prototype._getPosValue = function _getPosValue(name) {\n\t    var delta = this._deltas[name];\n\t    if (delta) {\n\t      // delete from deltas to prevent normal\n\t      delete this._deltas[name];\n\t      return {\n\t        start: delta.start.value,\n\t        end: delta.end.value,\n\t        delta: delta.delta,\n\t        units: delta.end.unit\n\t      };\n\t    } else {\n\t      var pos = _h2.default.parseUnit(this._props[name]);\n\t      return { start: pos.value, end: pos.value, delta: 0, units: pos.unit };\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate the progress of the Swirl.\n\t    @private\n\t    @overrides @ Shape\n\t    @param {Numer} Eased progress of the Swirl in range of [0..1]\n\t    @param {Numer} Progress of the Swirl in range of [0..1]\n\t  */\n\n\n\t  ShapeSwirl.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    this._progress = easedProgress;\n\t    this._calcCurrentProps(easedProgress, progress);\n\t    this._calcSwirlXY(easedProgress);\n\t    // this._calcOrigin();\n\t    this._draw(easedProgress);\n\t  };\n\t  /*\n\t    Method to calculate x/y for Swirl's progress\n\t    @private\n\t    @mutates _props\n\t    @param {Number} Current progress in [0...1]\n\t  */\n\n\n\t  ShapeSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {\n\t    var p = this._props,\n\t        angle = this._posData.angle + p.degreeShift,\n\t        point = _h2.default.getRadialPoint({\n\t      angle: p.isSwirl ? angle + this._getSwirl(proc) : angle,\n\t      radius: proc * this._posData.radius * p.pathScale,\n\t      center: {\n\t        x: this._posData.x.start,\n\t        y: this._posData.y.start\n\t      }\n\t    });\n\t    // if foreign svg canvas - set position without units\n\t    var x = point.x,\n\t        y = point.y,\n\t        smallNumber = 0.000001;\n\n\t    // remove very small numbers to prevent exponential forms\n\t    if (x > 0 && x < smallNumber) {\n\t      x = smallNumber;\n\t    }\n\t    if (y > 0 && y < smallNumber) {\n\t      y = smallNumber;\n\t    }\n\t    if (x < 0 && x > -smallNumber) {\n\t      x = -smallNumber;\n\t    }\n\t    if (y < 0 && y > -smallNumber) {\n\t      y = -smallNumber;\n\t    }\n\n\t    p.x = this._o.ctx ? x : '' + x + this._posData.x.units;\n\t    p.y = this._o.ctx ? y : '' + y + this._posData.y.units;\n\t  };\n\t  /*\n\t    Method to get progress of the swirl.\n\t    @private\n\t    @param {Number} Progress of the Swirl.\n\t    @returns {Number} Progress of the swirl.\n\t  */\n\n\n\t  ShapeSwirl.prototype._getSwirl = function _getSwirl(proc) {\n\t    var p = this._props;\n\t    return p.direction * p.swirlSize * Math.sin(p.swirlFrequency * proc);\n\t  };\n\t  /*\n\t    Method to draw shape.\n\t    If !isWithShape - draw self el only, but not shape.\n\t    @private\n\t    @overrides @ Shape.\n\t  */\n\n\n\t  ShapeSwirl.prototype._draw = function _draw() {\n\t    // call _draw or just _drawEl @ Shape depending if there is `shape`\n\t    var methodName = this._props.isWithShape ? '_draw' : '_drawEl';\n\t    _shape2.default.prototype[methodName].call(this);\n\t  };\n\n\t  return ShapeSwirl;\n\t}(_shape2.default);\n\n\texports.default = ShapeSwirl;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _shapeSwirl = __webpack_require__(3);\n\n\tvar _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);\n\n\tvar _tunable = __webpack_require__(13);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t// import Shape    from './shape';\n\n\tvar Burst = function (_Tunable) {\n\t  (0, _inherits3.default)(Burst, _Tunable);\n\n\t  function Burst() {\n\t    (0, _classCallCheck3.default)(this, Burst);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tunable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare defaults.\n\t    @override @ ShapeSwirl.\n\t  */\n\n\t  Burst.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      /* [number > 0] :: Quantity of Burst particles. */\n\t      count: 5,\n\t      /* [0 < number < 360] :: Degree of the Burst. */\n\t      degree: 360,\n\t      /* ∆ :: [number > 0] :: Radius of the Burst. */\n\t      radius: { 0: 50 },\n\t      /* ∆ :: [number > 0] :: X radius of the Burst. */\n\t      radiusX: null,\n\t      /* ∆ :: [number > 0] :: Y radius of the Burst. */\n\t      radiusY: null,\n\t      /* [number >= 0] :: width of the main swirl. */\n\t      width: 0,\n\t      /* [number >= 0] :: height of the main swirl. */\n\t      height: 0\n\t    };\n\t  };\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    overrides @ Thenable\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\n\n\t  Burst.prototype.then = function then(o) {\n\t    // remove tween properties (not callbacks)\n\t    this._removeTweenProperties(o);\n\n\t    var newMaster = this._masterThen(o),\n\t        newSwirls = this._childThen(o);\n\n\t    this._setSwirlDuration(newMaster, this._calcPackTime(newSwirls));\n\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\n\n\t  Burst.prototype.tune = function tune(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    // save timeline options to _timelineOptions\n\t    // and delete the timeline options on o\n\t    // cuz masterSwirl should not get them\n\t    this._saveTimelineOptions(o);\n\n\t    // add new timeline properties to timeline\n\t    this.timeline._setProp(this._timelineOptions);\n\n\t    // remove tween options (not callbacks)\n\t    this._removeTweenProperties(o);\n\n\t    // tune _props\n\t    this._tuneNewOptions(o);\n\n\t    // tune master swirl\n\t    this.masterSwirl.tune(o);\n\n\t    // tune child swirls\n\t    this._tuneSwirls(o);\n\n\t    // recalc time for modules\n\t    this._recalcModulesTime();\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHODS ^\n\t  // v PRIVATE METHODS v\n\n\t  /*\n\t    Method to copy `_o` options to `_props` object\n\t    with fallback to `_defaults`.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Burst.prototype._extendDefaults = function _extendDefaults() {\n\t    // remove tween properties (not callbacks)\n\t    this._removeTweenProperties(this._o);\n\t    _Tunable.prototype._extendDefaults.call(this);\n\t  };\n\t  /*\n\t    Method to remove all tween (excluding\n\t    callbacks) props from object.\n\t    @private\n\t    @param {Object} Object which should be cleaned\n\t                    up from tween properties.\n\t  */\n\n\n\t  Burst.prototype._removeTweenProperties = function _removeTweenProperties(o) {\n\t    for (var key in _h2.default.tweenOptionMap) {\n\t      // remove all items that are not declared in _defaults\n\t      if (this._defaults[key] == null) {\n\t        delete o[key];\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to recalc modules chain tween\n\t    times after tuning new options.\n\t    @private\n\t  */\n\n\n\t  Burst.prototype._recalcModulesTime = function _recalcModulesTime() {\n\t    var modules = this.masterSwirl._modules,\n\t        swirls = this._swirls,\n\t        shiftTime = 0;\n\n\t    for (var i = 0; i < modules.length; i++) {\n\t      var tween = modules[i].tween,\n\t          packTime = this._calcPackTime(swirls[i]);\n\t      tween._setProp({ 'duration': packTime, 'shiftTime': shiftTime });\n\t      shiftTime += packTime;\n\t    }\n\n\t    this.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to tune Swirls with new options.\n\t    @private\n\t    @param {Object} New options.\n\t  */\n\n\n\t  Burst.prototype._tuneSwirls = function _tuneSwirls(o) {\n\t    // get swirls in first pack\n\t    var pack0 = this._swirls[0];\n\t    for (var i = 0; i < pack0.length; i++) {\n\t      var swirl = pack0[i],\n\t          option = this._getChildOption(o || {}, i);\n\n\t      // since the `degreeShift` participate in\n\t      // children position calculations, we need to keep\n\t      // the old `degreeShift` value if new not set\n\t      var isDegreeShift = option.degreeShift != null;\n\t      if (!isDegreeShift) {\n\t        option.degreeShift = this._swirls[0][i]._props.degreeShift;\n\t      }\n\n\t      this._addBurstProperties(option, i);\n\n\t      // after burst position calculation - delete the old `degreeShift`\n\t      // from the options, since anyways we have copied it from the swirl\n\t      if (!isDegreeShift) {\n\t        delete option.degreeShift;\n\t      }\n\n\t      swirl.tune(option);\n\t      this._refreshBurstOptions(swirl._modules, i);\n\t    }\n\t  };\n\t  /*\n\t    Method to refresh burst x/y/angle options on further chained \n\t    swirls, because they will be overriden after `tune` call on\n\t    very first swirl.\n\t    @param {Array} Chained modules array\n\t    param {Number} Index of the first swirl in the chain.\n\t  */\n\n\n\t  Burst.prototype._refreshBurstOptions = function _refreshBurstOptions(modules, i) {\n\t    for (var j = 1; j < modules.length; j++) {\n\t      var module = modules[j],\n\t          options = {};\n\t      this._addBurstProperties(options, i, j);\n\t      module._tuneNewOptions(options);\n\t    }\n\t  };\n\t  /*\n\t    Method to call then on masterSwirl.\n\t    @param {Object} Then options.\n\t    @returns {Object} New master swirl.\n\t  */\n\n\n\t  Burst.prototype._masterThen = function _masterThen(o) {\n\t    this.masterSwirl.then(o);\n\t    // get the latest master swirl in then chain\n\t    var newMasterSwirl = _h2.default.getLastItem(this.masterSwirl._modules);\n\t    // save to masterSwirls\n\t    this._masterSwirls.push(newMasterSwirl);\n\t    return newMasterSwirl;\n\t  };\n\t  /*\n\t    Method to call then on child swilrs.\n\t    @param {Object} Then options.\n\t    @return {Array} Array of new Swirls.\n\t  */\n\n\n\t  Burst.prototype._childThen = function _childThen(o) {\n\t    var pack = this._swirls[0],\n\t        newPack = [];\n\n\t    for (var i = 0; i < pack.length; i++) {\n\t      // get option by modulus\n\t      var options = this._getChildOption(o, i);\n\t      var swirl = pack[i];\n\t      var lastSwirl = _h2.default.getLastItem(swirl._modules);\n\t      // add new Master Swirl as parent of new childswirl\n\t      options.parent = this.el;\n\n\t      this._addBurstProperties(options, i, this._masterSwirls.length - 1);\n\n\t      swirl.then(options);\n\n\t      // save the new item in `then` chain\n\t      newPack.push(_h2.default.getLastItem(swirl._modules));\n\t    }\n\t    // save the pack to _swirls object\n\t    this._swirls[this._masterSwirls.length - 1] = newPack;\n\t    return newPack;\n\t  };\n\t  /*\n\t    Method to initialize properties.\n\t    @private\n\t    @overrides @ Thenable\n\t  */\n\n\n\t  Burst.prototype._vars = function _vars() {\n\t    _Tunable.prototype._vars.call(this);\n\t    // just buffer timeline for calculations\n\t    this._bufferTimeline = new _timeline2.default();\n\t  };\n\t  /*\n\t    Method for initial render of the module.\n\t  */\n\n\n\t  Burst.prototype._render = function _render() {\n\t    this._o.isWithShape = false;\n\t    this._o.isSwirl = this._props.isSwirl;\n\t    this._o.callbacksContext = this;\n\t    // save timeline options and remove from _o\n\t    // cuz the master swirl should not get them\n\t    this._saveTimelineOptions(this._o);\n\n\t    this.masterSwirl = new MainSwirl(this._o);\n\t    this._masterSwirls = [this.masterSwirl];\n\t    this.el = this.masterSwirl.el;\n\n\t    this._renderSwirls();\n\t  };\n\t  /*\n\t    Method for initial render of swirls.\n\t    @private\n\t  */\n\n\n\t  Burst.prototype._renderSwirls = function _renderSwirls() {\n\t    var p = this._props,\n\t        pack = [];\n\n\t    for (var i = 0; i < p.count; i++) {\n\t      var option = this._getChildOption(this._o, i);\n\t      pack.push(new ChildSwirl(this._addOptionalProps(option, i)));\n\t    }\n\t    this._swirls = { 0: pack };\n\t    this._setSwirlDuration(this.masterSwirl, this._calcPackTime(pack));\n\t  };\n\t  /*\n\t    Method to save timeline options to _timelineOptions\n\t    and delete the property on the object.\n\t    @private\n\t    @param {Object} The object to save the timeline options from.\n\t  */\n\n\n\t  Burst.prototype._saveTimelineOptions = function _saveTimelineOptions(o) {\n\t    this._timelineOptions = o.timeline;\n\t    delete o.timeline;\n\t  };\n\t  /*\n\t    Method to calculate total time of array of\n\t    concurrent tweens.\n\t    @param   {Array}  Pack to calculate the total time for.\n\t    @returns {Number} Total pack duration.\n\t  */\n\n\n\t  Burst.prototype._calcPackTime = function _calcPackTime(pack) {\n\t    var maxTime = 0;\n\t    for (var i = 0; i < pack.length; i++) {\n\t      var tween = pack[i].tween,\n\t          p = tween._props;\n\n\t      maxTime = Math.max(p.repeatTime / p.speed, maxTime);\n\t    }\n\n\t    return maxTime;\n\t  };\n\t  /*\n\t    Method to set duration for Swirl.\n\t    @param {Object} Swirl instance to set the duration to.\n\t    @param {Number} Duration to set.\n\t  */\n\n\n\t  Burst.prototype._setSwirlDuration = function _setSwirlDuration(swirl, duration) {\n\t    swirl.tween._setProp('duration', duration);\n\t    var isRecalc = swirl.timeline && swirl.timeline._recalcTotalDuration;\n\t    isRecalc && swirl.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to get childOption form object call by modulus.\n\t    @private\n\t    @param   {Object} Object to look in.\n\t    @param   {Number} Index of the current Swirl.\n\t    @returns {Object} Options for the current swirl.\n\t  */\n\n\n\t  Burst.prototype._getChildOption = function _getChildOption(obj, i) {\n\t    var options = {};\n\t    for (var key in obj.children) {\n\t      options[key] = this._getPropByMod(key, i, obj.children);\n\t    }\n\t    return options;\n\t  };\n\t  /*\n\t    Method to get property by modulus.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Number} Index for the modulus.\n\t    @param {Object} Source object to check in.\n\t    @returns {Any} Property.\n\t  */\n\n\n\t  Burst.prototype._getPropByMod = function _getPropByMod(name, index) {\n\t    var sourceObj = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t    var prop = sourceObj[name];\n\t    return _h2.default.isArray(prop) ? prop[index % prop.length] : prop;\n\t  };\n\t  /*\n\t    Method to add optional Swirls' properties to passed object.\n\t    @private\n\t    @param {Object} Object to add the properties to.\n\t    @param {Number} Index of the property.\n\t  */\n\n\n\t  Burst.prototype._addOptionalProps = function _addOptionalProps(options, index) {\n\t    options.index = index;\n\t    options.parent = this.masterSwirl.el;\n\n\t    this._addBurstProperties(options, index);\n\n\t    return options;\n\t  };\n\t  /*\n\t    Method to add Burst options to object.\n\t    @private\n\t    @param {Object} Options to add the properties to.\n\t    @param {Number} Index of the Swirl.\n\t    @param {Number} Index of the main swirl.\n\t  */\n\n\n\t  Burst.prototype._addBurstProperties = function _addBurstProperties(options, index, i) {\n\t    // save index of the module\n\t    var mainIndex = this._index;\n\t    // temporary change the index to parse index based properties like stagger\n\t    this._index = index;\n\t    // parse degree shift for the bit\n\t    var degreeShift = this._parseProperty('degreeShift', options.degreeShift || 0);\n\t    // put the index of the module back\n\t    this._index = mainIndex;\n\n\t    var p = this._props,\n\t        degreeCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,\n\t        step = p.degree / degreeCnt,\n\t        pointStart = this._getSidePoint('start', index * step + degreeShift, i),\n\t        pointEnd = this._getSidePoint('end', index * step + degreeShift, i);\n\n\t    options.x = this._getDeltaFromPoints('x', pointStart, pointEnd);\n\t    options.y = this._getDeltaFromPoints('y', pointStart, pointEnd);\n\n\t    options.angle = this._getBitAngle(options.angle || 0, degreeShift, index);\n\t  };\n\t  /* \n\t    Method to get shapes angle in burst so\n\t    it will follow circular shape.\n\t     \n\t     @param    {Number, Object} Base angle.\n\t     @param    {Number}         Angle shift for the bit\n\t     @param    {Number}         Shape's index in burst.\n\t     @returns  {Number}         Angle in burst.\n\t  */\n\n\n\t  Burst.prototype._getBitAngle = function _getBitAngle() {\n\t    var angleProperty = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\t    var angleShift = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\t    var i = arguments[2];\n\n\t    var p = this._props,\n\t        degCnt = p.degree % 360 === 0 ? p.count : p.count - 1 || 1,\n\t        step = p.degree / degCnt,\n\t        angle = i * step + 90;\n\n\t    angle += angleShift;\n\t    // if not delta option\n\t    if (!this._isDelta(angleProperty)) {\n\t      angleProperty += angle;\n\t    } else {\n\t      var delta = {},\n\t          keys = (0, _keys2.default)(angleProperty),\n\t          start = keys[0],\n\t          end = angleProperty[start];\n\n\t      start = _h2.default.parseStringOption(start, i);\n\t      end = _h2.default.parseStringOption(end, i);\n\t      // new start = newEnd\n\t      delta[parseFloat(start) + angle] = parseFloat(end) + angle;\n\n\t      angleProperty = delta;\n\t    }\n\t    return angleProperty;\n\t  };\n\t  /*\n\t    Method to get radial point on `start` or `end`.\n\t    @private\n\t    @param {String} Name of the side - [start, end].\n\t    @param {Number} Angle of the radial point.\n\t    @param {Number} Index of the main swirl.\n\t    @returns radial point.\n\t  */\n\n\n\t  Burst.prototype._getSidePoint = function _getSidePoint(side, angle, i) {\n\t    var p = this._props,\n\t        sideRadius = this._getSideRadius(side, i);\n\n\t    return _h2.default.getRadialPoint({\n\t      radius: sideRadius.radius,\n\t      radiusX: sideRadius.radiusX,\n\t      radiusY: sideRadius.radiusY,\n\t      angle: angle,\n\t      // center:  { x: p.center, y: p.center }\n\t      center: { x: 0, y: 0 }\n\t    });\n\t  };\n\t  /*\n\t    Method to get radius of the side.\n\t    @private\n\t    @param {String} Name of the side - [start, end].\n\t    @param {Number} Index of the main swirl.\n\t    @returns {Object} Radius.\n\t  */\n\n\n\t  Burst.prototype._getSideRadius = function _getSideRadius(side, i) {\n\t    return {\n\t      radius: this._getRadiusByKey('radius', side, i),\n\t      radiusX: this._getRadiusByKey('radiusX', side, i),\n\t      radiusY: this._getRadiusByKey('radiusY', side, i)\n\t    };\n\t  };\n\t  /*\n\t    Method to get radius from ∆ or plain property.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {String} Side name - [start, end].\n\t    @param {Number} Index of the main swirl.\n\t    @returns {Number} Radius value.\n\t  */\n\n\n\t  Burst.prototype._getRadiusByKey = function _getRadiusByKey(key, side) {\n\t    var i = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n\t    var swirl = this._masterSwirls[i],\n\t        deltas = swirl._deltas,\n\t        props = swirl._props;\n\n\t    if (deltas[key] != null) {\n\t      return deltas[key][side];\n\t    } else if (props[key] != null) {\n\t      return props[key];\n\t    }\n\t  };\n\t  /*\n\t    Method to get delta from start and end position points.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {Object} Start position point.\n\t    @param {Object} End position point.\n\t    @returns {Object} Delta of the end/start.\n\t  */\n\n\n\t  Burst.prototype._getDeltaFromPoints = function _getDeltaFromPoints(key, pointStart, pointEnd) {\n\t    var delta = {};\n\t    if (pointStart[key] === pointEnd[key]) {\n\t      delta = pointStart[key];\n\t    } else {\n\t      delta[pointStart[key]] = pointEnd[key];\n\t    }\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to create timeline.\n\t    @private\n\t    @override @ Tweenable\n\t  */\n\n\n\t  Burst.prototype._makeTimeline = function _makeTimeline() {\n\t    // restore timeline options that were deleted in _render method\n\t    this._o.timeline = this._timelineOptions;\n\t    _Tunable.prototype._makeTimeline.call(this);\n\t    this.timeline.add(this.masterSwirl, this._swirls[0]);\n\t  };\n\t  /*\n\t    Method to make Tween for the module.\n\t    @private\n\t    @override @ Tweenable\n\t  */\n\n\n\t  Burst.prototype._makeTween = function _makeTween() {} /* don't create any tween */\n\t  /*\n\t    Override `_hide` and `_show` methods on module\n\t    since we don't have to hide nor show on the module.\n\t  */\n\t  ;\n\n\t  Burst.prototype._hide = function _hide() {/* do nothing */};\n\n\t  Burst.prototype._show = function _show() {/* do nothing */};\n\n\t  return Burst;\n\t}(_tunable2.default);\n\n\tvar ChildSwirl = function (_ShapeSwirl) {\n\t  (0, _inherits3.default)(ChildSwirl, _ShapeSwirl);\n\n\t  function ChildSwirl() {\n\t    (0, _classCallCheck3.default)(this, ChildSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _ShapeSwirl.apply(this, arguments));\n\t  }\n\n\t  ChildSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _ShapeSwirl.prototype._declareDefaults.call(this);\n\t    this._defaults.isSwirl = false;\n\t    this._o.duration = this._o.duration != null ? this._o.duration : 700;\n\t  };\n\t  // disable degreeshift calculations\n\n\n\t  ChildSwirl.prototype._calcSwirlXY = function _calcSwirlXY(proc) {\n\t    var degreeShift = this._props.degreeShift;\n\n\t    this._props.degreeShift = 0;\n\t    _ShapeSwirl.prototype._calcSwirlXY.call(this, proc);\n\t    this._props.degreeShift = degreeShift;\n\t  };\n\n\t  return ChildSwirl;\n\t}(_shapeSwirl2.default);\n\n\tvar MainSwirl = function (_ChildSwirl) {\n\t  (0, _inherits3.default)(MainSwirl, _ChildSwirl);\n\n\t  function MainSwirl() {\n\t    (0, _classCallCheck3.default)(this, MainSwirl);\n\t    return (0, _possibleConstructorReturn3.default)(this, _ChildSwirl.apply(this, arguments));\n\t  }\n\n\t  MainSwirl.prototype._declareDefaults = function _declareDefaults() {\n\t    _ChildSwirl.prototype._declareDefaults.call(this);\n\t    this._defaults.scale = 1;\n\t    this._defaults.width = 0;\n\t    this._defaults.height = 0;\n\t    this._defaults.radius = { 25: 75 };\n\t    // this._defaults.duration = 2000;\n\t  };\n\n\t  return MainSwirl;\n\t}(ChildSwirl);\n\n\tBurst.ChildSwirl = ChildSwirl;\n\tBurst.MainSwirl = MainSwirl;\n\n\texports.default = Burst;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _extends4 = __webpack_require__(27);\n\n\tvar _extends5 = _interopRequireDefault(_extends4);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _thenable = __webpack_require__(12);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _deltas = __webpack_require__(15);\n\n\tvar _deltas2 = _interopRequireDefault(_deltas);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(19);\n\n\n\t// get tween properties\n\tvar obj = {};\n\t_tween2.default.prototype._declareDefaults.call(obj);\n\tvar keys = (0, _keys2.default)(obj._defaults);\n\tfor (var i = 0; i < keys.length; i++) {\n\t  obj._defaults[keys[i]] = 1;\n\t}\n\tobj._defaults['timeline'] = 1;\n\tvar TWEEN_PROPERTIES = obj._defaults;\n\n\t/*\n\t  TODO:\n\n\t    - change _props to _propsObj for animations\n\t    - current values in deltas\n\t*/\n\n\tvar Html = function (_Thenable) {\n\t  (0, _inherits3.default)(Html, _Thenable);\n\n\t  function Html() {\n\t    (0, _classCallCheck3.default)(this, Html);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));\n\t  }\n\n\t  Html.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      x: 0,\n\t      y: 0,\n\t      z: 0,\n\n\t      skewX: 0,\n\t      skewY: 0,\n\n\t      // angle:      0,\n\t      angleX: 0,\n\t      angleY: 0,\n\t      angleZ: 0,\n\n\t      scale: 1,\n\t      scaleX: 1,\n\t      scaleY: 1,\n\n\t      isSoftHide: true,\n\t      isShowStart: true,\n\t      isShowEnd: true,\n\t      isForce3d: false,\n\t      isRefreshState: true\n\n\t    };\n\t    // exclude from automatic drawing\n\t    this._drawExclude = { el: 1 };\n\t    // properties that cause 3d layer\n\t    this._3dProperties = ['angleX', 'angleY', 'z'];\n\t    // properties that have array values\n\t    this._arrayPropertyMap = { transformOrigin: 1, backgroundPosition: 1 };\n\t    // properties that have no units\n\t    this._numberPropertyMap = {\n\t      opacity: 1, scale: 1, scaleX: 1, scaleY: 1,\n\t      // angle: 1,\n\t      angleX: 1, angleY: 1, angleZ: 1,\n\t      skewX: 1, skewY: 1\n\t    };\n\t    // properties that should be prefixed\n\t    this._prefixPropertyMap = { transform: 1, transformOrigin: 1 };\n\t    // save prefix\n\t    this._prefix = h.prefix.css;\n\t  };\n\n\t  Html.prototype.then = function then(o) {\n\t    // return if nothing was passed\n\t    if (o == null || !(0, _keys2.default)(o).length) {\n\t      return 1;\n\t    }\n\n\t    // get the last item in `then` chain\n\t    var prevModule = h.getLastItem(this._modules);\n\t    // set deltas to the finish state\n\t    prevModule.deltas.refresh(false);\n\t    // copy finish state to the last history record\n\t    this._history[this._history.length - 1] = prevModule._o;\n\t    // call super\n\t    _Thenable.prototype.then.call(this, o);\n\t    // restore the _props\n\t    prevModule.deltas.restore();\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to pipe startValue of the delta.\n\t    @private\n\t    @ovarrides @ Thenable\n\t    @param {String} Start property name.\n\t    @param {Any} Start property value.\n\t    @returns {Any} Start property value.\n\t  */\n\n\n\t  Html.prototype._checkStartValue = function _checkStartValue(key, value) {\n\t    if (value == null) {\n\t      // return default value for transforms\n\t      if (this._defaults[key] != null) {\n\t        return this._defaults[key];\n\t      }\n\t      // return default value from _customProps\n\t      if (this._customProps[key] != null) {\n\t        return this._customProps[key];\n\t      }\n\t      // try to get the default value\n\t      if (h.defaultStyles[key] != null) {\n\t        return h.defaultStyles[key];\n\t      }\n\t      // at the end return 0\n\t      return 0;\n\t    }\n\n\t    return value;\n\t  };\n\t  /*\n\t    Method to draw _props to el.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._draw = function _draw() {\n\t    var p = this._props;\n\t    for (var i = 0; i < this._drawProps.length; i++) {\n\t      var name = this._drawProps[i];\n\t      this._setStyle(name, p[name]);\n\t    }\n\t    // draw transforms\n\t    this._drawTransform();\n\t    // call custom transform callback if exist\n\t    this._customDraw && this._customDraw(this._props.el, this._props);\n\t  };\n\t  /*\n\t    Method to set transform on element.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._drawTransform = function _drawTransform() {\n\t    var p = this._props;\n\t    var string = !this._is3d ? 'translate(' + p.x + ', ' + p.y + ')\\n          rotate(' + p.angleZ + 'deg)\\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\\n          scale(' + p.scaleX + ', ' + p.scaleY + ')' : 'translate3d(' + p.x + ', ' + p.y + ', ' + p.z + ')\\n          rotateX(' + p.angleX + 'deg)\\n          rotateY(' + p.angleY + 'deg)\\n          rotateZ(' + p.angleZ + 'deg)\\n          skew(' + p.skewX + 'deg, ' + p.skewY + 'deg)\\n          scale(' + p.scaleX + ', ' + p.scaleY + ')';\n\n\t    this._setStyle('transform', string);\n\t  };\n\t  /*\n\t    Method to render on initialization.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Html.prototype._render = function _render() {\n\t    // return immediately if not the first in `then` chain\n\t    if (this._o.prevChainModule) {\n\t      return;\n\t    }\n\n\t    var p = this._props;\n\n\t    for (var i = 0; i < this._renderProps.length; i++) {\n\t      var name = this._renderProps[i],\n\t          value = p[name];\n\n\t      value = typeof value === 'number' ? value + 'px' : value;\n\t      this._setStyle(name, value);\n\t    }\n\n\t    this._draw();\n\n\t    if (!p.isShowStart) {\n\t      this._hide();\n\t    }\n\t  };\n\t  /*\n\t    Method to set style on el.\n\t    @private\n\t    @param {String} Style property name.\n\t    @param {String} Style property value.\n\t  */\n\n\n\t  Html.prototype._setStyle = function _setStyle(name, value) {\n\t    if (this._state[name] !== value) {\n\t      var style = this._props.el.style;\n\t      // set style\n\t      style[name] = value;\n\t      // if prefix needed - set it\n\t      if (this._prefixPropertyMap[name]) {\n\t        style['' + this._prefix + name] = value;\n\t      }\n\t      // cache the last set value\n\t      this._state[name] = value;\n\t    }\n\t  };\n\t  /*\n\t    Method to copy `_o` options to `_props` object.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._extendDefaults = function _extendDefaults() {\n\t    this._props = this._o.props || {};\n\t    // props for intial render only\n\t    this._renderProps = [];\n\t    // props for draw on every frame update\n\t    this._drawProps = [];\n\t    // save custom properties if present\n\t    this._saveCustomProperties(this._o);\n\t    // copy the options\n\t    var o = (0, _extends5.default)({}, this._o);\n\t    // extend options with defaults\n\t    o = this._addDefaults(o);\n\n\t    var keys = (0, _keys2.default)(o);\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      // include the property if it is not in drawExclude object\n\t      // and not in defaults = not a transform\n\t      var isInclude = !this._drawExclude[key] && // not in exclude map\n\t      this._defaults[key] == null && // not transform property\n\t      !TWEEN_PROPERTIES[key]; // not tween property\n\n\t      var isCustom = this._customProps[key];\n\t      // copy all non-delta properties to the props\n\t      // if not delta then add the property to render\n\t      // list that is called on initialization\n\t      // otherwise add it to the draw list that will\n\t      // be drawed on each frame\n\t      if (!h.isDelta(o[key]) && !TWEEN_PROPERTIES[key]) {\n\t        this._parseOption(key, o[key]);\n\t        if (key === 'el') {\n\t          this._props.el = h.parseEl(o.el);\n\t          this.el = this._props.el;\n\t        }\n\t        if (isInclude && !isCustom) {\n\t          this._renderProps.push(key);\n\t        }\n\t        // copy delta prop but not transforms\n\t        // otherwise push it to draw list that gets traversed on every draw\n\t      } else if (isInclude && !isCustom) {\n\t          this._drawProps.push(key);\n\t        }\n\t    }\n\n\t    this._createDeltas(o);\n\t  };\n\t  /*\n\t    Method to save customProperties to _customProps.\n\t    @param {Object} Options of the module.\n\t  */\n\n\n\t  Html.prototype._saveCustomProperties = function _saveCustomProperties() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    this._customProps = o.customProperties || {};\n\t    this._customProps = (0, _extends5.default)({}, this._customProps);\n\t    this._customDraw = this._customProps.draw;\n\t    delete this._customProps.draw;\n\t    delete o.customProperties;\n\n\t    this._copyDefaultCustomProps();\n\n\t    // if ( this._customProps ) {}\n\t    // this._customProps = this._customProps || {};\n\t  };\n\n\t  Html.prototype._copyDefaultCustomProps = function _copyDefaultCustomProps() {\n\t    for (var key in this._customProps) {\n\t      if (this._o[key] == null) {\n\t        this._o[key] = this._customProps[key];\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to reset some flags on merged options object.\n\t    @private\n\t    @overrides @ Thenable\n\t    @param   {Object} Options object.\n\t    @returns {Object} Options object.\n\t  */\n\n\n\t  Html.prototype._resetMergedFlags = function _resetMergedFlags(o) {\n\t    _Thenable.prototype._resetMergedFlags.call(this, o);\n\t    o.props = this._props;\n\t    o.customProperties = this._customProps;\n\t    return o;\n\t  };\n\t  /*\n\t    Method to parse option value.\n\t    @private\n\t    @param {String} Option name.\n\t    @param {Any} Option value.\n\t  */\n\n\n\t  Html.prototype._parseOption = function _parseOption(key, value) {\n\t    _Thenable.prototype._parseOption.call(this, key, value);\n\t    // at this point the property is parsed\n\t    var parsed = this._props[key];\n\t    // cast it to string if it is array\n\t    if (h.isArray(parsed)) {\n\t      this._props[key] = this._arrToString(parsed);\n\t    }\n\t  };\n\t  /*\n\t    Method cast array to string value.\n\t    @private\n\t    @param {Array} Array of parsed numbers with units.\n\t    @returns {String} Casted array.\n\t  */\n\n\n\t  Html.prototype._arrToString = function _arrToString(arr) {\n\t    var string = '';\n\t    for (var i = 0; i < arr.length; i++) {\n\t      string += arr[i].string + ' ';\n\t    }\n\t    return string;\n\t  };\n\t  /*\n\t    Method to add defauls to passed object.\n\t    @private\n\t    @param {Object} Object to add defaults to.\n\t  */\n\n\n\t  Html.prototype._addDefaults = function _addDefaults(obj) {\n\t    // flag that after all defaults are set will indicate\n\t    // if user have set the 3d transform\n\t    this._is3d = false;\n\n\t    for (var key in this._defaults) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\n\t      // copy the properties to the _o object\n\t      // if it's null - set the default value\n\t      if (obj[key] == null) {\n\t        // scaleX and scaleY should fallback to scale\n\t        if (key === 'scaleX' || key === 'scaleY') {\n\t          obj[key] = obj['scale'] != null ? obj['scale'] : this._defaults['scale'];\n\t        } else {\n\t          obj[key] = this._defaults[key];\n\t        }\n\t      } else {\n\t        // get if 3d property was set.\n\t        if (this._3dProperties.indexOf(key) !== -1) {\n\t          this._is3d = true;\n\t        }\n\t      }\n\t    }\n\n\t    if (this._o.isForce3d) {\n\t      this._is3d = true;\n\t    }\n\n\t    return obj;\n\t  };\n\t  /*\n\t    Lifecycle method to declare variables.\n\t    @private\n\t  */\n\n\n\t  Html.prototype._vars = function _vars() {\n\t    // set deltas to the last value, so the _props with\n\t    // end values will be copied to the _history, it is\n\t    // crucial for `then` chaining\n\t    this.deltas.refresh(false);\n\t    // call super vars\n\t    _Thenable.prototype._vars.call(this);\n\t    // state of set properties\n\t    this._state = {};\n\t    // restore delta values that we have refreshed before\n\t    this.deltas.restore(false);\n\t  };\n\t  /*\n\t    Method to create deltas from passed object.\n\t    @private\n\t    @param {Object} Options object to pass to the Deltas.\n\t  */\n\n\n\t  Html.prototype._createDeltas = function _createDeltas(options) {\n\t    this.deltas = new _deltas2.default({\n\t      options: options,\n\t      props: this._props,\n\t      arrayPropertyMap: this._arrayPropertyMap,\n\t      numberPropertyMap: this._numberPropertyMap,\n\t      customProps: this._customProps,\n\t      callbacksContext: options.callbacksContext || this,\n\t      isChained: !!this._o.prevChainModule\n\t    });\n\n\t    // if chained module set timeline to deltas' timeline\n\t    if (this._o.prevChainModule) {\n\t      this.timeline = this.deltas.timeline;\n\t    }\n\t  };\n\t  /* @overrides @ Tweenable */\n\n\n\t  Html.prototype._makeTween = function _makeTween() {};\n\n\t  Html.prototype._makeTimeline = function _makeTimeline() {\n\t    // do not create timeline if module if chained\n\t    if (this._o.prevChainModule) {\n\t      return;\n\t    }\n\t    // add callbacks overrides\n\t    this._o.timeline = this._o.timeline || {};\n\t    this._addCallbackOverrides(this._o.timeline);\n\t    _Thenable.prototype._makeTimeline.call(this);\n\t    this.timeline.add(this.deltas);\n\t  };\n\t  /*\n\t    Method to add callback overrides to passed object object.\n\t    @param {Object} Object to add overrides on.\n\t  */\n\n\n\t  Html.prototype._addCallbackOverrides = function _addCallbackOverrides(o) {\n\t    var it = this;\n\t    var p = this._props;\n\t    o.callbackOverrides = {\n\t      onUpdate: this._draw,\n\t      onRefresh: this._props.isRefreshState ? this._draw : void 0,\n\t      onStart: function onStart(isFwd) {\n\t        // don't touch main `el` onStart in chained elements\n\t        if (it._isChained) {\n\t          return;\n\t        };\n\t        // show if was hidden at start\n\t        if (isFwd && !p.isShowStart) {\n\t          it._show();\n\t        }\n\t        // hide if should be hidden at start\n\t        else {\n\t            if (!p.isShowStart) {\n\t              it._hide();\n\t            }\n\t          }\n\t      },\n\t      onComplete: function onComplete(isFwd) {\n\t        // don't touch main `el` if not the last in `then` chain\n\t        if (it._isChained) {\n\t          return;\n\t        }\n\t        if (isFwd) {\n\t          if (!p.isShowEnd) {\n\t            it._hide();\n\t          }\n\t        } else if (!p.isShowEnd) {\n\t          it._show();\n\t        }\n\t      }\n\t    };\n\t  };\n\n\t  /*\n\t    Method that gets called on `soft` show of the module,\n\t    it should restore transform styles of the module.\n\t    @private\n\t    @overrides @ Module\n\t  */\n\n\n\t  Html.prototype._showByTransform = function _showByTransform() {\n\t    this._drawTransform();\n\t  };\n\n\t  /*\n\t    Method to merge `start` and `end` for a property in then record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Start value of the property.\n\t    @param {Any}    End value of the property.\n\t  */\n\t  // !! COVER !!\n\n\n\t  Html.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {\n\t    // if isnt tween property\n\t    var isBoolean = typeof endValue === 'boolean',\n\t        curve,\n\t        easing;\n\n\t    if (!h.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {\n\n\t      var TWEEN_PROPS = {};\n\t      if (h.isObject(endValue) && endValue.to != null) {\n\t        for (var _key in endValue) {\n\t          if (TWEEN_PROPERTIES[_key] || _key === 'curve') {\n\t            TWEEN_PROPS[_key] = endValue[_key];\n\t            delete endValue[_key];\n\t          }\n\t        }\n\t        // curve    = endValue.curve;\n\t        // easing   = endValue.easing;\n\t        endValue = endValue.to;\n\t      }\n\n\t      // if end value is delta - just save it\n\t      if (this._isDelta(endValue)) {\n\n\t        var _TWEEN_PROPS = {};\n\t        for (var _key2 in endValue) {\n\t          if (TWEEN_PROPERTIES[_key2] || _key2 === 'curve') {\n\t            _TWEEN_PROPS[_key2] = endValue[_key2];\n\t            delete endValue[_key2];\n\t          }\n\t        }\n\t        var result = this._parseDeltaValues(key, endValue);\n\n\t        return (0, _extends5.default)({}, result, _TWEEN_PROPS);\n\t      } else {\n\t        var parsedEndValue = this._parsePreArrayProperty(key, endValue);\n\t        // if end value is not delta - merge with start value\n\t        if (this._isDelta(startValue)) {\n\t          var _extends2;\n\n\t          // if start value is delta - take the end value\n\t          // as start value of the new delta\n\t          return (0, _extends5.default)((_extends2 = {}, _extends2[h.getDeltaEnd(startValue)] = parsedEndValue, _extends2), TWEEN_PROPS);\n\t          // if both start and end value are not ∆ - make ∆\n\t        } else {\n\t            var _extends3;\n\n\t            return (0, _extends5.default)((_extends3 = {}, _extends3[startValue] = parsedEndValue, _extends3), TWEEN_PROPS);\n\t          }\n\t      }\n\t      // copy the tween values unattended\n\t    } else {\n\t        return endValue;\n\t      }\n\t  };\n\n\t  return Html;\n\t}(_thenable2.default);\n\n\texports.default = Html;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tunable = __webpack_require__(13);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Stagger = function (_Tunable) {\n\t  (0, _inherits3.default)(Stagger, _Tunable);\n\n\t  function Stagger(options, Module) {\n\t    var _ret;\n\n\t    (0, _classCallCheck3.default)(this, Stagger);\n\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Tunable.call(this));\n\n\t    return _ret = _this._init(options, Module), (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t  /*\r\n\t    Method to create then chain on child modules.\r\n\t    @param {Object} Then options.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.then = function then(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].then(this._getOptionByIndex(i, o));\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to tune child modules.\r\n\t    @param {Object} Tune options.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.tune = function tune(o) {\n\t    if (o == null) {\n\t      return this;\n\t    }\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].tune(this._getOptionByIndex(i, o));\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to generate child modules.\r\n\t    @return {Object} this.\r\n\t  */\n\n\n\t  Stagger.prototype.generate = function generate() {\n\t    for (var i = 0; i < this._modules.length; i++) {\n\t      // get child module's option and pass to the child `then`\n\t      this._modules[i].generate();\n\t    }\n\t    this.timeline._recalcTotalDuration();\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to get an option by modulo and name.\r\n\t    @param {String} Name of the property to get.\r\n\t    @param {Number} Index for the modulo calculation.\r\n\t    @param {Object} Options hash to look in.\r\n\t    @return {Any} Property.\r\n\t  */\n\n\n\t  Stagger.prototype._getOptionByMod = function _getOptionByMod(name, i, store) {\n\t    var props = store[name];\n\t    // if not dom list then clone it to array\n\t    if (props + '' === '[object NodeList]' || props + '' === '[object HTMLCollection]') props = Array.prototype.slice.call(props, 0);\n\t    // get the value in array or return the value itself\n\t    var value = _h2.default.isArray(props) ? props[i % props.length] : props;\n\t    // check if value has the stagger expression, if so parse it\n\t    return _h2.default.parseIfStagger(value, i);\n\t  };\n\t  /*\r\n\t    Method to get option by modulo of index.\r\n\t    @param {Number} Index for modulo calculations.\r\n\t    @param {Object} Options hash to look in.\r\n\t  */\n\n\n\t  Stagger.prototype._getOptionByIndex = function _getOptionByIndex(i, store) {\n\t    var _this2 = this;\n\n\t    var options = {};\n\t    (0, _keys2.default)(store).forEach(function (key) {\n\t      return options[key] = _this2._getOptionByMod(key, i, store);\n\t    });\n\t    return options;\n\t  };\n\t  /*\r\n\t    Method to get total child modules quantity.\r\n\t    @param  {String} Name of quantifier in options hash.\r\n\t    @param  {Object} Options hash object.\r\n\t    @return {Number} Number of child object that should be defined.\r\n\t  */\n\n\n\t  Stagger.prototype._getChildQuantity = function _getChildQuantity(name, store) {\n\t    // if number was set\n\t    if (typeof name === 'number') {\n\t      return name;\n\t    }\n\n\t    var quantifier = store[name];\n\t    if (_h2.default.isArray(quantifier)) {\n\t      return quantifier.length;\n\t    } else if (quantifier + '' === '[object NodeList]') {\n\t      return quantifier.length;\n\t    } else if (quantifier + '' === '[object HTMLCollection]') {\n\t      return Array.prototype.slice.call(quantifier, 0).length;\n\t    } else if (quantifier instanceof HTMLElement) {\n\t      return 1;\n\t    } else if (typeof quantifier == 'string') {\n\t      return 1;\n\t    }\n\t  };\n\t  /*\r\n\t    Method to make stagger form options\r\n\t    @param {Object} Options.\r\n\t    @param {Object} Child class.\r\n\t  */\n\n\n\t  Stagger.prototype._init = function _init(options, Module) {\n\t    var count = this._getChildQuantity(options.quantifier || 'el', options);\n\t    this._createTimeline(options);this._modules = [];\n\t    for (var i = 0; i < count; i++) {\n\t      // get child module's option\n\t      var option = this._getOptionByIndex(i, options);\n\t      option.isRunLess = true;\n\t      // set index of the module\n\t      option.index = i;\n\t      // create child module\n\t      var module = new Module(option);this._modules.push(module);\n\t      // add child module's timeline to the self timeline\n\t      this.timeline.add(module);\n\t    }\n\t    return this;\n\t  };\n\t  /*\r\n\t    Method to create timeline.\r\n\t    @param {Object} Timeline options.\r\n\t  */\n\n\n\t  Stagger.prototype._createTimeline = function _createTimeline() {\n\t    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    this.timeline = new _timeline2.default(options.timeline);\n\t  };\n\n\t  /* @overrides @ Tweenable */\n\n\n\t  Stagger.prototype._makeTween = function _makeTween() {};\n\n\t  Stagger.prototype._makeTimeline = function _makeTimeline() {};\n\n\t  return Stagger;\n\t}(_tunable2.default);\n\n\tmodule.exports = function (Module) {\n\t  return function (options) {\n\t    return new Stagger(options, Module);\n\t  };\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\r\n\t  Class for toggling opacity on bunch of elements\r\n\t  @class Spriter\r\n\t  @todo\r\n\t    - add isForce3d option\r\n\t    - add run new option merging\r\n\t    - add then chains\r\n\t*/\n\n\tvar Spriter = function () {\n\t  /*\r\n\t    Defaults/APIs\r\n\t  */\n\n\t  Spriter.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      /*\r\n\t        Duration\r\n\t        @property duration\r\n\t        @type     {Number}\r\n\t      */\n\t      duration: 500,\n\t      /*\r\n\t        Delay\r\n\t        @property delay\r\n\t        @type     {Number}\r\n\t      */\n\t      delay: 0,\n\t      /*\r\n\t        Easing. Please see the \r\n\t        [timeline module parseEasing function](timeline.coffee.html#parseEasing)\r\n\t        for all avaliable options.\r\n\t          @property easing\r\n\t        @type     {String, Function}\r\n\t      */\n\t      easing: 'linear.none',\n\t      /*\r\n\t        Repeat times count\r\n\t        \r\n\t        @property repeat\r\n\t        @type     {Number}\r\n\t      */\n\t      repeat: 0,\n\t      /*\r\n\t        Yoyo option defines if animation should be altered on repeat.\r\n\t        \r\n\t        @property yoyo\r\n\t        @type     {Boolean}\r\n\t      */\n\t      yoyo: false,\n\t      /*\r\n\t        isRunLess option prevents animation from running immediately after\r\n\t        initialization.\r\n\t        \r\n\t        @property isRunLess\r\n\t        @type     {Boolean}\r\n\t      */\n\t      isRunLess: false,\n\t      /*\r\n\t        isShowEnd option defines if the last frame should be shown when\r\n\t        animation completed.\r\n\t        \r\n\t        @property isShowEnd\r\n\t        @type     {Boolean}\r\n\t      */\n\t      isShowEnd: false,\n\t      /*\r\n\t        onStart callback will be called once on animation start.\r\n\t        \r\n\t        @property onStart\r\n\t        @type     {Function}\r\n\t      */\n\t      onStart: null,\n\t      /*\r\n\t        onUpdate callback will be called on every frame of the animation.\r\n\t        The current progress in range **[0,1]** will be passed to the callback.\r\n\t        \r\n\t        @property onUpdate\r\n\t        @type     {Function}\r\n\t      */\n\t      onUpdate: null,\n\t      /*\r\n\t        onComplete callback will be called once on animation complete.\r\n\t        \r\n\t        @property onComplete\r\n\t        @type     {Function}\r\n\t      */\n\t      onComplete: null\n\t    };\n\t  };\n\n\t  function Spriter() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Spriter);\n\n\t    this.o = o;\n\t    if (!this.o.el) {\n\t      return _h2.default.error('No \"el\" option specified, aborting');\n\t    }\n\t    this._vars();this._declareDefaults();this._extendDefaults();this._parseFrames();\n\t    if (this._frames.length <= 2) _h2.default.warn('Spriter: only ' + this._frames.length + ' frames found');\n\t    if (this._frames.length < 1) _h2.default.error(\"Spriter: there is no frames to animate, aborting\");\n\t    this._createTween();\n\t    return this;\n\t  }\n\t  /*\r\n\t    Method to declare some variables.\r\n\t    \r\n\t    @method run\r\n\t    @param  {Object} New options\r\n\t    @todo   Implement new object merging\r\n\t  */\n\n\n\t  Spriter.prototype._vars = function _vars() {\n\t    this._props = _h2.default.cloneObj(this.o);\n\t    this.el = this.o.el;\n\t    this._frames = [];\n\t  };\n\t  /*\r\n\t    Method to run the spriter on demand.\r\n\t    \r\n\t    @method run\r\n\t    @param  {Object} New options\r\n\t    @todo   Implement new object merging\r\n\t  */\n\n\n\t  Spriter.prototype.run = function run(o) {\n\t    return this.timeline.play();\n\t  };\n\t  /*\r\n\t    Method to extend _props by options(this.o)\r\n\t    \r\n\t    @method _extendDefaults\r\n\t  */\n\n\n\t  Spriter.prototype._extendDefaults = function _extendDefaults() {\n\t    return _h2.default.extend(this._props, this._defaults);\n\t  };\n\t  /*\r\n\t    Method to parse frames as child nodes of el.\r\n\t    \r\n\t    @method _parseFrames\r\n\t  */\n\n\n\t  Spriter.prototype._parseFrames = function _parseFrames() {\n\t    this._frames = Array.prototype.slice.call(this.el.children, 0);\n\t    this._frames.forEach(function (frame, i) {\n\t      return frame.style.opacity = 0;\n\t    });\n\t    this._frameStep = 1 / this._frames.length;\n\t  };\n\n\t  /*\r\n\t    Method to create tween and timeline and supply callbacks.\r\n\t    \r\n\t    @method _createTween\r\n\t  */\n\n\n\t  Spriter.prototype._createTween = function _createTween() {\n\t    var _this = this;\n\n\t    this._tween = new _tween2.default({\n\t      duration: this._props.duration,\n\t      delay: this._props.delay,\n\t      yoyo: this._props.yoyo,\n\t      repeat: this._props.repeat,\n\t      easing: this._props.easing,\n\t      onStart: function onStart() {\n\t        return _this._props.onStart && _this._props.onStart();\n\t      },\n\t      onComplete: function onComplete() {\n\t        return _this._props.onComplete && _this._props.onComplete();\n\t      },\n\t      onUpdate: function onUpdate(p) {\n\t        return _this._setProgress(p);\n\t      }\n\t    });\n\t    this.timeline = new _timeline2.default();this.timeline.add(this._tween);\n\t    if (!this._props.isRunLess) this._startTween();\n\t  };\n\n\t  /*\r\n\t    Method to start tween\r\n\t    \r\n\t    @method _startTween\r\n\t  */\n\n\n\t  Spriter.prototype._startTween = function _startTween() {\n\t    var _this2 = this;\n\n\t    setTimeout(function () {\n\t      return _this2.timeline.play();\n\t    }, 1);\n\t  };\n\t  /*\r\n\t    Method to set progress of the sprite\r\n\t    \r\n\t    @method _setProgress\r\n\t    @param  {Number} Progress in range **[0,1]**\r\n\t  */\n\n\n\t  Spriter.prototype._setProgress = function _setProgress(p) {\n\t    // get the frame number\n\t    var proc = Math.floor(p / this._frameStep);\n\t    // react only if frame changes\n\t    if (this._prevFrame != this._frames[proc]) {\n\t      // if previous frame isnt current one, hide it\n\t      if (this._prevFrame) {\n\t        this._prevFrame.style.opacity = 0;\n\t      }\n\t      // if end of animation and isShowEnd flag was specified\n\t      // then show the last frame else show current frame\n\t      var currentNum = p === 1 && this._props.isShowEnd ? proc - 1 : proc;\n\t      // show the current frame\n\t      if (this._frames[currentNum]) {\n\t        this._frames[currentNum].style.opacity = 1;\n\t      }\n\t      // set previous frame as current\n\t      this._prevFrame = this._frames[proc];\n\t    }\n\t    if (this._props.onUpdate) {\n\t      this._props.onUpdate(p);\n\t    }\n\t  };\n\n\t  return Spriter;\n\t}();\n\n\texports.default = Spriter;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tweener = __webpack_require__(10);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _easing = __webpack_require__(22);\n\n\tvar _easing2 = _interopRequireDefault(_easing);\n\n\tvar _module = __webpack_require__(16);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t// import h from '../h';\n\n\tvar Tween = function (_Module) {\n\t  (0, _inherits3.default)(Tween, _Module);\n\n\t  /*\n\t    Method do declare defaults with this._defaults object.\n\t    @private\n\t  */\n\n\t  Tween.prototype._declareDefaults = function _declareDefaults() {\n\t    // DEFAULTS\n\t    this._defaults = {\n\t      /* duration of the tween [0..∞] */\n\t      duration: 350,\n\t      /* delay of the tween [-∞..∞] */\n\t      delay: 0,\n\t      /* repeat of the tween [0..∞], means how much to\n\t         repeat the tween regardless first run,\n\t         for instance repeat: 2 will make the tween run 3 times */\n\t      repeat: 0,\n\t      /* speed of playback [0..∞], speed that is less then 1\n\t         will slowdown playback, for instance .5 will make tween\n\t         run 2x slower. Speed of 2 will speedup the tween to 2x. */\n\t      speed: 1,\n\t      /*  flip onUpdate's progress on each even period.\n\t          note that callbacks order won't flip at least\n\t          for now (under consideration). */\n\t      isYoyo: false,\n\t      /* easing for the tween, could be any easing type [link to easing-types.md] */\n\t      easing: 'Sin.Out',\n\t      /*\n\t        Easing for backward direction of the tweenthe tween,\n\t        if `null` - fallbacks to `easing` property.\n\t        forward direction in `yoyo` period is treated as backward for the easing.\n\t      */\n\t      backwardEasing: null,\n\t      /* custom tween's name */\n\t      name: null,\n\t      /* custom tween's base name */\n\t      nameBase: 'Tween',\n\t      /*\n\t        onProgress callback runs before any other callback.\n\t        @param {Number}   The entire, not eased, progress\n\t                          of the tween regarding repeat option.\n\t        @param {Boolean}  The direction of the tween.\n\t                          `true` for forward direction.\n\t                          `false` for backward direction(tween runs in reverse).\n\t      */\n\t      onProgress: null,\n\t      /*\n\t        onStart callback runs on very start of the tween just after onProgress\n\t        one. Runs on very end of the tween if tween is reversed.\n\t        @param {Boolean}  Direction of the tween.\n\t                          `true` for forward direction.\n\t                          `false` for backward direction(tween runs in reverse).\n\t      */\n\t      onStart: null,\n\t      onRefresh: null,\n\t      onComplete: null,\n\t      onRepeatStart: null,\n\t      onRepeatComplete: null,\n\t      onFirstUpdate: null,\n\t      onUpdate: null,\n\t      isChained: false,\n\t      // playback callbacks\n\t      onPlaybackStart: null,\n\t      onPlaybackPause: null,\n\t      onPlaybackStop: null,\n\t      onPlaybackComplete: null,\n\t      // context which all callbacks will be called with\n\t      callbacksContext: null\n\t    };\n\t  };\n\t  /*\n\t    API method to play the Tween.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.play = function play() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    if (this._state === 'play' && this._isRunning) {\n\t      return this;\n\t    }\n\t    this._props.isReversed = false;\n\t    this._subPlay(shift, 'play');\n\t    this._setPlaybackState('play');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to play the Tween in reverse.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.playBackward = function playBackward() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    if (this._state === 'reverse' && this._isRunning) {\n\t      return this;\n\t    }\n\t    this._props.isReversed = true;\n\t    this._subPlay(shift, 'reverse');\n\t    this._setPlaybackState('reverse');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to pause Tween.\n\t    @public\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.pause = function pause() {\n\t    if (this._state === 'pause' || this._state === 'stop') {\n\t      return this;\n\t    }\n\t    this._removeFromTweener();\n\t    this._setPlaybackState('pause');\n\t    return this;\n\t  };\n\t  /*\n\t    API method to stop the Tween.\n\t    @public\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.stop = function stop(progress) {\n\t    if (this._state === 'stop') {\n\t      return this;\n\t    }\n\n\t    this._wasUknownUpdate = undefined;\n\n\t    var stopProc = progress != null ? progress\n\t    /* if no progress passsed - set 1 if tween\n\t       is playingBackward, otherwise set to 0 */\n\t    : this._state === 'reverse' ? 1 : 0;\n\n\t    this.setProgress(stopProc);\n\n\t    this.reset();\n\t    return this;\n\t  };\n\t  /*\n\t    API method to replay(restart) the Tween.\n\t    @public\n\t    @param   {Number} Shift time in milliseconds.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.replay = function replay() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    this.reset();\n\t    this.play(shift);\n\t    return this;\n\t  };\n\t  /*\n\t    API method to replay(restart) backward the Tween.\n\t    @public\n\t    @param   {Number} Shift time in milliseconds.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.replayBackward = function replayBackward() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    this.reset();\n\t    this.playBackward(shift);\n\t    return this;\n\t  };\n\t  /*\n\t    API method to resume the Tween.\n\t    @public\n\t    @param  {Number} Shift time in milliseconds.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.resume = function resume() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    if (this._state !== 'pause') {\n\t      return this;\n\t    }\n\n\t    switch (this._prevState) {\n\t      case 'play':\n\t        this.play(shift);\n\t        break;\n\t      case 'reverse':\n\t        this.playBackward(shift);\n\t        break;\n\t    }\n\n\t    return this;\n\t  };\n\t  /*\n\t    API method to set progress on tween.\n\t    @public\n\t    @param {Number} Progress to set.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype.setProgress = function setProgress(progress) {\n\t    var p = this._props;\n\t    // set start time if there is no one yet.\n\t    !p.startTime && this._setStartTime();\n\t    // reset play time\n\t    this._playTime = null;\n\t    // progress should be in range of [0..1]\n\t    progress < 0 && (progress = 0);\n\t    progress > 1 && (progress = 1);\n\t    // update self with calculated time\n\t    this._update(p.startTime - p.delay + progress * p.repeatTime);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set tween's speed.\n\t    @public\n\t    @param {Number} Speed value.\n\t    @returns this.\n\t  */\n\n\n\t  Tween.prototype.setSpeed = function setSpeed(speed) {\n\t    this._props.speed = speed;\n\t    // if playing - normalize _startTime and _prevTime to the current point.\n\t    if (this._state === 'play' || this._state === 'reverse') {\n\t      this._setResumeTime(this._state);\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to reset tween's state and properties.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tween.prototype.reset = function reset() {\n\t    this._removeFromTweener();\n\t    this._setPlaybackState('stop');\n\t    this._progressTime = 0;\n\t    this._isCompleted = false;\n\t    this._isStarted = false;\n\t    this._isFirstUpdate = false;\n\t    this._wasUknownUpdate = undefined;\n\t    this._prevTime = undefined;\n\t    this._prevYoyo = undefined;\n\t    // this._props.startTime  = undefined;\n\t    this._props.isReversed = false;\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to launch play. Used as launch\n\t    method for bothplay and reverse methods.\n\t    @private\n\t    @param  {Number} Shift time in milliseconds.\n\t    @param  {String} Play or reverse state.\n\t    @return {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._subPlay = function _subPlay() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\t    var state = arguments[1];\n\n\t    var resumeTime,\n\t        startTime,\n\t        p = this._props,\n\n\t    // check if direction of playback changes,\n\t    // if so, the _progressTime needs to be flipped\n\t    _state = this._state,\n\t        _prevState = this._prevState,\n\t        isPause = _state === 'pause',\n\t        wasPlay = _state === 'play' || isPause && _prevState === 'play',\n\t        wasReverse = _state === 'reverse' || isPause && _prevState === 'reverse',\n\t        isFlip = wasPlay && state === 'reverse' || wasReverse && state === 'play';\n\n\t    // if tween was ended, set progress to 0 if not, set to elapsed progress\n\t    this._progressTime = this._progressTime >= p.repeatTime ? 0 : this._progressTime;\n\t    // flip the _progressTime if playback direction changed\n\t    if (isFlip) {\n\t      this._progressTime = p.repeatTime - this._progressTime;\n\t    }\n\t    // set resume time and normalize prev/start times\n\t    this._setResumeTime(state, shift);\n\t    // add self to tweener = play\n\t    _tweener2.default.add(this);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set _resumeTime, _startTime and _prevTime.\n\t    @private\n\t    @param {String} Current state. [play, reverse]\n\t    @param {Number} Time shift. *Default* is 0.\n\t  */\n\n\n\t  Tween.prototype._setResumeTime = function _setResumeTime(state) {\n\t    var shift = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n\t    // get current moment as resume time\n\t    this._resumeTime = performance.now();\n\t    // set start time regarding passed `shift` and `procTime`\n\t    var startTime = this._resumeTime - Math.abs(shift) - this._progressTime;\n\t    this._setStartTime(startTime, false);\n\t    // if we have prevTime - we need to normalize\n\t    // it for the current resume time\n\t    if (this._prevTime != null) {\n\t      this._prevTime = state === 'play' ? this._normPrevTimeForward() : this._props.endTime - this._progressTime;\n\t    }\n\t  };\n\t  /*\n\t    Method recalculate _prevTime for forward direction.\n\t    @private\n\t    @return {Number} Normalized prev time.\n\t  */\n\n\n\t  Tween.prototype._normPrevTimeForward = function _normPrevTimeForward() {\n\t    var p = this._props;\n\t    return p.startTime + this._progressTime - p.delay;\n\t  };\n\t  /*\n\t    Constructor of the class.\n\t    @private\n\t  */\n\n\n\t  function Tween() {\n\t    var _ret;\n\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Tween);\n\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));\n\n\t    _this._props.name == null && _this._setSelfName();\n\t    return _ret = _this, (0, _possibleConstructorReturn3.default)(_this, _ret);\n\t  }\n\t  /*\n\t    Method to set self name to generic one.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._setSelfName = function _setSelfName() {\n\t    var globalName = '_' + this._props.nameBase + 's';\n\t    // track amount of tweens globally\n\t    _tweener2.default[globalName] = _tweener2.default[globalName] == null ? 1 : ++_tweener2.default[globalName];\n\t    // and set generic tween's name  || Tween # ||\n\t    this._props.name = this._props.nameBase + ' ' + _tweener2.default[globalName];\n\t  };\n\t  /*\n\t    Method set playback state string.\n\t    @private\n\t    @param {String} State name\n\t  */\n\n\n\t  Tween.prototype._setPlaybackState = function _setPlaybackState(state) {\n\t    // save previous state\n\t    this._prevState = this._state;\n\t    this._state = state;\n\n\t    // callbacks\n\t    var wasPause = this._prevState === 'pause',\n\t        wasStop = this._prevState === 'stop',\n\t        wasPlay = this._prevState === 'play',\n\t        wasReverse = this._prevState === 'reverse',\n\t        wasPlaying = wasPlay || wasReverse,\n\t        wasStill = wasStop || wasPause;\n\n\t    if ((state === 'play' || state === 'reverse') && wasStill) {\n\t      this._playbackStart();\n\t    }\n\t    if (state === 'pause' && wasPlaying) {\n\t      this._playbackPause();\n\t    }\n\t    if (state === 'stop' && (wasPlaying || wasPause)) {\n\t      this._playbackStop();\n\t    }\n\t  };\n\t  /*\n\t    Method to declare some vars.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._vars = function _vars() {\n\t    this.progress = 0;\n\t    this._prevTime = undefined;\n\t    this._progressTime = 0;\n\t    this._negativeShift = 0;\n\t    this._state = 'stop';\n\t    // if negative delay was specified,\n\t    // save it to _negativeShift property and\n\t    // reset it back to 0\n\t    if (this._props.delay < 0) {\n\t      this._negativeShift = this._props.delay;\n\t      this._props.delay = 0;\n\t    }\n\n\t    return this._calcDimentions();\n\t  };\n\t  /*\n\t    Method to calculate tween's dimentions.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._calcDimentions = function _calcDimentions() {\n\t    this._props.time = this._props.duration + this._props.delay;\n\t    this._props.repeatTime = this._props.time * (this._props.repeat + 1);\n\t  };\n\t  /*\n\t    Method to extend defaults by options and put them in _props.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._extendDefaults = function _extendDefaults() {\n\t    // save callback overrides object with fallback to empty one\n\t    this._callbackOverrides = this._o.callbackOverrides || {};\n\t    delete this._o.callbackOverrides;\n\t    // call the _extendDefaults @ Module\n\t    _Module.prototype._extendDefaults.call(this);\n\n\t    var p = this._props;\n\t    p.easing = _easing2.default.parseEasing(p.easing);\n\t    p.easing._parent = this;\n\n\t    // parse only present backward easing to prevent parsing as `linear.none`\n\t    // because we need to fallback to `easing` in `_setProgress` method\n\t    if (p.backwardEasing != null) {\n\t      p.backwardEasing = _easing2.default.parseEasing(p.backwardEasing);\n\t      p.backwardEasing._parent = this;\n\t    }\n\t  };\n\t  /*\n\t    Method for setting start and end time to props.\n\t    @private\n\t    @param {Number(Timestamp)}, {Null} Start time.\n\t    @param {Boolean} Should reset flags.\n\t    @returns this\n\t  */\n\n\n\t  Tween.prototype._setStartTime = function _setStartTime(time) {\n\t    var isResetFlags = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n\t    var p = this._props,\n\t        shiftTime = p.shiftTime || 0;\n\t    // reset flags\n\t    if (isResetFlags) {\n\t      this._isCompleted = false;this._isRepeatCompleted = false;\n\t      this._isStarted = false;\n\t    }\n\t    // set start time to passed time or to the current moment\n\t    var startTime = time == null ? performance.now() : time;\n\t    // calculate bounds\n\t    // - negativeShift is negative delay in options hash\n\t    // - shift time is shift of the parent\n\t    p.startTime = startTime + p.delay + this._negativeShift + shiftTime;\n\t    p.endTime = p.startTime + p.repeatTime - p.delay;\n\t    // set play time to the startTimes\n\t    // if playback controls are used - use _resumeTime as play time,\n\t    // else use shifted startTime -- shift is needed for timelines append chains\n\t    this._playTime = this._resumeTime != null ? this._resumeTime : startTime + shiftTime;\n\t    this._resumeTime = null;\n\n\t    return this;\n\t  };\n\t  /*\n\t    Method to update tween's progress.\n\t    @private\n\t    @param {Number} Current update time.\n\t    -- next params only present when parent Timeline calls the method.\n\t    @param {Number} Previous Timeline's update time.\n\t    @param {Boolean} Was parent in yoyo period.\n\t    @param {Number} [-1, 0, 1] If update is on edge.\n\t                   -1 = edge jump in negative direction.\n\t                    0 = no edge jump.\n\t                    1 = edge jump in positive direction.\n\t  */\n\n\n\t  Tween.prototype._update = function _update(time, timelinePrevTime, wasYoyo, onEdge) {\n\t    var p = this._props;\n\t    // if we don't the _prevTime thus the direction we are heading to,\n\t    // but prevTime was passed thus we are child of a Timeline\n\t    // set _prevTime to passed one and pretent that there was unknown\n\t    // update to not to block start/complete callbacks\n\t    if (this._prevTime == null && timelinePrevTime != null) {\n\n\t      if (this._props.speed && this._playTime) {\n\t        // play point + ( speed * delta )\n\t        this._prevTime = this._playTime + this._props.speed * (timelinePrevTime - this._playTime);\n\t      }\n\t      // this._prevTime = timelinePrevTime;\n\t      this._wasUknownUpdate = true;\n\t    }\n\n\t    // var before = time;\n\t    // cache vars\n\t    var startPoint = p.startTime - p.delay;\n\t    // if speed param was defined - calculate\n\t    // new time regarding speed\n\t    if (p.speed && this._playTime) {\n\t      // play point + ( speed * delta )\n\t      time = this._playTime + p.speed * (time - this._playTime);\n\t    }\n\n\t    // due to javascript precision issues, after speed mapping\n\t    // we can get very close number that was made from progress of 1\n\t    // and in fact represents `endTime` if so, set the time to `endTime`\n\t    if (Math.abs(p.endTime - time) < 0.00000001) {\n\t      time = p.endTime;\n\t    }\n\n\t    // if parent is onEdge but not very start nor very end\n\t    if (onEdge && wasYoyo != null) {\n\t      var T = this._getPeriod(time),\n\t          isYoyo = !!(p.isYoyo && this._props.repeat && T % 2 === 1);\n\n\t      // for timeline\n\t      // notify children about edge jump\n\t      if (this._timelines) {\n\t        for (var i = 0; i < this._timelines.length; i++) {\n\t          this._timelines[i]._update(time, timelinePrevTime, wasYoyo, onEdge);\n\t        }\n\t      }\n\t      // forward edge direction\n\t      if (onEdge === 1) {\n\t        // jumped from yoyo period?\n\t        if (wasYoyo) {\n\t          this._prevTime = time + 1;\n\t          this._repeatStart(time, isYoyo);\n\t          this._start(time, isYoyo);\n\t        } else {\n\t          this._prevTime = time - 1;\n\t          this._repeatComplete(time, isYoyo);\n\t          this._complete(time, isYoyo);\n\t        }\n\t        // backward edge direction\n\t      } else if (onEdge === -1) {\n\t          // jumped from yoyo period?\n\t          if (wasYoyo) {\n\t            this._prevTime = time - 1;\n\t            this._repeatComplete(time, isYoyo);\n\t            this._complete(time, isYoyo);\n\t          } else {\n\t            // call _start callbacks only if prev time was in active area\n\t            // not always true for append chains\n\t            if (this._prevTime >= p.startTime && this._prevTime <= p.endTime) {\n\t              this._prevTime = time + 1;\n\t              this._repeatStart(time, isYoyo);\n\t              this._start(time, isYoyo);\n\t              // reset isCOmpleted immediately to prevent onComplete cb\n\t              this._isCompleted = true;\n\t            }\n\t          }\n\t        }\n\t      // reset the _prevTime - drop one frame to undestand\n\t      // where we are heading\n\t      this._prevTime = undefined;\n\t    }\n\t    // if in active area and not ended - save progress time\n\t    // for pause/play purposes.\n\t    if (time > startPoint && time < p.endTime) {\n\t      this._progressTime = time - startPoint;\n\t    }\n\t    // else if not started or ended set progress time to 0\n\t    else if (time <= startPoint) {\n\t        this._progressTime = 0;\n\t      } else if (time >= p.endTime) {\n\t        // set progress time to repeat time + tiny cofficient\n\t        // to make it extend further than the end time\n\t        this._progressTime = p.repeatTime + .00000000001;\n\t      }\n\t    // reverse time if _props.isReversed is set\n\t    if (p.isReversed) {\n\t      time = p.endTime - this._progressTime;\n\t    }\n\t    // We need to know what direction we are heading to,\n\t    // so if we don't have the previous update value - this is very first\n\t    // update, - skip it entirely and wait for the next value\n\t    if (this._prevTime == null) {\n\t      this._prevTime = time;\n\t      this._wasUknownUpdate = true;\n\t      return false;\n\t    }\n\n\t    // ====== AFTER SKIPPED FRAME ======\n\n\t    // handle onProgress callback\n\t    if (time >= startPoint && time <= p.endTime) {\n\t      this._progress((time - startPoint) / p.repeatTime, time);\n\t    }\n\t    /*\n\t      if time is inside the active area of the tween.\n\t      active area is the area from start time to end time,\n\t      with all the repeat and delays in it\n\t    */\n\t    if (time >= p.startTime && time <= p.endTime) {\n\t      this._updateInActiveArea(time);\n\t    } else {\n\t      // if was in active area - update in inactive area but just once -\n\t      // right after the active area\n\t      if (this._isInActiveArea) {\n\t        this._updateInInactiveArea(time);\n\t      } else if (!this._isRefreshed) {\n\t        // onRefresh callback\n\t        // before startTime\n\t        if (time < p.startTime && this.progress !== 0) {\n\t          this._refresh(true);\n\t          this._isRefreshed = true;\n\t          // after endTime\n\t        }\n\t        // else if ( time > p.endTime ) { }\n\t      }\n\t    }\n\n\t    this._prevTime = time;\n\t    return time >= p.endTime || time <= startPoint;\n\t  };\n\t  /*\n\t    Method to handle tween's progress in inactive area.\n\t    @private\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Tween.prototype._updateInInactiveArea = function _updateInInactiveArea(time) {\n\t    if (!this._isInActiveArea) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    // complete if time is larger then end time\n\t    if (time > p.endTime && !this._isCompleted) {\n\t      this._progress(1, time);\n\t      // get period number\n\t      var T = this._getPeriod(p.endTime),\n\t          isYoyo = p.isYoyo && T % 2 === 0;\n\n\t      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);\n\t      this._repeatComplete(time, isYoyo);\n\t      this._complete(time, isYoyo);\n\t    }\n\t    // if was active and went to - inactive area \"-\"\n\t    if (time < this._prevTime && time < p.startTime && !this._isStarted && !this._isCompleted) {\n\t      // if was in active area and didn't fire onStart callback\n\t      this._progress(0, time, false);\n\t      this._setProgress(0, time, false);\n\t      this._isRepeatStart = false;\n\t      this._repeatStart(time, false);\n\t      this._start(time, false);\n\t    }\n\t    this._isInActiveArea = false;\n\t  };\n\t  /*\n\t    Method to handle tween's progress in active area.\n\t    @private\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Tween.prototype._updateInActiveArea = function _updateInActiveArea(time) {\n\n\t    var props = this._props,\n\t        delayDuration = props.delay + props.duration,\n\t        startPoint = props.startTime - props.delay,\n\t        elapsed = (time - props.startTime + props.delay) % delayDuration,\n\t        TCount = Math.round((props.endTime - props.startTime + props.delay) / delayDuration),\n\t        T = this._getPeriod(time),\n\t        TValue = this._delayT,\n\t        prevT = this._getPeriod(this._prevTime),\n\t        TPrevValue = this._delayT;\n\n\t    // \"zero\" and \"one\" value regarding yoyo and it's period\n\t    var isYoyo = props.isYoyo && T % 2 === 1,\n\t        isYoyoPrev = props.isYoyo && prevT % 2 === 1,\n\t        yoyoZero = isYoyo ? 1 : 0,\n\t        yoyoOne = 1 - yoyoZero;\n\n\t    if (time === props.endTime) {\n\t      this._wasUknownUpdate = false;\n\t      // if `time` is equal to `endTime`, T represents the next period,\n\t      // so we need to decrement T and calculate \"one\" value regarding yoyo\n\t      var isYoyo = props.isYoyo && (T - 1) % 2 === 1;\n\t      this._setProgress(isYoyo ? 0 : 1, time, isYoyo);\n\t      if (time > this._prevTime) {\n\t        this._isRepeatCompleted = false;\n\t      }\n\t      this._repeatComplete(time, isYoyo);\n\t      return this._complete(time, isYoyo);\n\t    }\n\n\t    // reset callback flags\n\t    this._isCompleted = false;\n\t    this._isRefreshed = false;\n\t    // if time is inside the duration area of the tween\n\t    if (startPoint + elapsed >= props.startTime) {\n\t      this._isInActiveArea = true;this._isRepeatCompleted = false;\n\t      this._isRepeatStart = false;this._isStarted = false;\n\t      // active zone or larger then end\n\t      var elapsed2 = (time - props.startTime) % delayDuration,\n\t          proc = elapsed2 / props.duration;\n\t      // |=====|=====|=====| >>>\n\t      //      ^1^2\n\t      var isOnEdge = T > 0 && prevT < T;\n\t      // |=====|=====|=====| <<<\n\t      //      ^2^1\n\t      var isOnReverseEdge = prevT > T;\n\n\t      // for use in timeline\n\t      this._onEdge = 0;\n\t      isOnEdge && (this._onEdge = 1);\n\t      isOnReverseEdge && (this._onEdge = -1);\n\n\t      if (this._wasUknownUpdate) {\n\t        if (time > this._prevTime) {\n\t          this._start(time, isYoyo);\n\t          this._repeatStart(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t        }\n\t        // if backward direction and\n\t        // if ( time < this._prevTime && time !== this._props.startTime ) {\n\t        if (time < this._prevTime) {\n\t          this._complete(time, isYoyo);\n\t          this._repeatComplete(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t          // reset isCompleted immediately\n\t          this._isCompleted = false;\n\t        }\n\t      }\n\n\t      if (isOnEdge) {\n\t        // if not just after delay\n\t        // |---=====|---=====|---=====| >>>\n\t        //            ^1 ^2\n\t        // because we have already handled\n\t        // 1 and onRepeatComplete in delay gap\n\t        if (this.progress !== 1) {\n\t          // prevT\n\t          var isThisYoyo = props.isYoyo && (T - 1) % 2 === 1;\n\t          this._repeatComplete(time, isThisYoyo);\n\t        }\n\t        // if on edge but not at very start\n\t        // |=====|=====|=====| >>>\n\t        // ^!    ^here ^here\n\t        if (prevT >= 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      if (time > this._prevTime) {\n\t        //  |=====|=====|=====| >>>\n\t        // ^1  ^2\n\t        if (!this._isStarted && this._prevTime <= props.startTime) {\n\t          this._start(time, isYoyo);\n\t          this._repeatStart(time, isYoyo);\n\t          // it was zero anyways\n\n\t          // restart flags immediately in case if we will\n\t          // return to '-' inactive area on the next step\n\t          this._isStarted = false;\n\t          this._isRepeatStart = false;\n\t        }\n\t        this._firstUpdate(time, isYoyo);\n\t      }\n\n\t      if (isOnReverseEdge) {\n\t        // if on edge but not at very end\n\t        // |=====|=====|=====| <<<\n\t        //       ^here ^here ^not here\n\t        if (this.progress !== 0 && this.progress !== 1 && prevT != TCount) {\n\t          this._repeatStart(time, isYoyoPrev);\n\t        }\n\t        // if on very end edge\n\t        // |=====|=====|=====| <<<\n\t        //       ^!    ^! ^2 ^1\n\t        // we have handled the case in this._wasUknownUpdate\n\t        // block so filter that\n\t        if (prevT === TCount && !this._wasUknownUpdate) {\n\t          this._complete(time, isYoyo);\n\t          this._repeatComplete(time, isYoyo);\n\t          this._firstUpdate(time, isYoyo);\n\t          // reset isComplete flag call\n\t          // cuz we returned to active area\n\t          // this._isRepeatCompleted = false;\n\t          this._isCompleted = false;\n\t        }\n\t        this._repeatComplete(time, isYoyo);\n\t      }\n\n\t      if (prevT === 'delay') {\n\t        // if just before delay gap\n\t        // |---=====|---=====|---=====| <<<\n\t        //               ^2    ^1\n\t        if (T < TPrevValue) {\n\t          this._repeatComplete(time, isYoyo);\n\t        }\n\t        // if just after delay gap\n\t        // |---=====|---=====|---=====| >>>\n\t        //            ^1  ^2\n\t        if (T === TPrevValue && T > 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      // swap progress and repeatStart based on direction\n\t      if (time > this._prevTime) {\n\t        // if progress is equal 0 and progress grows\n\t        if (proc === 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t        if (time !== props.endTime) {\n\t          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);\n\t        }\n\t      } else {\n\t        if (time !== props.endTime) {\n\t          this._setProgress(isYoyo ? 1 - proc : proc, time, isYoyo);\n\t        }\n\t        // if progress is equal 0 and progress grows\n\t        if (proc === 0) {\n\t          this._repeatStart(time, isYoyo);\n\t        }\n\t      }\n\n\t      if (time === props.startTime) {\n\t        this._start(time, isYoyo);\n\t      }\n\t      // delay gap - react only once\n\t    } else if (this._isInActiveArea) {\n\t        // because T will be string of \"delay\" here,\n\t        // let's normalize it be setting to TValue\n\t        var t = T === 'delay' ? TValue : T,\n\t            isGrows = time > this._prevTime;\n\t        // decrement period if forward direction of update\n\t        isGrows && t--;\n\t        // calculate normalized yoyoZero value\n\t        yoyoZero = props.isYoyo && t % 2 === 1 ? 1 : 0;\n\t        // if was in active area and previous time was larger\n\t        // |---=====|---=====|---=====| <<<\n\t        //   ^2 ^1    ^2 ^1    ^2 ^1\n\t        if (time < this._prevTime) {\n\t          this._setProgress(yoyoZero, time, yoyoZero === 1);\n\t          this._repeatStart(time, yoyoZero === 1);\n\t        }\n\t        // set 1 or 0 regarding direction and yoyo\n\t        this._setProgress(isGrows ? 1 - yoyoZero : yoyoZero, time, yoyoZero === 1);\n\t        // if time grows\n\t        if (time > this._prevTime) {\n\t          // if reverse direction and in delay gap, then progress will be 0\n\t          // if so we don't need to call the onRepeatComplete callback\n\t          // |---=====|---=====|---=====| <<<\n\t          //   ^0       ^0       ^0  \n\t          // OR we have flipped 0 to 1 regarding yoyo option\n\t          if (this.progress !== 0 || yoyoZero === 1) {\n\t            // since we repeatComplete for previous period\n\t            // invert isYoyo option\n\t            // is elapsed is 0 - count as previous period\n\t            this._repeatComplete(time, yoyoZero === 1);\n\t          }\n\t        }\n\t        // set flag to indicate inactive area\n\t        this._isInActiveArea = false;\n\t      }\n\t    // we've got the first update now\n\t    this._wasUknownUpdate = false;\n\t  };\n\t  /*\n\t    Method to remove the Tween from the tweener.\n\t    @private\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._removeFromTweener = function _removeFromTweener() {\n\t    _tweener2.default.remove(this);return this;\n\t  };\n\t  /*\n\t    Method to get current period number.\n\t    @private\n\t    @param {Number} Time to get the period for.\n\t    @returns {Number} Current period number.\n\t  */\n\n\n\t  Tween.prototype._getPeriod = function _getPeriod(time) {\n\t    var p = this._props,\n\t        TTime = p.delay + p.duration,\n\t        dTime = p.delay + time - p.startTime,\n\t        T = dTime / TTime,\n\n\t    // if time if equal to endTime we need to set the elapsed\n\t    // time to 0 to fix the occasional precision js bug, which\n\t    // causes 0 to be something like 1e-12\n\t    elapsed = time < p.endTime ? dTime % TTime : 0;\n\t    // If the latest period, round the result, otherwise floor it.\n\t    // Basically we always can floor the result, but because of js\n\t    // precision issues, sometimes the result is 2.99999998 which\n\t    // will result in 2 instead of 3 after the floor operation.\n\t    T = time >= p.endTime ? Math.round(T) : Math.floor(T);\n\t    // if time is larger then the end time\n\t    if (time > p.endTime) {\n\t      // set equal to the periods count\n\t      T = Math.round((p.endTime - p.startTime + p.delay) / TTime);\n\t      // if in delay gap, set _delayT to current\n\t      // period number and return \"delay\"\n\t    } else if (elapsed > 0 && elapsed < p.delay) {\n\t        this._delayT = T;T = 'delay';\n\t      }\n\t    // if the end of period and there is a delay\n\t    return T;\n\t  };\n\t  /*\n\t    Method to set Tween's progress and call onUpdate callback.\n\t    @private\n\t    @override @ Module\n\t    @param {Number} Progress to set.\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo perido. Used in Timeline to pass to Tween.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Tween.prototype._setProgress = function _setProgress(proc, time, isYoyo) {\n\t    var p = this._props,\n\t        isYoyoChanged = p.wasYoyo !== isYoyo,\n\t        isForward = time > this._prevTime;\n\n\t    this.progress = proc;\n\t    // get the current easing for `forward` direction regarding `yoyo`\n\t    if (isForward && !isYoyo || !isForward && isYoyo) {\n\t      this.easedProgress = p.easing(proc);\n\t      // get the current easing for `backward` direction regarding `yoyo`\n\t    } else if (!isForward && !isYoyo || isForward && isYoyo) {\n\t        var easing = p.backwardEasing != null ? p.backwardEasing : p.easing;\n\n\t        this.easedProgress = easing(proc);\n\t      }\n\n\t    if (p.prevEasedProgress !== this.easedProgress || isYoyoChanged) {\n\t      if (p.onUpdate != null && typeof p.onUpdate === 'function') {\n\t        p.onUpdate.call(p.callbacksContext || this, this.easedProgress, this.progress, isForward, isYoyo);\n\t      }\n\t    }\n\t    p.prevEasedProgress = this.easedProgress;\n\t    p.wasYoyo = isYoyo;\n\t    return this;\n\t  };\n\t  /*\n\t    Method to set tween's state to start and call onStart callback.\n\t    @method _start\n\t    @private\n\t    @param {Number} Progress to set.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._start = function _start(time, isYoyo) {\n\t    if (this._isStarted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onStart != null && typeof p.onStart === 'function') {\n\t      p.onStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isCompleted = false;this._isStarted = true;\n\t    this._isFirstUpdate = false;\n\t  };\n\t  /*\n\t    Method to call onPlaybackStart callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackStart = function _playbackStart() {\n\t    var p = this._props;\n\t    if (p.onPlaybackStart != null && typeof p.onPlaybackStart === 'function') {\n\t      p.onPlaybackStart.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackPause callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackPause = function _playbackPause() {\n\t    var p = this._props;\n\t    if (p.onPlaybackPause != null && typeof p.onPlaybackPause === 'function') {\n\t      p.onPlaybackPause.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackStop callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackStop = function _playbackStop() {\n\t    var p = this._props;\n\t    if (p.onPlaybackStop != null && typeof p.onPlaybackStop === 'function') {\n\t      p.onPlaybackStop.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to call onPlaybackComplete callback\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._playbackComplete = function _playbackComplete() {\n\t    var p = this._props;\n\t    if (p.onPlaybackComplete != null && typeof p.onPlaybackComplete === 'function') {\n\t      p.onPlaybackComplete.call(p.callbacksContext || this);\n\t    }\n\t  };\n\t  /*\n\t    Method to set tween's state to complete.\n\t    @method _complete\n\t    @private\n\t    @param {Number} Current time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._complete = function _complete(time, isYoyo) {\n\t    if (this._isCompleted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onComplete != null && typeof p.onComplete === 'function') {\n\t      p.onComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\n\t    this._isCompleted = true;this._isStarted = false;\n\t    this._isFirstUpdate = false;\n\t    // reset _prevYoyo for timeline usage\n\t    this._prevYoyo = undefined;\n\t  };\n\n\t  /*\n\t    Method to run onFirstUpdate callback.\n\t    @method _firstUpdate\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._firstUpdate = function _firstUpdate(time, isYoyo) {\n\t    if (this._isFirstUpdate) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onFirstUpdate != null && typeof p.onFirstUpdate === 'function') {\n\t      // onFirstUpdate should have tween pointer\n\t      p.onFirstUpdate.tween = this;\n\t      p.onFirstUpdate.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isFirstUpdate = true;\n\t  };\n\t  /*\n\t    Method call onRepeatComplete calback and set flags.\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is repeat period.\n\t  */\n\n\n\t  Tween.prototype._repeatComplete = function _repeatComplete(time, isYoyo) {\n\t    if (this._isRepeatCompleted) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onRepeatComplete != null && typeof p.onRepeatComplete === 'function') {\n\t      p.onRepeatComplete.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isRepeatCompleted = true;\n\t    // this._prevYoyo = null;\n\t  };\n\n\t  /*\n\t    Method call onRepeatStart calback and set flags.\n\t    @private\n\t    @param {Number} Current update time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\n\n\t  Tween.prototype._repeatStart = function _repeatStart(time, isYoyo) {\n\t    if (this._isRepeatStart) {\n\t      return;\n\t    }\n\t    var p = this._props;\n\t    if (p.onRepeatStart != null && typeof p.onRepeatStart === 'function') {\n\t      p.onRepeatStart.call(p.callbacksContext || this, time > this._prevTime, isYoyo);\n\t    }\n\t    this._isRepeatStart = true;\n\t  };\n\t  /*\n\t    Method to launch onProgress callback.\n\t    @method _progress\n\t    @private\n\t    @param {Number} Progress to set.\n\t  */\n\n\n\t  Tween.prototype._progress = function _progress(progress, time) {\n\t    var p = this._props;\n\t    if (p.onProgress != null && typeof p.onProgress === 'function') {\n\t      p.onProgress.call(p.callbacksContext || this, progress, time > this._prevTime);\n\t    }\n\t  };\n\t  /*\n\t    Method to launch onRefresh callback.\n\t    @method _refresh\n\t    @private\n\t    @param {Boolean} If refresh even before start time.\n\t  */\n\n\n\t  Tween.prototype._refresh = function _refresh(isBefore) {\n\t    var p = this._props;\n\t    if (p.onRefresh != null) {\n\t      var context = p.callbacksContext || this,\n\t          progress = isBefore ? 0 : 1;\n\n\t      p.onRefresh.call(context, isBefore, p.easing(progress), progress);\n\t    }\n\t  };\n\t  /*\n\t    Method which is called when the tween is removed from tweener.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._onTweenerRemove = function _onTweenerRemove() {};\n\t  /*\n\t    Method which is called when the tween is removed\n\t    from tweener when finished.\n\t    @private\n\t  */\n\n\n\t  Tween.prototype._onTweenerFinish = function _onTweenerFinish() {\n\t    this._setPlaybackState('stop');\n\t    this._playbackComplete();\n\t  };\n\t  /*\n\t    Method to set property[s] on Tween.\n\t    @private\n\t    @override @ Module\n\t    @param {Object, String} Hash object of key/value pairs, or property name.\n\t    @param {_} Property's value to set.\n\t  */\n\n\n\t  Tween.prototype._setProp = function _setProp(obj, value) {\n\t    _Module.prototype._setProp.call(this, obj, value);\n\t    this._calcDimentions();\n\t  };\n\t  /*\n\t    Method to set single property.\n\t    @private\n\t    @override @ Module\n\t    @param {String} Name of the property.\n\t    @param {Any} Value for the property.\n\t  */\n\n\n\t  Tween.prototype._assignProp = function _assignProp(key, value) {\n\t    // fallback to defaults\n\t    if (value == null) {\n\t      value = this._defaults[key];\n\t    }\n\t    // parse easing\n\t    if (key === 'easing') {\n\t      value = _easing2.default.parseEasing(value);\n\t      value._parent = this;\n\t    }\n\t    // handle control callbacks overrides\n\t    var control = this._callbackOverrides[key],\n\t        isntOverriden = !value || !value.isMojsCallbackOverride;\n\t    if (control && isntOverriden) {\n\t      value = this._overrideCallback(value, control);\n\t    }\n\t    // call super on Module\n\t    _Module.prototype._assignProp.call(this, key, value);\n\t  };\n\t  /*\n\t    Method to override callback for controll pupropes.\n\t    @private\n\t    @param {String}    Callback name.\n\t    @parma {Function}  Method to call  \n\t  */\n\n\n\t  Tween.prototype._overrideCallback = function _overrideCallback(callback, fun) {\n\t    var isCallback = callback && typeof callback === 'function',\n\t        override = function callbackOverride() {\n\t      // call overriden callback if it exists\n\t      isCallback && callback.apply(this, arguments);\n\t      // call the passed cleanup function\n\t      fun.apply(this, arguments);\n\t    };\n\t    // add overridden flag\n\t    override.isMojsCallbackOverride = true;\n\t    return override;\n\t  };\n\n\t  // _visualizeProgress(time) {\n\t  //   var str = '|',\n\t  //       procStr = ' ',\n\t  //       p = this._props,\n\t  //       proc = p.startTime - p.delay;\n\n\t  //   while ( proc < p.endTime ) {\n\t  //     if (p.delay > 0 ) {\n\t  //       var newProc = proc + p.delay;\n\t  //       if ( time > proc && time < newProc ) {\n\t  //         procStr += ' ^ ';\n\t  //       } else {\n\t  //         procStr += '   ';\n\t  //       }\n\t  //       proc = newProc;\n\t  //       str  += '---';\n\t  //     }\n\t  //     var newProc = proc + p.duration;\n\t  //     if ( time > proc && time < newProc ) {\n\t  //       procStr += '  ^   ';\n\t  //     } else if (time === proc) {\n\t  //       procStr += '^     ';\n\t  //     } else if (time === newProc) {\n\t  //       procStr += '    ^ ';\n\t  //     } else {\n\t  //       procStr += '      ';\n\t  //     }\n\t  //     proc = newProc;\n\t  //     str += '=====|';\n\t  //   }\n\n\t  //   console.log(str);\n\t  //   console.log(procStr);\n\t  // }\n\n\n\t  return Tween;\n\t}(_module2.default);\n\n\texports.default = Tween;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _getIterator2 = __webpack_require__(29);\n\n\tvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _tweener = __webpack_require__(10);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Timeline = function (_Tween) {\n\t  (0, _inherits3.default)(Timeline, _Tween);\n\n\t  /*\n\t    API method to add child tweens/timelines.\n\t    @public\n\t    @param {Object, Array} Tween/Timeline or an array of such.\n\t    @returns {Object} Self.\n\t  */\n\n\t  Timeline.prototype.add = function add() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    this._pushTimelineArray(args);\n\t    this._calcDimentions();\n\t    return this;\n\t  };\n\t  /*\n\t    API method to append the Tween/Timeline to the end of the\n\t    timeline. Each argument is treated as a new append.\n\t    Array of tweens is treated as a parallel sequence. \n\t    @public\n\t    @param {Object, Array} Tween/Timeline to append or array of such.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Timeline.prototype.append = function append() {\n\t    for (var _len2 = arguments.length, timeline = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      timeline[_key2] = arguments[_key2];\n\t    }\n\n\t    for (var _iterator = timeline, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n\t      var _ref;\n\n\t      if (_isArray) {\n\t        if (_i >= _iterator.length) break;\n\t        _ref = _iterator[_i++];\n\t      } else {\n\t        _i = _iterator.next();\n\t        if (_i.done) break;\n\t        _ref = _i.value;\n\t      }\n\n\t      var tm = _ref;\n\n\t      if (_h2.default.isArray(tm)) {\n\t        this._appendTimelineArray(tm);\n\t      } else {\n\t        this._appendTimeline(tm, this._timelines.length);\n\t      }\n\t      this._calcDimentions();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    API method to stop the Tween.\n\t    @public\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t    @returns {Object} Self.\n\t  */\n\n\n\t  Timeline.prototype.stop = function stop(progress) {\n\t    _Tween.prototype.stop.call(this, progress);\n\t    this._stopChildren(progress);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to reset tween's state and properties.\n\t    @public\n\t    @overrides @ Tween\n\t    @returns this.\n\t  */\n\n\n\t  Timeline.prototype.reset = function reset() {\n\t    _Tween.prototype.reset.call(this);\n\t    this._resetChildren();\n\t    return this;\n\t  };\n\t  /*\n\t    Method to call `reset` method on all children.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._resetChildren = function _resetChildren() {\n\t    for (var i = 0; i < this._timelines.length; i++) {\n\t      this._timelines[i].reset();\n\t    }\n\t  };\n\t  /*\n\t    Method to call `stop` method on all children.\n\t    @private\n\t    @param   {Number} Progress [0..1] to set when stopped.\n\t  */\n\n\n\t  Timeline.prototype._stopChildren = function _stopChildren(progress) {\n\t    for (var i = this._timelines.length - 1; i >= 0; i--) {\n\t      this._timelines[i].stop(progress);\n\t    }\n\t  };\n\t  /*\n\t    Method to set tween's state to complete.\n\t    @private\n\t    @overrides @ Tween\n\t    @param {Number} Current time.\n\t    @param {Boolean} Is yoyo period.\n\t  */\n\t  // _complete ( time, isYoyo ) {\n\t  //   // this._updateChildren( 1, time, isYoyo );\n\t  //   // this._setProgress( 1, time, isYoyo );\n\t  //   super._complete( time, isYoyo );\n\t  //   // this._resetChildren();\n\t  // }\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to append Tween/Timeline array or mix of such.\n\t    @private\n\t    @param {Array} Array of Tweens/Timelines.\n\t  */\n\n\n\t  Timeline.prototype._appendTimelineArray = function _appendTimelineArray(timelineArray) {\n\t    var i = timelineArray.length,\n\t        time = this._props.repeatTime - this._props.delay,\n\t        len = this._timelines.length;\n\n\t    while (i--) {\n\t      this._appendTimeline(timelineArray[i], len, time);\n\t    }\n\t  };\n\t  /*\n\t    Method to append a single timeline to the Timeline.\n\t    @private\n\t    @param {Object} Tween/Timline to append.\n\t    @param {Number} Index of the append.\n\t    @param {Number} Shift time.\n\t  */\n\n\n\t  Timeline.prototype._appendTimeline = function _appendTimeline(timeline, index, time) {\n\t    // if timeline is a module with timeline property then extract it\n\t    if (timeline.timeline instanceof Timeline) {\n\t      timeline = timeline.timeline;\n\t    }\n\t    if (timeline.tween instanceof _tween2.default) {\n\t      timeline = timeline.tween;\n\t    }\n\n\t    var shift = time != null ? time : this._props.duration;\n\t    shift += timeline._props.shiftTime || 0;\n\t    timeline.index = index;this._pushTimeline(timeline, shift);\n\t  };\n\t  /*\n\t    PrivateMethod to push Tween/Timeline array.\n\t    @private\n\t    @param {Array} Array of Tweens/Timelines.\n\t  */\n\n\n\t  Timeline.prototype._pushTimelineArray = function _pushTimelineArray(array) {\n\t    for (var i = 0; i < array.length; i++) {\n\t      var tm = array[i];\n\t      // recursive push to handle arrays of arrays\n\t      if (_h2.default.isArray(tm)) {\n\t        this._pushTimelineArray(tm);\n\t      } else {\n\t        this._pushTimeline(tm);\n\t      }\n\t    };\n\t  };\n\t  /*\n\t    Method to push a single Tween/Timeline.\n\t    @private\n\t    @param {Object} Tween or Timeline to push.\n\t    @param {Number} Number of milliseconds to shift the start time\n\t                    of the Tween/Timeline.\n\t  */\n\n\n\t  Timeline.prototype._pushTimeline = function _pushTimeline(timeline, shift) {\n\t    // if timeline is a module with timeline property then extract it\n\t    if (timeline.timeline instanceof Timeline) {\n\t      timeline = timeline.timeline;\n\t    }\n\t    if (timeline.tween instanceof _tween2.default) {\n\t      timeline = timeline.tween;\n\t    }\n\t    // add self delay to the timeline\n\t    shift != null && timeline._setProp({ 'shiftTime': shift });\n\t    this._timelines.push(timeline);\n\t    this._recalcDuration(timeline);\n\t  };\n\t  /*\n\t    Method set progress on self and child Tweens/Timelines.\n\t    @private\n\t    @param {Number} Progress to set.\n\t    @param {Number} Current update time.\n\t  */\n\n\n\t  Timeline.prototype._setProgress = function _setProgress(p, time, isYoyo) {\n\t    // we need to pass self previous time to children\n\t    // to prevent initial _wasUnknownUpdate nested waterfall\n\t    // if not yoyo option set, pass the previous time\n\t    // otherwise, pass previous or next time regarding yoyo period.\n\n\t    // COVER CURRENT SWAPPED ORDER\n\t    this._updateChildren(p, time, isYoyo);\n\n\t    _tween2.default.prototype._setProgress.call(this, p, time);\n\t  };\n\n\t  Timeline.prototype._updateChildren = function _updateChildren(p, time, isYoyo) {\n\t    var coef = time > this._prevTime ? -1 : 1;\n\t    if (this._props.isYoyo && isYoyo) {\n\t      coef *= -1;\n\t    }\n\t    var timeToTimelines = this._props.startTime + p * this._props.duration,\n\t        prevTimeToTimelines = timeToTimelines + coef,\n\t        len = this._timelines.length;\n\n\t    for (var i = 0; i < len; i++) {\n\t      // specify the children's array update loop direction\n\t      // if time > prevTime go from 0->length else from length->0\n\t      // var j = ( time > this._prevTime ) ? i : (len-1) - i ;\n\t      var j = timeToTimelines > prevTimeToTimelines ? i : len - 1 - i;\n\t      this._timelines[j]._update(timeToTimelines, prevTimeToTimelines, this._prevYoyo, this._onEdge);\n\t    }\n\t    this._prevYoyo = isYoyo;\n\t  };\n\t  /*\n\t    Method calculate self duration based on timeline's duration.\n\t    @private\n\t    @param {Object} Tween or Timeline to calculate.\n\t  */\n\n\n\t  Timeline.prototype._recalcDuration = function _recalcDuration(timeline) {\n\t    var p = timeline._props,\n\t        timelineTime = p.repeatTime / p.speed + (p.shiftTime || 0) + timeline._negativeShift;\n\n\t    this._props.duration = Math.max(timelineTime, this._props.duration);\n\t  };\n\t  /*\n\t    Method calculate self duration from skretch.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._recalcTotalDuration = function _recalcTotalDuration() {\n\t    var i = this._timelines.length;\n\t    this._props.duration = 0;\n\t    while (i--) {\n\t      var tm = this._timelines[i];\n\t      // recalc total duration on child timelines\n\t      tm._recalcTotalDuration && tm._recalcTotalDuration();\n\t      // add the timeline's duration to selft duration\n\t      this._recalcDuration(tm);\n\t    }\n\t    this._calcDimentions();\n\t  };\n\t  /*\n\t    Method set start and end times.\n\t    @private\n\t    @param {Number, Null} Time to start with.\n\t  */\n\n\n\t  Timeline.prototype._setStartTime = function _setStartTime(time) {\n\t    var isReset = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n\t    _Tween.prototype._setStartTime.call(this, time);\n\t    this._startTimelines(this._props.startTime, isReset);\n\t  };\n\t  /*\n\t    Method calculate self duration based on timeline's duration.\n\t    @private\n\t    @param {Number, Null} Time to start with.\n\t  */\n\n\n\t  Timeline.prototype._startTimelines = function _startTimelines(time) {\n\t    var isReset = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];\n\n\t    var p = this._props,\n\t        isStop = this._state === 'stop';\n\n\t    time == null && (time = this._props.startTime);\n\n\t    for (var i = 0; i < this._timelines.length; i++) {\n\t      var tm = this._timelines[i];\n\t      tm._setStartTime(time, isReset);\n\t      // if from `_subPlay` and `_prevTime` is set and state is `stop`\n\t      // prevTime normalizing is for play/pause functionality, so no\n\t      // need to normalize if the timeline is in `stop` state.\n\t      if (!isReset && tm._prevTime != null && !isStop) {\n\t        tm._prevTime = tm._normPrevTimeForward();\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to launch onRefresh callback.\n\t    @method _refresh\n\t    @private\n\t    @overrides @ Tween\n\t    @param {Boolean} If refresh even before start time.\n\t  */\n\n\n\t  Timeline.prototype._refresh = function _refresh(isBefore) {\n\t    var len = this._timelines.length;\n\t    for (var i = 0; i < len; i++) {\n\t      this._timelines[i]._refresh(isBefore);\n\t    }\n\t    _Tween.prototype._refresh.call(this, isBefore);\n\t  };\n\t  /*\n\t    Method do declare defaults by this._defaults object\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._declareDefaults = function _declareDefaults() {\n\t    // if duration was passed on initialization stage, warn user and reset it.\n\t    if (this._o.duration != null) {\n\t      _h2.default.error('Duration can not be declared on Timeline, but \"' + this._o.duration + '\" is. You probably want to use Tween instead.');\n\t      this._o.duration = 0;\n\t    }\n\t    _Tween.prototype._declareDefaults.call(this);\n\t    // remove default\n\t    this._defaults.duration = 0;\n\t    this._defaults.easing = 'Linear.None';\n\t    this._defaults.backwardEasing = 'Linear.None';\n\t    this._defaults.nameBase = 'Timeline';\n\t  };\n\n\t  function Timeline() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Timeline);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tween.call(this, o));\n\t  }\n\t  /*\n\t    Method to declare some vars.\n\t    @private\n\t  */\n\n\n\t  Timeline.prototype._vars = function _vars() {\n\t    this._timelines = [];\n\t    _Tween.prototype._vars.call(this);\n\t  };\n\n\t  return Timeline;\n\t}(_tween2.default);\n\n\texports.default = Timeline;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\t__webpack_require__(30);\n\n\t__webpack_require__(31);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Tweener = function () {\n\t  function Tweener() {\n\t    (0, _classCallCheck3.default)(this, Tweener);\n\n\t    this._vars();\n\t    this._listenVisibilityChange();\n\t    return this;\n\t  }\n\n\t  Tweener.prototype._vars = function _vars() {\n\t    this.tweens = [];\n\t    this._loop = this._loop.bind(this);\n\t    this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\t  };\n\t  /*\n\t    Main animation loop. Should have only one concurrent loop.\n\t    @private\n\t    @returns this\n\t  */\n\n\n\t  Tweener.prototype._loop = function _loop() {\n\t    if (!this._isRunning) {\n\t      return false;\n\t    }\n\t    this._update(window.performance.now());\n\t    if (!this.tweens.length) {\n\t      return this._isRunning = false;\n\t    }\n\t    requestAnimationFrame(this._loop);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to start animation loop.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._startLoop = function _startLoop() {\n\t    if (this._isRunning) {\n\t      return;\n\t    };this._isRunning = true;\n\t    requestAnimationFrame(this._loop);\n\t  };\n\t  /*\n\t    Method to stop animation loop.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._stopLoop = function _stopLoop() {\n\t    this._isRunning = false;\n\t  };\n\t  /*\n\t    Method to update every tween/timeline on animation frame.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._update = function _update(time) {\n\t    var i = this.tweens.length;\n\t    while (i--) {\n\t      // cache the current tween\n\t      var tween = this.tweens[i];\n\t      if (tween && tween._update(time) === true) {\n\t        this.remove(tween);\n\t        tween._onTweenerFinish();\n\t        tween._prevTime = undefined;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to add a Tween/Timeline to loop pool.\n\t    @param {Object} Tween/Timeline to add.\n\t  */\n\n\n\t  Tweener.prototype.add = function add(tween) {\n\t    // return if tween is already running\n\t    if (tween._isRunning) {\n\t      return;\n\t    }\n\t    tween._isRunning = true;\n\t    this.tweens.push(tween);\n\t    this._startLoop();\n\t  };\n\t  /*\n\t    Method stop updating all the child tweens/timelines.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype.removeAll = function removeAll() {\n\t    this.tweens.length = 0;\n\t  };\n\t  /*\n\t    Method to remove specific tween/timeline form updating.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype.remove = function remove(tween) {\n\t    var index = typeof tween === 'number' ? tween : this.tweens.indexOf(tween);\n\n\t    if (index !== -1) {\n\t      tween = this.tweens[index];\n\t      if (tween) {\n\t        tween._isRunning = false;\n\t        this.tweens.splice(index, 1);\n\t        tween._onTweenerRemove();\n\t      }\n\t    }\n\t  };\n\n\t  /*\n\t    Method to initialize event listeners to visibility change events.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._listenVisibilityChange = function _listenVisibilityChange() {\n\t    if (typeof document.hidden !== \"undefined\") {\n\t      this._visibilityHidden = \"hidden\";\n\t      this._visibilityChange = \"visibilitychange\";\n\t    } else if (typeof document.mozHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"mozHidden\";\n\t      this._visibilityChange = \"mozvisibilitychange\";\n\t    } else if (typeof document.msHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"msHidden\";\n\t      this._visibilityChange = \"msvisibilitychange\";\n\t    } else if (typeof document.webkitHidden !== \"undefined\") {\n\t      this._visibilityHidden = \"webkitHidden\";\n\t      this._visibilityChange = \"webkitvisibilitychange\";\n\t    }\n\n\t    document.addEventListener(this._visibilityChange, this._onVisibilityChange, false);\n\t  };\n\t  /*\n\t    Method that will fire on visibility change.\n\t  */\n\n\n\t  Tweener.prototype._onVisibilityChange = function _onVisibilityChange() {\n\t    if (document[this._visibilityHidden]) {\n\t      this._savePlayingTweens();\n\t    } else {\n\t      this._restorePlayingTweens();\n\t    }\n\t  };\n\t  /*\n\t    Method to save all playing tweens.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._savePlayingTweens = function _savePlayingTweens() {\n\t    this._savedTweens = this.tweens.slice(0);\n\t    for (var i = 0; i < this._savedTweens.length; i++) {\n\t      this._savedTweens[i].pause();\n\t    }\n\t  };\n\t  /*\n\t    Method to restore all playing tweens.\n\t    @private\n\t  */\n\n\n\t  Tweener.prototype._restorePlayingTweens = function _restorePlayingTweens() {\n\t    for (var i = 0; i < this._savedTweens.length; i++) {\n\t      this._savedTweens[i].resume();\n\t    }\n\t  };\n\n\t  return Tweener;\n\t}();\n\n\tvar t = new Tweener();\n\texports.default = t;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _module = __webpack_require__(16);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Class to define a module ancestor\n\t  with timeline and tween options and functionality.\n\t  All runable modules should inherit from this class.\n\n\t  @class Tweenable\n\t*/\n\n\tvar Tweenable = function (_Module) {\n\t  (0, _inherits3.default)(Tweenable, _Module);\n\n\t  /*\n\t    `play` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\n\t  Tweenable.prototype.play = function play() {\n\t    this.timeline.play.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `playBackward` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.playBackward = function playBackward() {\n\t    this.timeline.playBackward.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `pause` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.pause = function pause() {\n\t    this.timeline.pause.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `stop` method for the timeline.\n\t    @public\n\t    @param {Number} [0...1] Progress to set on stop.\n\t                            *Default* is `0` if `play`\n\t                            and `1` if `playBAckward`.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.stop = function stop() {\n\t    this.timeline.stop.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `reset` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.reset = function reset() {\n\t    this.timeline.reset.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `replay` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.replay = function replay() {\n\t    this.timeline.replay.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `replay` method for the timeline.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.replayBackward = function replayBackward() {\n\t    this.timeline.replayBackward.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `resume` method for the timeline.\n\t    @public\n\t    @param {Number} Time shift.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.resume = function resume() {\n\t    var shift = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n\t    this.timeline.resume.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    `setProgress` method for the timeline.\n\t    @public\n\t    @param {Number} [0...1] Progress value.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.setProgress = function setProgress() {\n\t    this.timeline.setProgress.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\t  /*\n\t    setSpeed method for the timeline.\n\t    @param {Number} Speed value.\n\t    @returns this.\n\t  */\n\n\n\t  Tweenable.prototype.setSpeed = function setSpeed(speed) {\n\t    this.timeline.setSpeed.apply(this.timeline, arguments);\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  function Tweenable() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Tweenable);\n\n\t    // pipe function for _o object\n\t    // before creating tween/timeline\n\n\t    var _this = (0, _possibleConstructorReturn3.default)(this, _Module.call(this, o));\n\t    // super of Module\n\n\n\t    _this._transformTweenOptions();\n\t    // make tween only if isTweenLess option is not set\n\t    !_this._o.isTweenLess && _this._makeTween();\n\t    // make timeline only if isTimelineLess option is not set\n\t    !_this._o.isTimelineLess && _this._makeTimeline();\n\t    return _this;\n\t  }\n\t  /*\n\t    Placeholder method that should be overrided\n\t    and will be called before tween/timeline creation.\n\t    @private\n\t  */\n\n\n\t  Tweenable.prototype._transformTweenOptions = function _transformTweenOptions() {};\n\t  /*\n\t    Method to create tween.\n\t    @private\n\t  */\n\n\n\t  Tweenable.prototype._makeTween = function _makeTween() {\n\t    // pass callbacks context\n\t    this._o.callbacksContext = this._o.callbacksContext || this;\n\t    this.tween = new _tween2.default(this._o);\n\t    // make timeline property point to tween one is \"no timeline\" mode\n\t    this._o.isTimelineLess && (this.timeline = this.tween);\n\t  };\n\t  /*\n\t    Method to create timeline.\n\t    @private\n\t    @param {Object} Timeline's options.\n\t                    An object which contains \"timeline\" property with\n\t                    timeline options.\n\t  */\n\n\n\t  Tweenable.prototype._makeTimeline = function _makeTimeline() {\n\t    // pass callbacks context\n\t    this._o.timeline = this._o.timeline || {};\n\t    this._o.timeline.callbacksContext = this._o.callbacksContext || this;\n\t    this.timeline = new _timeline2.default(this._o.timeline);\n\t    // set the flag to indicate that real timeline is present\n\t    this._isTimeline = true;\n\t    // if tween exist - add it to the timeline there is some\n\t    // modules like burst and stagger that have no tween\n\t    this.tween && this.timeline.add(this.tween);\n\t  };\n\n\t  return Tweenable;\n\t}(_module2.default);\n\n\texports.default = Tweenable;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _tweenable = __webpack_require__(11);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  The Thenable class adds .then public method and\n\t  the ability to chain API calls.\n\t*/\n\n\tvar Thenable = function (_Tweenable) {\n\t  (0, _inherits3.default)(Thenable, _Tweenable);\n\n\t  function Thenable() {\n\t    (0, _classCallCheck3.default)(this, Thenable);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Tweenable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to create a then record for the module.\n\t    @public\n\t    @param    {Object} Options for the next animation.\n\t    @returns  {Object} this.\n\t  */\n\n\t  Thenable.prototype.then = function then(o) {\n\t    // return if nothing was passed\n\t    if (o == null || !(0, _keys2.default)(o).length) {\n\t      return 1;\n\t    }\n\t    // merge then options with the current ones\n\t    var prevRecord = this._history[this._history.length - 1],\n\t        prevModule = this._modules[this._modules.length - 1],\n\t        merged = this._mergeThenOptions(prevRecord, o);\n\n\t    this._resetMergedFlags(merged);\n\t    // create a submodule of the same type as the master module\n\t    var module = new this.constructor(merged);\n\t    // set `this` as amster module of child module\n\t    module._masterModule = this;\n\t    // save the modules to the _modules array\n\t    this._modules.push(module);\n\t    // add module's tween into master timeline\n\t    this.timeline.append(module);\n\n\t    return this;\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to reset some flags on merged options object.\n\t    @private\n\t    @param   {Object} Options object.\n\t    @returns {Object} Options object.\n\t  */\n\n\n\t  Thenable.prototype._resetMergedFlags = function _resetMergedFlags(obj) {\n\t    // set the submodule to be without timeline for perf reasons\n\t    obj.isTimelineLess = true;\n\t    // reset isShowStart flag for the submodules\n\t    obj.isShowStart = false;\n\t    // reset isRefreshState flag for the submodules\n\t    obj.isRefreshState = false;\n\t    // set the submodule callbacks context\n\t    obj.callbacksContext = this._props.callbacksContext || this;\n\t    // set previous module\n\t    obj.prevChainModule = _h2.default.getLastItem(this._modules);\n\t    // pass the `this` as master module\n\t    obj.masterModule = this;\n\t    return obj;\n\t  };\n\t  /*\n\t    Method to initialize properties.\n\t    @private\n\t  */\n\n\n\t  Thenable.prototype._vars = function _vars() {\n\t    _Tweenable.prototype._vars.call(this);\n\t    // save _master module\n\t    this._masterModule = this._o.masterModule;\n\t    // set isChained flag based on prevChainModule option\n\t    this._isChained = !!this._masterModule;\n\t    // we are expect that the _o object\n\t    // have been already extended by defaults\n\t    var initialRecord = _h2.default.cloneObj(this._props);\n\t    for (var key in this._arrayPropertyMap) {\n\t      if (this._o[key]) {\n\t        var preParsed = this._parsePreArrayProperty(key, this._o[key]);\n\t        initialRecord[key] = preParsed;\n\t      }\n\t    }\n\n\t    this._history = [initialRecord];\n\t    // the array holds all modules in the then chain\n\t    this._modules = [this];\n\t    // the props that to exclude from then merge\n\t    this._nonMergeProps = { shape: 1 };\n\t  };\n\t  /*\n\t    Method to merge two options into one. Used in .then chains.\n\t    @private\n\t    @param {Object} Start options for the merge.\n\t    @param {Object} End options for the merge.\n\t    @returns {Object} Merged options.\n\t  */\n\n\n\t  Thenable.prototype._mergeThenOptions = function _mergeThenOptions(start, end) {\n\t    var o = {};\n\t    this._mergeStartLoop(o, start);\n\t    this._mergeEndLoop(o, start, end);\n\t    this._history.push(o);\n\t    return o;\n\t  };\n\t  /*\n\t    Method to pipe startValue of the delta.\n\t    @private\n\t    @param {String} Start property name.\n\t    @param {Any} Start property value.\n\t    @returns {Any} Start property value.\n\t  */\n\n\n\t  Thenable.prototype._checkStartValue = function _checkStartValue(name, value) {\n\t    return value;\n\t  };\n\t  /*\n\t    Originally part of the _mergeThenOptions.\n\t    Loops thru start object and copies all the props from it.\n\t    @param {Object} An object to copy in.\n\t    @parma {Object} Start options object.\n\t  */\n\n\n\t  Thenable.prototype._mergeStartLoop = function _mergeStartLoop(o, start) {\n\t    // loop thru start options object\n\t    for (var key in start) {\n\t      var value = start[key];\n\t      if (start[key] == null) {\n\t        continue;\n\t      };\n\t      // copy all values from start if not tween prop or duration\n\t      if (!_h2.default.isTweenProp(key) || key === 'duration') {\n\t        // if delta - copy only the end value\n\t        if (this._isDelta(value)) {\n\t          o[key] = _h2.default.getDeltaEnd(value);\n\t        } else {\n\t          o[key] = value;\n\t        }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Originally part of the _mergeThenOptions.\n\t    Loops thru start object and merges all the props from it.\n\t    @param {Object} An object to copy in.\n\t    @parma {Object} Start options object.\n\t    @parma {Object} End options object.\n\t  */\n\n\n\t  Thenable.prototype._mergeEndLoop = function _mergeEndLoop(o, start, end) {\n\t    var endKeys = (0, _keys2.default)(end);\n\n\t    for (var key in end) {\n\t      // just copy parent option\n\t      if (key == 'parent') {\n\t        o[key] = end[key];continue;\n\t      };\n\n\t      // get key/value of the end object\n\t      // endKey - name of the property, endValue - value of the property\n\t      var endValue = end[key],\n\t          startValue = start[key] != null ? start[key] : this._defaults[key];\n\n\t      startValue = this._checkStartValue(key, startValue);\n\t      if (endValue == null) {\n\t        continue;\n\t      };\n\t      // make ∆ of start -> end\n\t      // if key name is radiusX/radiusY and\n\t      // the startValue is not set fallback to radius value\n\t      var isSubRadius = key === 'radiusX' || key === 'radiusY';\n\t      if (isSubRadius && startValue == null) {\n\t        startValue = start.radius;\n\t      }\n\n\t      var isSubRadius = key === 'scaleX' || key === 'scaleY';\n\t      if (isSubRadius && startValue == null) {\n\t        startValue = start.scale;\n\t      }\n\n\t      o[key] = this._mergeThenProperty(key, startValue, endValue);\n\t    }\n\t  };\n\t  /*\n\t    Method to merge `start` and `end` for a property in then record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Start value of the property.\n\t    @param {Any}    End value of the property.\n\t  */\n\n\n\t  Thenable.prototype._mergeThenProperty = function _mergeThenProperty(key, startValue, endValue) {\n\t    // if isnt tween property\n\t    var isBoolean = typeof endValue === 'boolean',\n\t        curve,\n\t        easing;\n\n\t    if (!_h2.default.isTweenProp(key) && !this._nonMergeProps[key] && !isBoolean) {\n\n\t      if (_h2.default.isObject(endValue) && endValue.to != null) {\n\t        curve = endValue.curve;\n\t        easing = endValue.easing;\n\t        endValue = endValue.to;\n\t      }\n\n\t      // if end value is delta - just save it\n\t      if (this._isDelta(endValue)) {\n\t        return this._parseDeltaValues(key, endValue);\n\t      } else {\n\t        var parsedEndValue = this._parsePreArrayProperty(key, endValue);\n\t        // if end value is not delta - merge with start value\n\t        if (this._isDelta(startValue)) {\n\t          var _ref;\n\n\t          // if start value is delta - take the end value\n\t          // as start value of the new delta\n\t          return _ref = {}, _ref[_h2.default.getDeltaEnd(startValue)] = parsedEndValue, _ref.easing = easing, _ref.curve = curve, _ref;\n\t          // if both start and end value are not ∆ - make ∆\n\t        } else {\n\t            var _ref2;\n\n\t            return _ref2 = {}, _ref2[startValue] = parsedEndValue, _ref2.easing = easing, _ref2.curve = curve, _ref2;\n\t          }\n\t      }\n\t      // copy the tween values unattended\n\t    } else {\n\t        return endValue;\n\t      }\n\t  };\n\t  /*\n\t    Method to retreive array's length and return -1 for\n\t    all other types.\n\t    @private\n\t    @param {Array, Any} Array to get the width for.\n\t    @returns {Number} Array length or -1 if not array.\n\t  */\n\n\n\t  Thenable.prototype._getArrayLength = function _getArrayLength(arr) {\n\t    return _h2.default.isArray(arr) ? arr.length : -1;\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Thenable.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = _h2.default.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to check if the module is first in `then` chain.\n\t    @private\n\t    @returns {Boolean} If the module is the first in module chain.\n\t  */\n\n\n\t  Thenable.prototype._isFirstInChain = function _isFirstInChain() {\n\t    return !this._masterModule;\n\t  };\n\t  /*\n\t    Method to check if the module is last in `then` chain.\n\t    @private\n\t    @returns {Boolean} If the module is the last in module chain.\n\t  */\n\n\n\t  Thenable.prototype._isLastInChain = function _isLastInChain() {\n\t    var master = this._masterModule;\n\t    // if there is no master field - check the modules length\n\t    // if module length is 1 thus there is no modules chain\n\t    // it is the last one, otherwise it isnt\n\t    if (!master) {\n\t      return this._modules.length === 1;\n\t    }\n\t    // if there is master - check if it is the last item in _modules chain\n\t    return this === _h2.default.getLastItem(master._modules);\n\t  };\n\n\t  return Thenable;\n\t}(_tweenable2.default);\n\n\texports.default = Thenable;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _thenable = __webpack_require__(12);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Tuneable = function (_Thenable) {\n\t  (0, _inherits3.default)(Tuneable, _Thenable);\n\n\t  function Tuneable() {\n\t    (0, _classCallCheck3.default)(this, Tuneable);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Thenable.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to start the animation with optional new options.\n\t    @public\n\t    @param {Object} New options to set on the run.\n\t    @returns {Object} this.\n\t  */\n\n\t  Tuneable.prototype.tune = function tune(o) {\n\t    // if options object was passed\n\t    if (o && (0, _keys2.default)(o).length) {\n\t      this._transformHistory(o);\n\t      this._tuneNewOptions(o);\n\t      // restore array prop values because _props\n\t      // contain them as parsed arrays\n\t      // but we need the as strings to store in history\n\t      // and merge in history chains\n\t      this._history[0] = _h2.default.cloneObj(this._props);\n\t      for (var key in this._arrayPropertyMap) {\n\t        if (o[key] != null) {\n\t          this._history[0][key] = this._preparsePropValue(key, o[key]);\n\t        }\n\t      }\n\n\t      this._tuneSubModules();\n\t      this._resetTweens();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to regenerate all the random properties form initial object.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Tuneable.prototype.generate = function generate() {\n\t    return this.tune(this._o);\n\t  };\n\n\t  // ^ PUBLIC  METHOD(S) ^\n\t  // v PRIVATE METHOD(S) v\n\n\t  /*\n\t    Method to preparse options in object.\n\t    @private\n\t    @param {Object} Object to preparse properties on.\n\t    @returns {Object} Passed object with preparsed props.\n\t  */\n\t  // _preParseOptions ( o ) {\n\t  //   for (var key in o) {\n\t  //     o[key] = this._preparsePropValue( key, o[key] );\n\t  //   }\n\t  //   return o;\n\t  // }\n\t  /*\n\t    Method to transform history rewrite new options object chain on run.\n\t    @private\n\t    @param {Object} New options to tune for.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistory = function _transformHistory(o) {\n\t    for (var key in o) {\n\t      var value = o[key];\n\t      // don't transform for childOptions\n\t      // if ( key === 'childOptions' ) { continue; }\n\t      this._transformHistoryFor(key, this._preparsePropValue(key, value));\n\t    }\n\t  };\n\t  /*\n\t    Method to transform history chain for specific key/value.\n\t    @param {String} Name of the property to transform history for.\n\t    @param {Any} The new property's value.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistoryFor = function _transformHistoryFor(key, value) {\n\t    for (var i = 0; i < this._history.length; i++) {\n\t      if (value = this._transformHistoryRecord(i, key, value)) {\n\t        // break if no further history modifications needed\n\t        if (value == null) {\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to transform history recod with key/value.\n\t    @param {Number} Index of the history record to transform.\n\t    @param {String} Property name to transform.\n\t    @param {Any} Property value to transform to.\n\t    @param {Object} Optional the current history record.\n\t    @param {Object} Optional the next history record.\n\t    @returns {Boolean} Returns true if no further\n\t                       history modifications is needed.\n\t  */\n\n\n\t  Tuneable.prototype._transformHistoryRecord = function _transformHistoryRecord(index, key, newVal, currRecord, nextRecord) {\n\t    // newVal = this._parseProperty( key, newVal );\n\t    if (newVal == null) {\n\t      return null;\n\t    }\n\n\t    // fallback to history records, if wasn't specified\n\t    currRecord = currRecord == null ? this._history[index] : currRecord;\n\t    nextRecord = nextRecord == null ? this._history[index + 1] : nextRecord;\n\n\t    var oldVal = currRecord[key],\n\t        nextVal = nextRecord == null ? null : nextRecord[key];\n\n\t    // if index is 0 - always save the newVal\n\t    // and return non-delta for subsequent modifications\n\t    if (index === 0) {\n\t      currRecord[key] = newVal;\n\t      // always return on tween properties\n\t      if (_h2.default.isTweenProp(key) && key !== 'duration') {\n\t        return null;\n\t      }\n\t      // nontween properties\n\t      var isRewriteNext = this._isRewriteNext(oldVal, nextVal),\n\t          returnVal = this._isDelta(newVal) ? _h2.default.getDeltaEnd(newVal) : newVal;\n\t      return isRewriteNext ? returnVal : null;\n\t    } else {\n\t      // if was delta and came none-deltta - rewrite\n\t      // the start of the delta and stop\n\t      if (this._isDelta(oldVal)) {\n\t        var _currRecord$key;\n\n\t        currRecord[key] = (_currRecord$key = {}, _currRecord$key[newVal] = _h2.default.getDeltaEnd(oldVal), _currRecord$key);\n\t        return null;\n\t      } else {\n\t        // if the old value is not delta and the new one is\n\t        currRecord[key] = newVal;\n\t        // if the next item has the same value - return the\n\t        // item for subsequent modifications or stop\n\t        return this._isRewriteNext(oldVal, nextVal) ? newVal : null;\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to check if the next item should\n\t    be rewrited in transform history operation.\n\t    @private\n\t    @param {Any} Current value.\n\t    @param {Any} Next value.\n\t    @returns {Boolean} If need to rewrite the next value.\n\t  */\n\n\n\t  Tuneable.prototype._isRewriteNext = function _isRewriteNext(currVal, nextVal) {\n\t    // return false if nothing to rewrite next\n\t    if (nextVal == null && currVal != null) {\n\t      return false;\n\t    }\n\n\t    var isEqual = currVal === nextVal,\n\t        isNextDelta = this._isDelta(nextVal),\n\t        isDelta = this._isDelta(currVal),\n\t        isValueDeltaChain = false,\n\t        isDeltaChain = false;\n\n\t    if (isDelta && isNextDelta) {\n\t      if (_h2.default.getDeltaEnd(currVal) == _h2.default.getDeltaStart(nextVal)) {\n\t        isDeltaChain = true;\n\t      }\n\t    } else if (isNextDelta) {\n\t      isValueDeltaChain = _h2.default.getDeltaStart(nextVal) === '' + currVal;\n\t    }\n\n\t    return isEqual || isValueDeltaChain || isDeltaChain;\n\t  };\n\t  /*\n\t    Method to tune new history options to all the submodules.\n\t    @private\n\t  */\n\n\n\t  Tuneable.prototype._tuneSubModules = function _tuneSubModules() {\n\t    for (var i = 1; i < this._modules.length; i++) {\n\t      this._modules[i]._tuneNewOptions(this._history[i]);\n\t    }\n\t  };\n\t  /*\n\t    Method to set new options on run.\n\t    @param {Boolean} If foreign context.\n\t    @private\n\t  */\n\n\n\t  Tuneable.prototype._resetTweens = function _resetTweens() {\n\t    var i = 0,\n\t        shift = 0,\n\t        tweens = this.timeline._timelines;\n\n\t    // if `isTimelineLess` return\n\t    if (tweens == null) {\n\t      return;\n\t    }\n\n\t    for (var i = 0; i < tweens.length; i++) {\n\t      var tween = tweens[i],\n\t          prevTween = tweens[i - 1];\n\n\t      shift += prevTween ? prevTween._props.repeatTime : 0;\n\t      this._resetTween(tween, this._history[i], shift);\n\t    }\n\t    this.timeline._setProp(this._props.timeline);\n\t    this.timeline._recalcTotalDuration();\n\t  };\n\t  /*\n\t    Method to reset tween with new options.\n\t    @param {Object} Tween to reset.\n\t    @param {Object} Tween's to reset tween with.\n\t    @param {Number} Optional number to shift tween start time.\n\t  */\n\n\n\t  Tuneable.prototype._resetTween = function _resetTween(tween, o) {\n\t    var shift = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n\t    o.shiftTime = shift;tween._setProp(o);\n\t  };\n\n\t  return Tuneable;\n\t}(_thenable2.default);\n\n\texports.default = Tuneable;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar h = __webpack_require__(19);\n\n\tvar Delta = function () {\n\t  function Delta() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Delta);\n\n\t    this._o = o;\n\t    this._createTween(o.tweenOptions);\n\t    // initial properties render\n\t    !this._o.isChained && this.refresh(true);\n\t  }\n\t  /*\n\t    Method to call `_refresh` method on `tween`.\n\t    Use switch between `0` and `1` progress for delta value.\n\t    @public\n\t    @param {Boolean} If refresh before start time or after.\n\t    @returns this.\n\t  */\n\n\n\t  Delta.prototype.refresh = function refresh(isBefore) {\n\t    this._previousValues = [];\n\n\t    var deltas = this._o.deltas;\n\t    for (var i = 0; i < deltas.length; i++) {\n\t      var name = deltas[i].name;\n\t      this._previousValues.push({\n\t        name: name, value: this._o.props[name]\n\t      });\n\t    }\n\n\t    this.tween._refresh(isBefore);\n\t    return this;\n\t  };\n\t  /*\n\t    Method to restore all saved properties from `_previousValues` array.\n\t    @public\n\t    @returns this.\n\t  */\n\n\n\t  Delta.prototype.restore = function restore() {\n\t    var prev = this._previousValues;\n\t    for (var i = 0; i < prev.length; i++) {\n\t      var record = prev[i];\n\t      this._o.props[record.name] = record.value;\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create tween of the delta.\n\t    @private\n\t    @param {Object} Options object.\n\t  */\n\n\n\t  Delta.prototype._createTween = function _createTween() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    var it = this;\n\t    o.callbackOverrides = {\n\t      onUpdate: function onUpdate(ep, p) {\n\t        it._calcCurrentProps(ep, p);\n\t      }\n\t    };\n\n\t    // if not chained - add the onRefresh callback\n\t    // to refresh the tween when needed\n\t    if (!this._o.isChained) {\n\t      o.callbackOverrides.onRefresh = function (isBefore, ep, p) {\n\t        it._calcCurrentProps(ep, p);\n\t      };\n\t    }\n\n\t    o.callbacksContext = this._o.callbacksContext;\n\t    this.tween = new _tween2.default(o);\n\t  };\n\t  /*\n\t    Method to calculate current progress of the deltas.\n\t    @private\n\t    @param {Number} Eased progress to calculate - [0..1].\n\t    @param {Number} Progress to calculate - [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {\n\t    var deltas = this._o.deltas;\n\t    for (var i = 0; i < deltas.length; i++) {\n\t      var type = deltas[i].type;\n\t      this['_calcCurrent_' + type](deltas[i], easedProgress, p);\n\t    }\n\t  };\n\t  /*\n\t    Method to calc the current color delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_color = function _calcCurrent_color(delta, ep, p) {\n\t    var r,\n\t        g,\n\t        b,\n\t        a,\n\t        start = delta.start,\n\t        d = delta.delta;\n\t    if (!delta.curve) {\n\t      r = parseInt(start.r + ep * d.r, 10);\n\t      g = parseInt(start.g + ep * d.g, 10);\n\t      b = parseInt(start.b + ep * d.b, 10);\n\t      a = parseFloat(start.a + ep * d.a);\n\t    } else {\n\t      var cp = delta.curve(p);\n\t      r = parseInt(cp * (start.r + p * d.r), 10);\n\t      g = parseInt(cp * (start.g + p * d.g), 10);\n\t      b = parseInt(cp * (start.b + p * d.b), 10);\n\t      a = parseFloat(cp * (start.a + p * d.a));\n\t    }\n\t    this._o.props[delta.name] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t  };\n\t  /*\n\t    Method to calc the current number delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_number = function _calcCurrent_number(delta, ep, p) {\n\t    this._o.props[delta.name] = !delta.curve ? delta.start + ep * delta.delta : delta.curve(p) * (delta.start + p * delta.delta);\n\t  };\n\t  /*\n\t    Method to calc the current number with units delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_unit = function _calcCurrent_unit(delta, ep, p) {\n\t    var currentValue = !delta.curve ? delta.start.value + ep * delta.delta : delta.curve(p) * (delta.start.value + p * delta.delta);\n\n\t    this._o.props[delta.name] = '' + currentValue + delta.end.unit;\n\t  };\n\t  /*\n\t    Method to calc the current array delta value.\n\t    @param {Object} Delta\n\t    @param {Number} Eased progress [0..1].\n\t    @param {Number} Plain progress [0..1].\n\t  */\n\n\n\t  Delta.prototype._calcCurrent_array = function _calcCurrent_array(delta, ep, p) {\n\t    // var arr,\n\t    var name = delta.name,\n\t        props = this._o.props,\n\t        string = '';\n\n\t    // to prevent GC bothering with arrays garbage\n\t    // if ( h.isArray( props[name] ) ) {\n\t    //   arr = props[name];\n\t    //   arr.length = 0;\n\t    // } else { arr = []; }\n\n\t    // just optimization to prevent curve\n\t    // calculations on every array item\n\t    var proc = delta.curve ? delta.curve(p) : null;\n\n\t    for (var i = 0; i < delta.delta.length; i++) {\n\t      var item = delta.delta[i],\n\t          dash = !delta.curve ? delta.start[i].value + ep * item.value : proc * (delta.start[i].value + p * item.value);\n\n\t      string += '' + dash + item.unit + ' ';\n\t      // arr.push({\n\t      //   string: `${dash}${item.unit}`,\n\t      //   value:  dash,\n\t      //   unit:   item.unit,\n\t      // });\n\t    }\n\t    props[name] = string;\n\t  };\n\n\t  return Delta;\n\t}();\n\n\texports.default = Delta;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _extends2 = __webpack_require__(27);\n\n\tvar _extends3 = _interopRequireDefault(_extends2);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _keys = __webpack_require__(28);\n\n\tvar _keys2 = _interopRequireDefault(_keys);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _delta = __webpack_require__(14);\n\n\tvar _delta2 = _interopRequireDefault(_delta);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  This module's target is to parse options object,\n\t  find deltas in it and send them to `Delta` classes.\n\t  The `Delta` class is dull - they expect actual parsed deltas\n\t  and separated tween options, so we should parse them here.\n\t  The timeline of the module controls the `Delta` modules' tweens.\n\n\t  @param {Object} props Object to set deltas result to (pass to the Delta classes).\n\t  @param {Object} options Object to parse the deltas from.\n\t  @param {Function} onUpdate onUpdate callback.\n\t  @param optional {Object} arrayPropertyMap List of properties with truthy\n\t                                            values which describe properties\n\t                                            that should be parsed as arrays.\n\t  @param optional {Object} numberPropertyMap List of properties with truthy\n\t                                            values which describe properties\n\t                                            that should be parsed as numbers\n\t                                            without units.\n\t*/\n\n\t// TODO:\n\t// - colors with curves change alpha level too\n\t// const html = new mojs.Html({\n\t//   el: '#js-el',\n\t//   x: { 0: 100 },\n\t//   onUpdate () {\n\t//     console.log(this._props.originX);\n\t//   },\n\t//   originX: { 'white': 'black', curve: 'M0,100 L100, 0' },\n\t//   customProperties: {\n\t//     originX: {\n\t//       type: 'color',\n\t//       default: 'cyan'\n\t//     },\n\t//     draw() { console.log('draw'); }\n\t//   }\n\t// });\n\n\tvar easing = __webpack_require__(22);\n\tvar h = __webpack_require__(19);\n\n\n\t// get tween properties\n\tvar obj = {};\n\t_tween2.default.prototype._declareDefaults.call(obj);\n\tvar keys = (0, _keys2.default)(obj._defaults);\n\tfor (var i = 0; i < keys.length; i++) {\n\t  obj._defaults[keys[i]] = 1;\n\t}\n\tobj._defaults['timeline'] = 1;\n\tvar TWEEN_PROPERTIES = obj._defaults;\n\n\tvar Deltas = function () {\n\t  function Deltas() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Deltas);\n\n\t    this._o = o;\n\n\t    this._shortColors = {\n\t      transparent: 'rgba(0,0,0,0)',\n\t      none: 'rgba(0,0,0,0)',\n\t      aqua: 'rgb(0,255,255)',\n\t      black: 'rgb(0,0,0)',\n\t      blue: 'rgb(0,0,255)',\n\t      fuchsia: 'rgb(255,0,255)',\n\t      gray: 'rgb(128,128,128)',\n\t      green: 'rgb(0,128,0)',\n\t      lime: 'rgb(0,255,0)',\n\t      maroon: 'rgb(128,0,0)',\n\t      navy: 'rgb(0,0,128)',\n\t      olive: 'rgb(128,128,0)',\n\t      purple: 'rgb(128,0,128)',\n\t      red: 'rgb(255,0,0)',\n\t      silver: 'rgb(192,192,192)',\n\t      teal: 'rgb(0,128,128)',\n\t      white: 'rgb(255,255,255)',\n\t      yellow: 'rgb(255,255,0)',\n\t      orange: 'rgb(255,128,0)'\n\t    };\n\n\t    this._ignoreDeltasMap = { prevChainModule: 1, masterModule: 1 };\n\n\t    this._parseDeltas(o.options);\n\t    this._createDeltas();\n\t    this._createTimeline(this._mainTweenOptions);\n\t  }\n\t  /*\n\t    Method to call `refresh` on all child `delta` objects.\n\t    @public\n\t    @param {Boolean} If before start time (true) or after end time (false).\n\t  */\n\n\n\t  Deltas.prototype.refresh = function refresh(isBefore) {\n\t    for (var i = 0; i < this._deltas.length; i++) {\n\t      this._deltas[i].refresh(isBefore);\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to call `restore` on all child `delta` objects.\n\t    @public\n\t  */\n\n\n\t  Deltas.prototype.restore = function restore() {\n\t    for (var i = 0; i < this._deltas.length; i++) {\n\t      this._deltas[i].restore();\n\t    }\n\t    return this;\n\t  };\n\t  /*\n\t    Method to create Timeline.\n\t    @private\n\t    @param {Object} Timeline options.\n\t  */\n\n\n\t  Deltas.prototype._createTimeline = function _createTimeline() {\n\t    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n\t    // const o = this._o;\n\t    // opts.timeline = opts.timeline || {};\n\t    // opts.timeline.callbackOverrides = {\n\t    //   onUpdate:   o.onUpdate,\n\t    //   onRefresh:  o.onUpdate\n\t    // }\n\t    // send callbacksContext to timeline if set\n\t    // o.callbacksContext && (opts.timeline.callbacksContext = o.callbacksContext);\n\t    // opts.timeline\n\t    this.timeline = new _timeline2.default();\n\t    this.timeline.add(this._deltas);\n\t  };\n\t  /*\n\t    Method to create Deltas from parsed options.\n\t    @private\n\t  */\n\n\n\t  Deltas.prototype._createDeltas = function _createDeltas() {\n\t    this._deltas = [];\n\n\t    // create main delta object\n\t    this._deltas.push(this._createDelta(this._mainDeltas, this._mainTweenOptions));\n\n\t    // create child delta object\n\t    for (var i = 0; i < this._childDeltas.length; i++) {\n\t      var delta = this._childDeltas[i];\n\t      this._deltas.push(this._createDelta([delta.delta], delta.tweenOptions));\n\t    }\n\t  };\n\t  /*\n\t    Method to create Delta object with passed options.\n\t    @private\n\t    @param {Array} Array of deltas.\n\t    @param {Object} Tween properties.\n\t    @returns {Object} Delta object\n\t  */\n\n\n\t  Deltas.prototype._createDelta = function _createDelta(deltas, tweenOptions) {\n\t    var o = this._o;\n\t    return new _delta2.default({\n\t      deltas: deltas, tweenOptions: tweenOptions,\n\t      props: o.props,\n\t      isChained: o.isChained,\n\t      callbacksContext: o.callbacksContext\n\t    });\n\t  };\n\t  /*\n\t    Method to parse delta objects from options.\n\t    @private\n\t    @param {Object} Options object to parse the deltas from.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltas = function _parseDeltas(obj) {\n\t    // spilt main animation properties and main tween properties\n\t    var mainSplit = this._splitTweenOptions(obj);\n\t    // main animation properties\n\t    var opts = mainSplit.delta;\n\t    // main tween properties\n\t    this._mainTweenOptions = mainSplit.tweenOptions;\n\n\t    this._mainDeltas = [];\n\t    this._childDeltas = [];\n\t    var keys = (0, _keys2.default)(opts);\n\t    // loop thru all properties without tween ones\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      // is property is delta - parse it\n\t      if (this._isDelta(opts[key]) && !this._ignoreDeltasMap[key]) {\n\t        var delta = this._splitAndParseDelta(key, opts[key]);\n\t        // if parsed object has no tween values - it's delta of the main object\n\t        if (!delta.tweenOptions) {\n\t          this._mainDeltas.push(delta.delta);\n\t        }\n\t        // otherwise it is distinct delta object\n\t        else {\n\t            this._childDeltas.push(delta);\n\t          }\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to split tween values and parse single delta record.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @returns {Object} Split object.\n\t                @param {Object} tweenOptions Tween properties.\n\t                @param {Object} delta Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._splitAndParseDelta = function _splitAndParseDelta(name, object) {\n\t    var split = this._splitTweenOptions(object);\n\t    // parse delta in the object\n\t    split.delta = this._parseDelta(name, split.delta);\n\t    return split;\n\t  };\n\t  /*\n\t    Method to parse delta by delegating the variables to _parse*Delta methods.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDelta = function _parseDelta(name, object, index) {\n\t    // if name is in _o.customProps - parse it regarding the type\n\t    return this._o.customProps && this._o.customProps[name] != null ? this._parseDeltaByCustom(name, object, index) : this._parseDeltaByGuess(name, object, index);\n\t  };\n\t  /**\n\t    Method to parse delta by taking the type from the customProps object.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltaByCustom = function _parseDeltaByCustom(name, object, index) {\n\t    return this._parseNumberDelta(name, object, index);\n\t    // const customRecord = this._o.customProps[name];\n\t    // switch ( customRecord.type.toLowerCase() ) {\n\t    //   case 'color':  { return this._parseColorDelta( name, object ); }\n\t    //   case 'array':  { return this._parseArrayDelta( name, object ); }\n\t    //   case 'number': { return this._parseNumberDelta( name, object, index ); }\n\t    //   case 'unit':   { return this._parseUnitDelta( name, object, index ); }\n\t    // }\n\t  };\n\t  /**\n\t    Method to parse delta by reasoning about it's value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Object} Raw delta object.\n\t    @param {Number} Module index.\n\t  */\n\n\n\t  Deltas.prototype._parseDeltaByGuess = function _parseDeltaByGuess(name, object, index) {\n\t    var _preparseDelta2 = this._preparseDelta(object);\n\n\t    var start = _preparseDelta2.start;\n\n\t    var o = this._o;\n\n\t    // color values\n\t    if (isNaN(parseFloat(start)) && !start.match(/rand\\(/) && !start.match(/stagger\\(/)) {\n\t      return this._parseColorDelta(name, object);\n\t      // array values\n\t    } else if (o.arrayPropertyMap && o.arrayPropertyMap[name]) {\n\t        return this._parseArrayDelta(name, object);\n\t        // unit or number values\n\t      } else {\n\t          return o.numberPropertyMap && o.numberPropertyMap[name] ?\n\t          // if the property is in the number property map - parse it like number\n\t          this._parseNumberDelta(name, object, index)\n\t          // otherwise - like number with units\n\t          : this._parseUnitDelta(name, object, index);\n\t        }\n\t  };\n\t  /*\n\t    Method to separate tween options from delta properties.\n\t    @param {Object} Object for separation.\n\t    @returns {Object} Object that contains 2 objects\n\t                        - one delta options\n\t                        - one tween options ( could be empty if no tween opts )\n\t  */\n\n\n\t  Deltas.prototype._splitTweenOptions = function _splitTweenOptions(delta) {\n\t    delta = (0, _extends3.default)({}, delta);\n\n\t    var keys = (0, _keys2.default)(delta),\n\t        tweenOptions = {};\n\t    var isTween = null;\n\n\t    for (var i = 0; i < keys.length; i++) {\n\t      var key = keys[i];\n\t      if (TWEEN_PROPERTIES[key]) {\n\t        if (delta[key] != null) {\n\t          tweenOptions[key] = delta[key];\n\t          isTween = true;\n\t        }\n\t        delete delta[key];\n\t      }\n\t    }\n\t    return {\n\t      delta: delta,\n\t      tweenOptions: isTween ? tweenOptions : undefined\n\t    };\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Deltas.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = h.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || h.isArray(optionsValue) || h.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to parse color delta values.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseColorDelta = function _parseColorDelta(key, value) {\n\t    if (key === 'strokeLinecap') {\n\t      h.warn('Sorry, stroke-linecap property is not animatable yet, using the start(#{start}) value instead', value);\n\t      return {};\n\t    }\n\t    var preParse = this._preparseDelta(value);\n\n\t    var startColorObj = this._makeColorObj(preParse.start),\n\t        endColorObj = this._makeColorObj(preParse.end);\n\n\t    var delta = {\n\t      type: 'color',\n\t      name: key,\n\t      start: startColorObj,\n\t      end: endColorObj,\n\t      curve: preParse.curve,\n\t      delta: {\n\t        r: endColorObj.r - startColorObj.r,\n\t        g: endColorObj.g - startColorObj.g,\n\t        b: endColorObj.b - startColorObj.b,\n\t        a: endColorObj.a - startColorObj.a\n\t      }\n\t    };\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse array delta values.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseArrayDelta = function _parseArrayDelta(key, value) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var startArr = this._strToArr(preParse.start),\n\t        endArr = this._strToArr(preParse.end);\n\n\t    h.normDashArrays(startArr, endArr);\n\n\t    for (var i = 0; i < startArr.length; i++) {\n\t      var end = endArr[i];\n\t      h.mergeUnits(startArr[i], end, key);\n\t    }\n\n\t    var delta = {\n\t      type: 'array',\n\t      name: key,\n\t      start: startArr,\n\t      end: endArr,\n\t      delta: h.calcArrDelta(startArr, endArr),\n\t      curve: preParse.curve\n\t    };\n\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse numeric delta values with units.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @param {Number} Index of the module.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseUnitDelta = function _parseUnitDelta(key, value, index) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var end = h.parseUnit(h.parseStringOption(preParse.end, index)),\n\t        start = h.parseUnit(h.parseStringOption(preParse.start, index));\n\n\t    h.mergeUnits(start, end, key);\n\t    var delta = {\n\t      type: 'unit',\n\t      name: key,\n\t      start: start,\n\t      end: end,\n\t      delta: end.value - start.value,\n\t      curve: preParse.curve\n\t    };\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to parse numeric delta values without units.\n\t    @private\n\t    @param {String} Name of the property.\n\t    @param {Any} Property value.\n\t    @param {Number} Index of the module.\n\t    @returns {Object} Parsed delta.\n\t  */\n\n\n\t  Deltas.prototype._parseNumberDelta = function _parseNumberDelta(key, value, index) {\n\t    var preParse = this._preparseDelta(value);\n\n\t    var end = parseFloat(h.parseStringOption(preParse.end, index)),\n\t        start = parseFloat(h.parseStringOption(preParse.start, index));\n\n\t    var delta = {\n\t      type: 'number',\n\t      name: key,\n\t      start: start,\n\t      end: end,\n\t      delta: end - start,\n\t      curve: preParse.curve\n\t    };\n\n\t    return delta;\n\t  };\n\t  /*\n\t    Method to extract `curve` and `start`/`end` values.\n\t    @private\n\t    @param {Object} Delta object.\n\t    @returns {Object} Preparsed delta.\n\t              @property {String} Start value.\n\t              @property {String, Number} End value.\n\t  */\n\n\n\t  Deltas.prototype._preparseDelta = function _preparseDelta(value) {\n\t    // clone value object\n\t    value = (0, _extends3.default)({}, value);\n\t    // parse curve if exist\n\t    var curve = value.curve;\n\t    if (curve != null) {\n\t      curve = easing.parseEasing(curve);\n\t      curve._parent = this;\n\t    }\n\t    delete value.curve;\n\t    // parse start and end values\n\t    var start = (0, _keys2.default)(value)[0],\n\t        end = value[start];\n\n\t    return { start: start, end: end, curve: curve };\n\t  };\n\t  /*\n\t    Method to parse color into usable object.\n\t    @private\n\t    @param {String} Color string.\n\t    @returns {Object} Parsed color value.\n\t  */\n\n\n\t  Deltas.prototype._makeColorObj = function _makeColorObj(color) {\n\t    // HEX\n\t    var colorObj = {};\n\t    if (color[0] === '#') {\n\t      var result = /^#?([a-f\\d]{1,2})([a-f\\d]{1,2})([a-f\\d]{1,2})$/i.exec(color);\n\t      if (result) {\n\t        var r = result[1].length === 2 ? result[1] : result[1] + result[1],\n\t            g = result[2].length === 2 ? result[2] : result[2] + result[2],\n\t            b = result[3].length === 2 ? result[3] : result[3] + result[3];\n\n\t        colorObj = {\n\t          r: parseInt(r, 16), g: parseInt(g, 16), b: parseInt(b, 16), a: 1\n\t        };\n\t      }\n\t    }\n\n\t    // not HEX\n\t    // shorthand color and rgb()\n\t    if (color[0] !== '#') {\n\t      var isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';\n\t      var rgbColor = undefined;\n\t      // rgb color\n\t      if (isRgb) {\n\t        rgbColor = color;\n\t      };\n\t      // shorthand color name\n\t      if (!isRgb) {\n\t        if (!this._shortColors[color]) {\n\t          h.div.style.color = color;\n\t          rgbColor = h.computedStyle(h.div).color;\n\t        } else {\n\t          rgbColor = this._shortColors[color];\n\t        }\n\t      }\n\n\t      var regexString1 = '^rgba?\\\\((\\\\d{1,3}),\\\\s?(\\\\d{1,3}),',\n\t          regexString2 = '\\\\s?(\\\\d{1,3}),?\\\\s?(\\\\d{1}|0?\\\\.\\\\d{1,})?\\\\)$',\n\t          result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor),\n\t          alpha = parseFloat(result[4] || 1);\n\n\t      if (result) {\n\t        colorObj = {\n\t          r: parseInt(result[1], 10),\n\t          g: parseInt(result[2], 10),\n\t          b: parseInt(result[3], 10),\n\t          a: alpha != null && !isNaN(alpha) ? alpha : 1\n\t        };\n\t      }\n\t    }\n\n\t    return colorObj;\n\t  };\n\t  /*\n\t    Method to parse string into array.\n\t    @private\n\t    @param {String, Number} String or number to parse.\n\t    @returns {Array} Parsed array.\n\t  */\n\n\n\t  Deltas.prototype._strToArr = function _strToArr(string) {\n\t    var arr = [];\n\t    // plain number\n\t    if (typeof string === 'number' && !isNaN(string)) {\n\t      arr.push(h.parseUnit(string));\n\t      return arr;\n\t    }\n\t    // string array\n\t    string.trim().split(/\\s+/gim).forEach(function (str) {\n\t      arr.push(h.parseUnit(h.parseIfRand(str)));\n\t    });\n\t    return arr;\n\t  };\n\n\t  return Deltas;\n\t}();\n\n\texports.default = Deltas;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Base class for module. Extends and parses defaults.\n\t*/\n\n\tvar Module = function () {\n\t  function Module() {\n\t    var o = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t    (0, _classCallCheck3.default)(this, Module);\n\n\t    // this._isIt = o.isIt;\n\t    // delete o.isIt;\n\t    this._o = o;\n\t    this._index = this._o.index || 0;\n\t    // map of props that should be\n\t    // parsed to arrays of values\n\t    this._arrayPropertyMap = {\n\t      strokeDashoffset: 1,\n\t      strokeDasharray: 1,\n\t      origin: 1\n\t    };\n\n\t    this._skipPropsDelta = {\n\t      timeline: 1,\n\t      prevChainModule: 1,\n\t      callbacksContext: 1\n\t    };\n\n\t    this._declareDefaults();\n\t    this._extendDefaults();\n\n\t    this._vars();\n\t    this._render();\n\t  }\n\t  /*\n\t    Method to declare defaults.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {};\n\t  };\n\t  /*\n\t    Method to declare module's variables.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._vars = function _vars() {\n\t    this._progress = 0;\n\t    this._strokeDasharrayBuffer = [];\n\t  };\n\t  /*\n\t    Method to render on initialization.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._render = function _render() {};\n\t  /*\n\t    Method to set property on the module.\n\t    @private\n\t    @param {String, Object} Name of the property to set\n\t                            or object with properties to set.\n\t    @param {Any} Value for the property to set. Could be\n\t                  undefined if the first param is object.\n\t  */\n\n\n\t  Module.prototype._setProp = function _setProp(attr, value) {\n\t    if ((typeof attr === 'undefined' ? 'undefined' : (0, _typeof3.default)(attr)) === 'object') {\n\t      for (var key in attr) {\n\t        this._assignProp(key, attr[key]);\n\t      }\n\t    } else {\n\t      this._assignProp(attr, value);\n\t    }\n\t  };\n\t  /*\n\t    Method to assign single property's value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t  */\n\n\n\t  Module.prototype._assignProp = function _assignProp(key, value) {\n\t    this._props[key] = value;\n\t  };\n\t  /*\n\t    Method to show element.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._show = function _show() {\n\t    var p = this._props;\n\t    if (!this.el) {\n\t      return;\n\t    }\n\n\t    if (p.isSoftHide) {\n\t      // this.el.style.opacity = p.opacity;\n\t      this._showByTransform();\n\t    } else {\n\t      this.el.style.display = 'block';\n\t    }\n\n\t    this._isShown = true;\n\t  };\n\t  /*\n\t    Method to hide element.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._hide = function _hide() {\n\t    if (!this.el) {\n\t      return;\n\t    }\n\n\t    if (this._props.isSoftHide) {\n\t      // this.el.style.opacity = 0;\n\t      _h2.default.setPrefixedStyle(this.el, 'transform', 'scale(0)');\n\t    } else {\n\t      this.el.style.display = 'none';\n\t    }\n\n\t    this._isShown = false;\n\t  };\n\t  /*\n\t    Method to show element by applying transform back to normal.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._showByTransform = function _showByTransform() {};\n\t  /*\n\t    Method to parse option string.\n\t    Searches for stagger and rand values and parses them.\n\t    Leaves the value unattended otherwise.\n\t    @param {Any} Option value to parse.\n\t    @returns {Number} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parseOptionString = function _parseOptionString(value) {\n\t    if (typeof value === 'string') {\n\t      if (value.match(/stagger/)) {\n\t        value = _h2.default.parseStagger(value, this._index);\n\t      }\n\t    }\n\t    if (typeof value === 'string') {\n\t      if (value.match(/rand/)) {\n\t        value = _h2.default.parseRand(value);\n\t      }\n\t    }\n\t    return value;\n\t  };\n\t  /*\n\t    Method to parse postion option.\n\t    @param {String} Property name.\n\t    @param {Any} Property Value.\n\t    @returns {String} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parsePositionOption = function _parsePositionOption(key, value) {\n\t    if (_h2.default.unitOptionMap[key]) {\n\t      value = _h2.default.parseUnit(value).string;\n\t    }\n\t    return value;\n\t  };\n\t  /*\n\t    Method to parse strokeDash.. option.\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {String} Parsed options value.\n\t  */\n\n\n\t  Module.prototype._parseStrokeDashOption = function _parseStrokeDashOption(key, value) {\n\t    var result = value;\n\t    // parse numeric/percent values for strokeDash.. properties\n\t    if (this._arrayPropertyMap[key]) {\n\t      var result = [];\n\t      switch (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) {\n\t        case 'number':\n\t          result.push(_h2.default.parseUnit(value));\n\t          break;\n\t        case 'string':\n\t          var array = value.split(' ');\n\t          for (var i = 0; i < array.length; i++) {\n\t            result.push(_h2.default.parseUnit(array[i]));\n\t          }\n\t          break;\n\t      }\n\t    }\n\t    return result;\n\t  };\n\t  /*\n\t    Method to check if the property is delta property.\n\t    @private\n\t    @param {Any} Parameter value to check.\n\t    @returns {Boolean}\n\t  */\n\n\n\t  Module.prototype._isDelta = function _isDelta(optionsValue) {\n\t    var isObject = _h2.default.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || _h2.default.isArray(optionsValue) || _h2.default.isDOM(optionsValue));\n\t  };\n\t  /*\n\t    Method to get delta from property and set\n\t    the property's start value to the props object.\n\t    @private\n\t    @param {String} Key name to get delta for.\n\t    @param {Object} Option value to get the delta for.\n\t  */\n\n\n\t  Module.prototype._getDelta = function _getDelta(key, optionsValue) {\n\t    var delta;\n\t    if ((key === 'left' || key === 'top') && !this._o.ctx) {\n\t      _h2.default.warn('Consider to animate x/y properties instead of left/top,\\n        as it would be much more performant', optionsValue);\n\t    }\n\t    // skip delta calculation for a property if it is listed\n\t    // in skipPropsDelta object\n\t    if (this._skipPropsDelta && this._skipPropsDelta[key]) {\n\t      return;\n\t    }\n\t    // get delta\n\t    delta = _h2.default.parseDelta(key, optionsValue, this._index);\n\t    // if successfully parsed - save it\n\t    if (delta.type != null) {\n\t      this._deltas[key] = delta;\n\t    }\n\n\t    var deltaEnd = (0, _typeof3.default)(delta.end) === 'object' ? delta.end.value === 0 ? 0 : delta.end.string : delta.end;\n\t    // set props to end value of the delta\n\t    // 0 should be 0 regardless units\n\t    this._props[key] = deltaEnd;\n\t  };\n\t  /*\n\t    Method to copy `_o` options to `_props` object\n\t    with fallback to `_defaults`.\n\t    @private\n\t  */\n\n\n\t  Module.prototype._extendDefaults = function _extendDefaults() {\n\t    this._props = {};\n\t    this._deltas = {};\n\t    for (var key in this._defaults) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\t      // copy the properties to the _o object\n\t      var value = this._o[key] != null ? this._o[key] : this._defaults[key];\n\t      // parse option\n\t      this._parseOption(key, value);\n\t    }\n\t  };\n\t  /*\n\t    Method to tune new oprions to _o and _props object.\n\t    @private\n\t    @param {Object} Options object to tune to.\n\t  */\n\n\n\t  Module.prototype._tuneNewOptions = function _tuneNewOptions(o) {\n\t    // hide the module before tuning it's options\n\t    // cuz the user could see the change\n\t    this._hide();\n\t    for (var key in o) {\n\t      // skip property if it is listed in _skipProps\n\t      // if (this._skipProps && this._skipProps[key]) { continue; }\n\t      // copy the properties to the _o object\n\t      // delete the key from deltas\n\t      o && delete this._deltas[key];\n\t      // rewrite _o record\n\t      this._o[key] = o[key];\n\t      // save the options to _props\n\t      this._parseOption(key, o[key]);\n\t    }\n\t  };\n\t  /*\n\t    Method to parse option value.\n\t    @private\n\t    @param {String} Option name.\n\t    @param {Any} Option value.\n\t  */\n\n\n\t  Module.prototype._parseOption = function _parseOption(name, value) {\n\t    // if delta property\n\t    if (this._isDelta(value) && !this._skipPropsDelta[name]) {\n\t      this._getDelta(name, value);\n\t      var deltaEnd = _h2.default.getDeltaEnd(value);\n\t      return this._assignProp(name, this._parseProperty(name, deltaEnd));\n\t    }\n\n\t    this._assignProp(name, this._parseProperty(name, value));\n\t  };\n\t  /*\n\t    Method to parse postion and string props.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._parsePreArrayProperty = function _parsePreArrayProperty(name, value) {\n\t    // parse stagger and rand values\n\t    value = this._parseOptionString(value);\n\t    // parse units for position properties\n\t    return this._parsePositionOption(name, value);\n\t  };\n\t  /*\n\t    Method to parse property value.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._parseProperty = function _parseProperty(name, value) {\n\t    // parse `HTML` element in `parent` option\n\t    if (name === 'parent') {\n\t      return _h2.default.parseEl(value);\n\t    }\n\t    // parse `stagger`, `rand` and `position`\n\t    value = this._parsePreArrayProperty(name, value);\n\t    // parse numeric/percent values for strokeDash.. properties\n\t    return this._parseStrokeDashOption(name, value);\n\t  };\n\t  /*\n\t    Method to parse values inside ∆.\n\t    @private\n\t    @param {String} Key name.\n\t    @param {Object} Delta.\n\t    @returns {Object} Delta with parsed parameters.\n\t  */\n\n\n\t  Module.prototype._parseDeltaValues = function _parseDeltaValues(name, delta) {\n\t    // return h.parseDelta( name, delta, this._index );\n\n\t    var d = {};\n\t    for (var key in delta) {\n\t      var value = delta[key];\n\n\t      // delete delta[key];\n\t      // add parsed properties\n\t      var newEnd = this._parsePreArrayProperty(name, value);\n\t      d[this._parsePreArrayProperty(name, key)] = newEnd;\n\t    }\n\t    return d;\n\t  };\n\t  /*\n\t    Method to parse delta and nondelta properties.\n\t    @private\n\t    @param {String} Property name.\n\t    @param {Any}    Property value.\n\t    @returns {Any}  Parsed property value.\n\t  */\n\n\n\t  Module.prototype._preparsePropValue = function _preparsePropValue(key, value) {\n\t    return this._isDelta(value) ? this._parseDeltaValues(key, value) : this._parsePreArrayProperty(key, value);\n\t  };\n\t  /*\n\t    Method to calculate current progress of the deltas.\n\t    @private\n\t    @param {Number} Eased progress to calculate - [0..1].\n\t    @param {Number} Progress to calculate - [0..1].\n\t  */\n\n\n\t  Module.prototype._calcCurrentProps = function _calcCurrentProps(easedProgress, p) {\n\n\t    for (var key in this._deltas) {\n\n\t      var value = this._deltas[key];\n\n\t      // get eased progress from delta easing if defined and not curve\n\t      var isCurve = !!value.curve;\n\t      var ep = value.easing != null && !isCurve ? value.easing(p) : easedProgress;\n\n\t      if (value.type === 'array') {\n\t        var arr;\n\t        // if prop property is array - reuse it else - create an array\n\t        if (_h2.default.isArray(this._props[key])) {\n\t          arr = this._props[key];\n\t          arr.length = 0;\n\t        } else {\n\t          arr = [];\n\t        }\n\n\t        // just optimization to prevent curve\n\t        // calculations on every array item\n\t        var proc = isCurve ? value.curve(p) : null;\n\n\t        for (var i = 0; i < value.delta.length; i++) {\n\t          var item = value.delta[i],\n\t              dash = !isCurve ? value.start[i].value + ep * item.value : proc * (value.start[i].value + p * item.value);\n\t          arr.push({\n\t            string: '' + dash + item.unit,\n\t            value: dash,\n\t            unit: item.unit\n\t          });\n\t        }\n\n\t        this._props[key] = arr;\n\t      } else if (value.type === 'number') {\n\t        this._props[key] = !isCurve ? value.start + ep * value.delta : value.curve(p) * (value.start + p * value.delta);\n\t      } else if (value.type === 'unit') {\n\t        var currentValue = !isCurve ? value.start.value + ep * value.delta : value.curve(p) * (value.start.value + p * value.delta);\n\n\t        this._props[key] = '' + currentValue + value.end.unit;\n\t      } else if (value.type === 'color') {\n\t        var r, g, b, a;\n\t        if (!isCurve) {\n\t          r = parseInt(value.start.r + ep * value.delta.r, 10);\n\t          g = parseInt(value.start.g + ep * value.delta.g, 10);\n\t          b = parseInt(value.start.b + ep * value.delta.b, 10);\n\t          a = parseFloat(value.start.a + ep * value.delta.a);\n\t        } else {\n\t          var cp = value.curve(p);\n\t          r = parseInt(cp * (value.start.r + p * value.delta.r), 10);\n\t          g = parseInt(cp * (value.start.g + p * value.delta.g), 10);\n\t          b = parseInt(cp * (value.start.b + p * value.delta.b), 10);\n\t          a = parseFloat(cp * (value.start.a + p * value.delta.a));\n\t        }\n\t        this._props[key] = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to calculate current progress and probably draw it in children.\n\t    @private\n\t    @param {Number} Eased progress to set - [0..1].\n\t    @param {Number} Progress to set - [0..1].\n\t  */\n\n\n\t  Module.prototype._setProgress = function _setProgress(easedProgress, progress) {\n\t    this._progress = easedProgress;\n\t    this._calcCurrentProps(easedProgress, progress);\n\t  };\n\n\t  return Module;\n\t}();\n\n\texports.default = Module;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\tvar _typeof = typeof _Symbol === \"function\" && typeof _Symbol$iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _Symbol === \"function\" && obj.constructor === _Symbol ? \"symbol\" : typeof obj; };\n\n\texports.__esModule = true;\n\n\tvar _iterator = __webpack_require__(32);\n\n\tvar _iterator2 = _interopRequireDefault(_iterator);\n\n\tvar _symbol = __webpack_require__(33);\n\n\tvar _symbol2 = _interopRequireDefault(_symbol);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n\t  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t} : function (obj) {\n\t  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Helpers, h;\n\n\tHelpers = (function() {\n\t  Helpers.prototype.NS = 'http://www.w3.org/2000/svg';\n\n\t  Helpers.prototype.logBadgeCss = 'background:#3A0839;color:#FF512F;border-radius:5px; padding: 1px 5px 2px; border: 1px solid #FF512F;';\n\n\t  Helpers.prototype.shortColors = {\n\t    transparent: 'rgba(0,0,0,0)',\n\t    none: 'rgba(0,0,0,0)',\n\t    aqua: 'rgb(0,255,255)',\n\t    black: 'rgb(0,0,0)',\n\t    blue: 'rgb(0,0,255)',\n\t    fuchsia: 'rgb(255,0,255)',\n\t    gray: 'rgb(128,128,128)',\n\t    green: 'rgb(0,128,0)',\n\t    lime: 'rgb(0,255,0)',\n\t    maroon: 'rgb(128,0,0)',\n\t    navy: 'rgb(0,0,128)',\n\t    olive: 'rgb(128,128,0)',\n\t    purple: 'rgb(128,0,128)',\n\t    red: 'rgb(255,0,0)',\n\t    silver: 'rgb(192,192,192)',\n\t    teal: 'rgb(0,128,128)',\n\t    white: 'rgb(255,255,255)',\n\t    yellow: 'rgb(255,255,0)',\n\t    orange: 'rgb(255,128,0)'\n\t  };\n\n\t  Helpers.prototype.chainOptionMap = {};\n\n\t  Helpers.prototype.callbacksMap = {\n\t    onRefresh: 1,\n\t    onStart: 1,\n\t    onComplete: 1,\n\t    onFirstUpdate: 1,\n\t    onUpdate: 1,\n\t    onProgress: 1,\n\t    onRepeatStart: 1,\n\t    onRepeatComplete: 1,\n\t    onPlaybackStart: 1,\n\t    onPlaybackPause: 1,\n\t    onPlaybackStop: 1,\n\t    onPlaybackComplete: 1\n\t  };\n\n\t  Helpers.prototype.tweenOptionMap = {\n\t    duration: 1,\n\t    delay: 1,\n\t    speed: 1,\n\t    repeat: 1,\n\t    easing: 1,\n\t    backwardEasing: 1,\n\t    isYoyo: 1,\n\t    shiftTime: 1,\n\t    isReversed: 1,\n\t    callbacksContext: 1\n\t  };\n\n\t  Helpers.prototype.unitOptionMap = {\n\t    left: 1,\n\t    top: 1,\n\t    x: 1,\n\t    y: 1,\n\t    rx: 1,\n\t    ry: 1\n\t  };\n\n\t  Helpers.prototype.RAD_TO_DEG = 180 / Math.PI;\n\n\t  function Helpers() {\n\t    this.vars();\n\t  }\n\n\t  Helpers.prototype.vars = function() {\n\t    var ua;\n\t    this.prefix = this.getPrefix();\n\t    this.getRemBase();\n\t    this.isFF = this.prefix.lowercase === 'moz';\n\t    this.isIE = this.prefix.lowercase === 'ms';\n\t    ua = navigator.userAgent;\n\t    this.isOldOpera = ua.match(/presto/gim);\n\t    this.isSafari = ua.indexOf('Safari') > -1;\n\t    this.isChrome = ua.indexOf('Chrome') > -1;\n\t    this.isOpera = ua.toLowerCase().indexOf(\"op\") > -1;\n\t    this.isChrome && this.isSafari && (this.isSafari = false);\n\t    (ua.match(/PhantomJS/gim)) && (this.isSafari = false);\n\t    this.isChrome && this.isOpera && (this.isChrome = false);\n\t    this.is3d = this.checkIf3d();\n\t    this.uniqIDs = -1;\n\t    this.div = document.createElement('div');\n\t    document.body.appendChild(this.div);\n\t    return this.defaultStyles = this.computedStyle(this.div);\n\t  };\n\n\t  Helpers.prototype.cloneObj = function(obj, exclude) {\n\t    var i, key, keys, newObj;\n\t    keys = Object.keys(obj);\n\t    newObj = {};\n\t    i = keys.length;\n\t    while (i--) {\n\t      key = keys[i];\n\t      if (exclude != null) {\n\t        if (!exclude[key]) {\n\t          newObj[key] = obj[key];\n\t        }\n\t      } else {\n\t        newObj[key] = obj[key];\n\t      }\n\t    }\n\t    return newObj;\n\t  };\n\n\t  Helpers.prototype.extend = function(objTo, objFrom) {\n\t    var key, value;\n\t    for (key in objFrom) {\n\t      value = objFrom[key];\n\t      if (objTo[key] == null) {\n\t        objTo[key] = objFrom[key];\n\t      }\n\t    }\n\t    return objTo;\n\t  };\n\n\t  Helpers.prototype.getRemBase = function() {\n\t    var html, style;\n\t    html = document.querySelector('html');\n\t    style = getComputedStyle(html);\n\t    return this.remBase = parseFloat(style.fontSize);\n\t  };\n\n\t  Helpers.prototype.clamp = function(value, min, max) {\n\t    if (value < min) {\n\t      return min;\n\t    } else if (value > max) {\n\t      return max;\n\t    } else {\n\t      return value;\n\t    }\n\t  };\n\n\t  Helpers.prototype.setPrefixedStyle = function(el, name, value) {\n\t    (name === 'transform') && (el.style[\"\" + this.prefix.css + name] = value);\n\t    return el.style[name] = value;\n\t  };\n\n\t  Helpers.prototype.style = function(el, name, value) {\n\t    var key, keys, len, results;\n\t    if (typeof name === 'object') {\n\t      keys = Object.keys(name);\n\t      len = keys.length;\n\t      results = [];\n\t      while (len--) {\n\t        key = keys[len];\n\t        value = name[key];\n\t        results.push(this.setPrefixedStyle(el, key, value));\n\t      }\n\t      return results;\n\t    } else {\n\t      return this.setPrefixedStyle(el, name, value);\n\t    }\n\t  };\n\n\t  Helpers.prototype.prepareForLog = function(args) {\n\t    args = Array.prototype.slice.apply(args);\n\t    args.unshift('::');\n\t    args.unshift(this.logBadgeCss);\n\t    args.unshift('%cmo·js%c');\n\t    return args;\n\t  };\n\n\t  Helpers.prototype.log = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.log.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.warn = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.warn.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.error = function() {\n\t    if (mojs.isDebug === false) {\n\t      return;\n\t    }\n\t    return console.error.apply(console, this.prepareForLog(arguments));\n\t  };\n\n\t  Helpers.prototype.parseUnit = function(value) {\n\t    var amount, isStrict, ref, regex, returnVal, unit;\n\t    if (typeof value === 'number') {\n\t      return returnVal = {\n\t        unit: 'px',\n\t        isStrict: false,\n\t        value: value,\n\t        string: value === 0 ? \"\" + value : value + \"px\"\n\t      };\n\t    } else if (typeof value === 'string') {\n\t      regex = /px|%|rem|em|ex|cm|ch|mm|in|pt|pc|vh|vw|vmin|deg/gim;\n\t      unit = (ref = value.match(regex)) != null ? ref[0] : void 0;\n\t      isStrict = true;\n\t      if (!unit) {\n\t        unit = 'px';\n\t        isStrict = false;\n\t      }\n\t      amount = parseFloat(value);\n\t      return returnVal = {\n\t        unit: unit,\n\t        isStrict: isStrict,\n\t        value: amount,\n\t        string: amount === 0 ? \"\" + amount : \"\" + amount + unit\n\t      };\n\t    }\n\t    return value;\n\t  };\n\n\t  Helpers.prototype.bind = function(func, context) {\n\t    var bindArgs, wrapper;\n\t    wrapper = function() {\n\t      var args, unshiftArgs;\n\t      args = Array.prototype.slice.call(arguments);\n\t      unshiftArgs = bindArgs.concat(args);\n\t      return func.apply(context, unshiftArgs);\n\t    };\n\t    bindArgs = Array.prototype.slice.call(arguments, 2);\n\t    return wrapper;\n\t  };\n\n\t  Helpers.prototype.getRadialPoint = function(o) {\n\t    var point, radAngle, radiusX, radiusY;\n\t    if (o == null) {\n\t      o = {};\n\t    }\n\t    radAngle = (o.angle - 90) * 0.017453292519943295;\n\t    radiusX = o.radiusX != null ? o.radiusX : o.radius;\n\t    radiusY = o.radiusY != null ? o.radiusY : o.radius;\n\t    return point = {\n\t      x: o.center.x + (Math.cos(radAngle) * radiusX),\n\t      y: o.center.y + (Math.sin(radAngle) * radiusY)\n\t    };\n\t  };\n\n\t  Helpers.prototype.getPrefix = function() {\n\t    var dom, pre, styles, v;\n\t    styles = window.getComputedStyle(document.documentElement, \"\");\n\t    v = Array.prototype.slice.call(styles).join(\"\").match(/-(moz|webkit|ms)-/);\n\t    pre = (v || (styles.OLink === \"\" && [\"\", \"o\"]))[1];\n\t    dom = \"WebKit|Moz|MS|O\".match(new RegExp(\"(\" + pre + \")\", \"i\"))[1];\n\t    return {\n\t      dom: dom,\n\t      lowercase: pre,\n\t      css: \"-\" + pre + \"-\",\n\t      js: pre[0].toUpperCase() + pre.substr(1)\n\t    };\n\t  };\n\n\t  Helpers.prototype.strToArr = function(string) {\n\t    var arr;\n\t    arr = [];\n\t    if (typeof string === 'number' && !isNaN(string)) {\n\t      arr.push(this.parseUnit(string));\n\t      return arr;\n\t    }\n\t    string.trim().split(/\\s+/gim).forEach((function(_this) {\n\t      return function(str) {\n\t        return arr.push(_this.parseUnit(_this.parseIfRand(str)));\n\t      };\n\t    })(this));\n\t    return arr;\n\t  };\n\n\t  Helpers.prototype.calcArrDelta = function(arr1, arr2) {\n\t    var delta, i, j, len1, num;\n\t    delta = [];\n\t    for (i = j = 0, len1 = arr1.length; j < len1; i = ++j) {\n\t      num = arr1[i];\n\t      delta[i] = this.parseUnit(\"\" + (arr2[i].value - arr1[i].value) + arr2[i].unit);\n\t    }\n\t    return delta;\n\t  };\n\n\t  Helpers.prototype.isArray = function(variable) {\n\t    return variable instanceof Array;\n\t  };\n\n\t  Helpers.prototype.normDashArrays = function(arr1, arr2) {\n\t    var arr1Len, arr2Len, currItem, i, j, k, lenDiff, ref, ref1, startI;\n\t    arr1Len = arr1.length;\n\t    arr2Len = arr2.length;\n\t    if (arr1Len > arr2Len) {\n\t      lenDiff = arr1Len - arr2Len;\n\t      startI = arr2.length;\n\t      for (i = j = 0, ref = lenDiff; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t        currItem = i + startI;\n\t        arr2.push(this.parseUnit(\"0\" + arr1[currItem].unit));\n\t      }\n\t    } else if (arr2Len > arr1Len) {\n\t      lenDiff = arr2Len - arr1Len;\n\t      startI = arr1.length;\n\t      for (i = k = 0, ref1 = lenDiff; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n\t        currItem = i + startI;\n\t        arr1.push(this.parseUnit(\"0\" + arr2[currItem].unit));\n\t      }\n\t    }\n\t    return [arr1, arr2];\n\t  };\n\n\t  Helpers.prototype.makeColorObj = function(color) {\n\t    var alpha, b, colorObj, g, isRgb, r, regexString1, regexString2, result, rgbColor;\n\t    if (color[0] === '#') {\n\t      result = /^#?([a-f\\d]{1,2})([a-f\\d]{1,2})([a-f\\d]{1,2})$/i.exec(color);\n\t      colorObj = {};\n\t      if (result) {\n\t        r = result[1].length === 2 ? result[1] : result[1] + result[1];\n\t        g = result[2].length === 2 ? result[2] : result[2] + result[2];\n\t        b = result[3].length === 2 ? result[3] : result[3] + result[3];\n\t        colorObj = {\n\t          r: parseInt(r, 16),\n\t          g: parseInt(g, 16),\n\t          b: parseInt(b, 16),\n\t          a: 1\n\t        };\n\t      }\n\t    }\n\t    if (color[0] !== '#') {\n\t      isRgb = color[0] === 'r' && color[1] === 'g' && color[2] === 'b';\n\t      if (isRgb) {\n\t        rgbColor = color;\n\t      }\n\t      if (!isRgb) {\n\t        rgbColor = !this.shortColors[color] ? (this.div.style.color = color, this.computedStyle(this.div).color) : this.shortColors[color];\n\t      }\n\t      regexString1 = '^rgba?\\\\((\\\\d{1,3}),\\\\s?(\\\\d{1,3}),';\n\t      regexString2 = '\\\\s?(\\\\d{1,3}),?\\\\s?(\\\\d{1}|0?\\\\.\\\\d{1,})?\\\\)$';\n\t      result = new RegExp(regexString1 + regexString2, 'gi').exec(rgbColor);\n\t      colorObj = {};\n\t      alpha = parseFloat(result[4] || 1);\n\t      if (result) {\n\t        colorObj = {\n\t          r: parseInt(result[1], 10),\n\t          g: parseInt(result[2], 10),\n\t          b: parseInt(result[3], 10),\n\t          a: (alpha != null) && !isNaN(alpha) ? alpha : 1\n\t        };\n\t      }\n\t    }\n\t    return colorObj;\n\t  };\n\n\t  Helpers.prototype.computedStyle = function(el) {\n\t    return getComputedStyle(el);\n\t  };\n\n\t  Helpers.prototype.capitalize = function(str) {\n\t    if (typeof str !== 'string') {\n\t      throw Error('String expected - nothing to capitalize');\n\t    }\n\t    return str.charAt(0).toUpperCase() + str.substring(1);\n\t  };\n\n\t  Helpers.prototype.parseRand = function(string) {\n\t    var rand, randArr, units;\n\t    randArr = string.split(/rand\\(|\\,|\\)/);\n\t    units = this.parseUnit(randArr[2]);\n\t    rand = this.rand(parseFloat(randArr[1]), parseFloat(randArr[2]));\n\t    if (units.unit && randArr[2].match(units.unit)) {\n\t      return rand + units.unit;\n\t    } else {\n\t      return rand;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseStagger = function(string, index) {\n\t    var base, number, splittedValue, unit, unitValue, value;\n\t    value = string.split(/stagger\\(|\\)$/)[1].toLowerCase();\n\t    splittedValue = value.split(/(rand\\(.*?\\)|[^\\(,\\s]+)(?=\\s*,|\\s*$)/gim);\n\t    value = splittedValue.length > 3 ? (base = this.parseUnit(this.parseIfRand(splittedValue[1])), splittedValue[3]) : (base = this.parseUnit(0), splittedValue[1]);\n\t    value = this.parseIfRand(value);\n\t    unitValue = this.parseUnit(value);\n\t    number = index * unitValue.value + base.value;\n\t    unit = base.isStrict ? base.unit : unitValue.isStrict ? unitValue.unit : '';\n\t    if (unit) {\n\t      return \"\" + number + unit;\n\t    } else {\n\t      return number;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseIfStagger = function(value, i) {\n\t    if (!(typeof value === 'string' && value.match(/stagger/g))) {\n\t      return value;\n\t    } else {\n\t      return this.parseStagger(value, i);\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseIfRand = function(str) {\n\t    if (typeof str === 'string' && str.match(/rand\\(/)) {\n\t      return this.parseRand(str);\n\t    } else {\n\t      return str;\n\t    }\n\t  };\n\n\t  Helpers.prototype.parseDelta = function(key, value, index) {\n\t    var curve, delta, easing, end, endArr, endColorObj, i, j, len1, start, startArr, startColorObj;\n\t    value = this.cloneObj(value);\n\t    easing = value.easing;\n\t    if (easing != null) {\n\t      easing = mojs.easing.parseEasing(easing);\n\t    }\n\t    delete value.easing;\n\t    curve = value.curve;\n\t    if (curve != null) {\n\t      curve = mojs.easing.parseEasing(curve);\n\t    }\n\t    delete value.curve;\n\t    start = Object.keys(value)[0];\n\t    end = value[start];\n\t    delta = {\n\t      start: start\n\t    };\n\t    if (isNaN(parseFloat(start)) && !start.match(/rand\\(/) && !start.match(/stagger\\(/)) {\n\t      if (key === 'strokeLinecap') {\n\t        this.warn(\"Sorry, stroke-linecap property is not animatable yet, using the start(\" + start + \") value instead\", value);\n\t        return delta;\n\t      }\n\t      startColorObj = this.makeColorObj(start);\n\t      endColorObj = this.makeColorObj(end);\n\t      delta = {\n\t        type: 'color',\n\t        name: key,\n\t        start: startColorObj,\n\t        end: endColorObj,\n\t        easing: easing,\n\t        curve: curve,\n\t        delta: {\n\t          r: endColorObj.r - startColorObj.r,\n\t          g: endColorObj.g - startColorObj.g,\n\t          b: endColorObj.b - startColorObj.b,\n\t          a: endColorObj.a - startColorObj.a\n\t        }\n\t      };\n\t    } else if (key === 'strokeDasharray' || key === 'strokeDashoffset' || key === 'origin') {\n\t      startArr = this.strToArr(start);\n\t      endArr = this.strToArr(end);\n\t      this.normDashArrays(startArr, endArr);\n\t      for (i = j = 0, len1 = startArr.length; j < len1; i = ++j) {\n\t        start = startArr[i];\n\t        end = endArr[i];\n\t        this.mergeUnits(start, end, key);\n\t      }\n\t      delta = {\n\t        type: 'array',\n\t        name: key,\n\t        start: startArr,\n\t        end: endArr,\n\t        delta: this.calcArrDelta(startArr, endArr),\n\t        easing: easing,\n\t        curve: curve\n\t      };\n\t    } else {\n\t      if (!this.callbacksMap[key] && !this.tweenOptionMap[key]) {\n\t        if (this.unitOptionMap[key]) {\n\t          end = this.parseUnit(this.parseStringOption(end, index));\n\t          start = this.parseUnit(this.parseStringOption(start, index));\n\t          this.mergeUnits(start, end, key);\n\t          delta = {\n\t            type: 'unit',\n\t            name: key,\n\t            start: start,\n\t            end: end,\n\t            delta: end.value - start.value,\n\t            easing: easing,\n\t            curve: curve\n\t          };\n\t        } else {\n\t          end = parseFloat(this.parseStringOption(end, index));\n\t          start = parseFloat(this.parseStringOption(start, index));\n\t          delta = {\n\t            type: 'number',\n\t            name: key,\n\t            start: start,\n\t            end: end,\n\t            delta: end - start,\n\t            easing: easing,\n\t            curve: curve\n\t          };\n\t        }\n\t      }\n\t    }\n\t    return delta;\n\t  };\n\n\t  Helpers.prototype.mergeUnits = function(start, end, key) {\n\t    if (!end.isStrict && start.isStrict) {\n\t      end.unit = start.unit;\n\t      return end.string = \"\" + end.value + end.unit;\n\t    } else if (end.isStrict && !start.isStrict) {\n\t      start.unit = end.unit;\n\t      return start.string = \"\" + start.value + start.unit;\n\t    } else if (end.isStrict && start.isStrict) {\n\t      if (end.unit !== start.unit) {\n\t        start.unit = end.unit;\n\t        start.string = \"\" + start.value + start.unit;\n\t        return this.warn(\"Two different units were specified on \\\"\" + key + \"\\\" delta property, mo · js will fallback to end \\\"\" + end.unit + \"\\\" unit \");\n\t      }\n\t    }\n\t  };\n\n\t  Helpers.prototype.rand = function(min, max) {\n\t    return (Math.random() * (max - min)) + min;\n\t  };\n\n\t  Helpers.prototype.isDOM = function(o) {\n\t    var isNode;\n\t    if (o == null) {\n\t      return false;\n\t    }\n\t    isNode = typeof o.nodeType === 'number' && typeof o.nodeName === 'string';\n\t    return typeof o === 'object' && isNode;\n\t  };\n\n\t  Helpers.prototype.getChildElements = function(element) {\n\t    var childNodes, children, i;\n\t    childNodes = element.childNodes;\n\t    children = [];\n\t    i = childNodes.length;\n\t    while (i--) {\n\t      if (childNodes[i].nodeType === 1) {\n\t        children.unshift(childNodes[i]);\n\t      }\n\t    }\n\t    return children;\n\t  };\n\n\t  Helpers.prototype.delta = function(start, end) {\n\t    var isType1, isType2, obj, type1, type2;\n\t    type1 = typeof start;\n\t    type2 = typeof end;\n\t    isType1 = type1 === 'string' || type1 === 'number' && !isNaN(start);\n\t    isType2 = type2 === 'string' || type2 === 'number' && !isNaN(end);\n\t    if (!isType1 || !isType2) {\n\t      this.error(\"delta method expects Strings or Numbers at input but got - \" + start + \", \" + end);\n\t      return;\n\t    }\n\t    obj = {};\n\t    obj[start] = end;\n\t    return obj;\n\t  };\n\n\t  Helpers.prototype.getUniqID = function() {\n\t    return ++this.uniqIDs;\n\t  };\n\n\t  Helpers.prototype.parsePath = function(path) {\n\t    var domPath;\n\t    if (typeof path === 'string') {\n\t      if (path.charAt(0).toLowerCase() === 'm') {\n\t        domPath = document.createElementNS(this.NS, 'path');\n\t        domPath.setAttributeNS(null, 'd', path);\n\t        return domPath;\n\t      } else {\n\t        return document.querySelector(path);\n\t      }\n\t    }\n\t    if (path.style) {\n\t      return path;\n\t    }\n\t  };\n\n\t  Helpers.prototype.closeEnough = function(num1, num2, eps) {\n\t    return Math.abs(num1 - num2) < eps;\n\t  };\n\n\t  Helpers.prototype.checkIf3d = function() {\n\t    var div, prefixed, style, tr;\n\t    div = document.createElement('div');\n\t    this.style(div, 'transform', 'translateZ(0)');\n\t    style = div.style;\n\t    prefixed = this.prefix.css + \"transform\";\n\t    tr = style[prefixed] != null ? style[prefixed] : style.transform;\n\t    return tr !== '';\n\t  };\n\n\n\t  /*\n\t    Method to check if variable holds pointer to an object.\n\t    @param {Any} Variable to test\n\t    @returns {Boolean} If variable is object.\n\t   */\n\n\t  Helpers.prototype.isObject = function(variable) {\n\t    return variable !== null && typeof variable === 'object';\n\t  };\n\n\n\t  /*\n\t    Method to get first value of the object.\n\t    Used to get end value on ∆s.\n\t    @param {Object} Object to get the value of.\n\t    @returns {Any} The value of the first object' property.\n\t   */\n\n\t  Helpers.prototype.getDeltaEnd = function(obj) {\n\t    var key;\n\t    key = Object.keys(obj)[0];\n\t    return obj[key];\n\t  };\n\n\n\t  /*\n\t    Method to get first key of the object.\n\t    Used to get start value on ∆s.\n\t    @param {Object} Object to get the value of.\n\t    @returns {String} The key of the first object' property.\n\t   */\n\n\t  Helpers.prototype.getDeltaStart = function(obj) {\n\t    var key;\n\t    key = Object.keys(obj)[0];\n\t    return key;\n\t  };\n\n\n\t  /*\n\t    Method to check if propery exists in callbacksMap or tweenOptionMap.\n\t    @param {String} Property name to check for\n\t    @returns {Boolean} If property is tween property.\n\t   */\n\n\t  Helpers.prototype.isTweenProp = function(keyName) {\n\t    return this.tweenOptionMap[keyName] || this.callbacksMap[keyName];\n\t  };\n\n\n\t  /*\n\t    Method to parse string property value\n\t    which can include both `rand` and `stagger `\n\t    value in various positions.\n\t    @param {String} Property name to check for.\n\t    @param {Number} Optional index for stagger.\n\t    @returns {Number} Parsed option value.\n\t   */\n\n\t  Helpers.prototype.parseStringOption = function(value, index) {\n\t    if (index == null) {\n\t      index = 0;\n\t    }\n\t    if (typeof value === 'string') {\n\t      value = this.parseIfStagger(value, index);\n\t      value = this.parseIfRand(value);\n\t    }\n\t    return value;\n\t  };\n\n\n\t  /*\n\t    Method to get the last item of array.\n\t    @private\n\t    @param {Array} Array to get the last item in.\n\t    @returns {Any} The last item of array.\n\t   */\n\n\t  Helpers.prototype.getLastItem = function(arr) {\n\t    return arr[arr.length - 1];\n\t  };\n\n\n\t  /*\n\t    Method parse HTMLElement.\n\t    @private\n\t    @param {String, Object} Selector string or HTMLElement.\n\t    @returns {Object} HTMLElement.\n\t   */\n\n\t  Helpers.prototype.parseEl = function(el) {\n\t    if (h.isDOM(el)) {\n\t      return el;\n\t    } else if (typeof el === 'string') {\n\t      el = document.querySelector(el);\n\t    }\n\t    if (el === null) {\n\t      h.error(\"Can't parse HTML element: \", el);\n\t    }\n\t    return el;\n\t  };\n\n\n\t  /*\n\t    Method force compositor layer on HTMLElement.\n\t    @private\n\t    @param {Object} HTMLElement.\n\t    @returns {Object} HTMLElement.\n\t   */\n\n\t  Helpers.prototype.force3d = function(el) {\n\t    this.setPrefixedStyle(el, 'backface-visibility', 'hidden');\n\t    return el;\n\t  };\n\n\n\t  /*\n\t    Method to check if value is delta.\n\t    @private\n\t    @param {Any} Property to check.\n\t    @returns {Boolean} If value is delta.\n\t   */\n\n\t  Helpers.prototype.isDelta = function(optionsValue) {\n\t    var isObject;\n\t    isObject = this.isObject(optionsValue);\n\t    isObject = isObject && !optionsValue.unit;\n\t    return !(!isObject || this.isArray(optionsValue) || this.isDOM(optionsValue));\n\t  };\n\n\t  return Helpers;\n\n\t})();\n\n\th = new Helpers;\n\n\tmodule.exports = h;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Bit, BitsMap, Circle, Cross, Curve, Custom, Equal, Line, Polygon, Rect, Zigzag, h;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tCustom = __webpack_require__(36)[\"default\"] || __webpack_require__(36);\n\n\tCircle = __webpack_require__(37);\n\n\tLine = __webpack_require__(38);\n\n\tZigzag = __webpack_require__(39);\n\n\tRect = __webpack_require__(35);\n\n\tPolygon = __webpack_require__(40);\n\n\tCross = __webpack_require__(41);\n\n\tCurve = __webpack_require__(42)[\"default\"] || __webpack_require__(42);\n\n\tEqual = __webpack_require__(43);\n\n\th = __webpack_require__(19);\n\n\tBitsMap = (function() {\n\t  function BitsMap() {\n\t    this.addShape = h.bind(this.addShape, this);\n\t  }\n\n\t  BitsMap.prototype.bit = Bit;\n\n\t  BitsMap.prototype.custom = Custom;\n\n\t  BitsMap.prototype.circle = Circle;\n\n\t  BitsMap.prototype.line = Line;\n\n\t  BitsMap.prototype.zigzag = Zigzag;\n\n\t  BitsMap.prototype.rect = Rect;\n\n\t  BitsMap.prototype.polygon = Polygon;\n\n\t  BitsMap.prototype.cross = Cross;\n\n\t  BitsMap.prototype.equal = Equal;\n\n\t  BitsMap.prototype.curve = Curve;\n\n\t  BitsMap.prototype.getShape = function(name) {\n\t    return this[name] || h.error(\"no \\\"\" + name + \"\\\" shape available yet, please choose from this list:\", ['circle', 'line', 'zigzag', 'rect', 'polygon', 'cross', 'equal', 'curve']);\n\t  };\n\n\n\t  /*\n\t    Method to add shape to the map.\n\t    @public\n\t    @param {String} Name of the shape module.\n\t    @param {Object} Shape module class.\n\t   */\n\n\t  BitsMap.prototype.addShape = function(name, Module) {\n\t    return this[name] = Module;\n\t  };\n\n\t  return BitsMap;\n\n\t})();\n\n\tmodule.exports = new BitsMap;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MotionPath, Timeline, Tween, h, resize,\n\t  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n\th = __webpack_require__(19);\n\n\tresize = __webpack_require__(34);\n\n\tTween = __webpack_require__(8)[\"default\"];\n\n\tTimeline = __webpack_require__(9)[\"default\"];\n\n\tMotionPath = (function() {\n\t  MotionPath.prototype.defaults = {\n\t    path: null,\n\t    curvature: {\n\t      x: '75%',\n\t      y: '50%'\n\t    },\n\t    isCompositeLayer: true,\n\t    delay: 0,\n\t    duration: 1000,\n\t    easing: null,\n\t    repeat: 0,\n\t    yoyo: false,\n\t    onStart: null,\n\t    onComplete: null,\n\t    onUpdate: null,\n\t    offsetX: 0,\n\t    offsetY: 0,\n\t    angleOffset: null,\n\t    pathStart: 0,\n\t    pathEnd: 1,\n\t    motionBlur: 0,\n\t    transformOrigin: null,\n\t    isAngle: false,\n\t    isReverse: false,\n\t    isRunLess: false,\n\t    isPresetPosition: true\n\t  };\n\n\t  function MotionPath(o1) {\n\t    this.o = o1 != null ? o1 : {};\n\t    this.calcHeight = bind(this.calcHeight, this);\n\t    if (this.vars()) {\n\t      return;\n\t    }\n\t    this.createTween();\n\t    this;\n\t  }\n\n\t  MotionPath.prototype.vars = function() {\n\t    this.getScaler = h.bind(this.getScaler, this);\n\t    this.resize = resize;\n\t    this.props = h.cloneObj(this.defaults);\n\t    this.extendOptions(this.o);\n\t    this.isMotionBlurReset = h.isSafari || h.isIE;\n\t    this.isMotionBlurReset && (this.props.motionBlur = 0);\n\t    this.history = [h.cloneObj(this.props)];\n\t    return this.postVars();\n\t  };\n\n\t  MotionPath.prototype.curveToPath = function(o) {\n\t    var angle, curvature, curvatureX, curvatureY, curvePoint, curveXPoint, dX, dY, endPoint, path, percent, radius, start;\n\t    path = document.createElementNS(h.NS, 'path');\n\t    start = o.start;\n\t    endPoint = {\n\t      x: start.x + o.shift.x,\n\t      y: start.x + o.shift.y\n\t    };\n\t    curvature = o.curvature;\n\t    dX = o.shift.x;\n\t    dY = o.shift.y;\n\t    radius = Math.sqrt(dX * dX + dY * dY);\n\t    percent = radius / 100;\n\t    angle = Math.atan(dY / dX) * (180 / Math.PI) + 90;\n\t    if (o.shift.x < 0) {\n\t      angle = angle + 180;\n\t    }\n\t    curvatureX = h.parseUnit(curvature.x);\n\t    curvatureX = curvatureX.unit === '%' ? curvatureX.value * percent : curvatureX.value;\n\t    curveXPoint = h.getRadialPoint({\n\t      center: {\n\t        x: start.x,\n\t        y: start.y\n\t      },\n\t      radius: curvatureX,\n\t      angle: angle\n\t    });\n\t    curvatureY = h.parseUnit(curvature.y);\n\t    curvatureY = curvatureY.unit === '%' ? curvatureY.value * percent : curvatureY.value;\n\t    curvePoint = h.getRadialPoint({\n\t      center: {\n\t        x: curveXPoint.x,\n\t        y: curveXPoint.y\n\t      },\n\t      radius: curvatureY,\n\t      angle: angle + 90\n\t    });\n\t    path.setAttribute('d', \"M\" + start.x + \",\" + start.y + \" Q\" + curvePoint.x + \",\" + curvePoint.y + \" \" + endPoint.x + \",\" + endPoint.y);\n\t    return path;\n\t  };\n\n\t  MotionPath.prototype.postVars = function() {\n\t    this.props.pathStart = h.clamp(this.props.pathStart, 0, 1);\n\t    this.props.pathEnd = h.clamp(this.props.pathEnd, this.props.pathStart, 1);\n\t    this.angle = 0;\n\t    this.speedX = 0;\n\t    this.speedY = 0;\n\t    this.blurX = 0;\n\t    this.blurY = 0;\n\t    this.prevCoords = {};\n\t    this.blurAmount = 20;\n\t    this.props.motionBlur = h.clamp(this.props.motionBlur, 0, 1);\n\t    this.onUpdate = this.props.onUpdate;\n\t    if (!this.o.el) {\n\t      h.error('Missed \"el\" option. It could be a selector, DOMNode or another module.');\n\t      return true;\n\t    }\n\t    this.el = this.parseEl(this.props.el);\n\t    this.props.motionBlur > 0 && this.createFilter();\n\t    this.path = this.getPath();\n\t    if (!this.path.getAttribute('d')) {\n\t      h.error('Path has no coordinates to work with, aborting');\n\t      return true;\n\t    }\n\t    this.len = this.path.getTotalLength();\n\t    this.slicedLen = this.len * (this.props.pathEnd - this.props.pathStart);\n\t    this.startLen = this.props.pathStart * this.len;\n\t    this.fill = this.props.fill;\n\t    if (this.fill != null) {\n\t      this.container = this.parseEl(this.props.fill.container);\n\t      this.fillRule = this.props.fill.fillRule || 'all';\n\t      this.getScaler();\n\t      if (this.container != null) {\n\t        this.removeEvent(this.container, 'onresize', this.getScaler);\n\t        return this.addEvent(this.container, 'onresize', this.getScaler);\n\t      }\n\t    }\n\t  };\n\n\t  MotionPath.prototype.addEvent = function(el, type, handler) {\n\t    return el.addEventListener(type, handler, false);\n\t  };\n\n\t  MotionPath.prototype.removeEvent = function(el, type, handler) {\n\t    return el.removeEventListener(type, handler, false);\n\t  };\n\n\t  MotionPath.prototype.createFilter = function() {\n\t    var div, svg;\n\t    div = document.createElement('div');\n\t    this.filterID = \"filter-\" + (h.getUniqID());\n\t    div.innerHTML = \"<svg id=\\\"svg-\" + this.filterID + \"\\\"\\n    style=\\\"visibility:hidden; width:0px; height:0px\\\">\\n  <filter id=\\\"\" + this.filterID + \"\\\" y=\\\"-20\\\" x=\\\"-20\\\" width=\\\"40\\\" height=\\\"40\\\">\\n    <feOffset\\n      id=\\\"blur-offset\\\" in=\\\"SourceGraphic\\\"\\n      dx=\\\"0\\\" dy=\\\"0\\\" result=\\\"offset2\\\"></feOffset>\\n    <feGaussianblur\\n      id=\\\"blur\\\" in=\\\"offset2\\\"\\n      stdDeviation=\\\"0,0\\\" result=\\\"blur2\\\"></feGaussianblur>\\n    <feMerge>\\n      <feMergeNode in=\\\"SourceGraphic\\\"></feMergeNode>\\n      <feMergeNode in=\\\"blur2\\\"></feMergeNode>\\n    </feMerge>\\n  </filter>\\n</svg>\";\n\t    svg = div.querySelector(\"#svg-\" + this.filterID);\n\t    this.filter = svg.querySelector('#blur');\n\t    this.filterOffset = svg.querySelector('#blur-offset');\n\t    document.body.insertBefore(svg, document.body.firstChild);\n\t    this.el.style['filter'] = \"url(#\" + this.filterID + \")\";\n\t    return this.el.style[h.prefix.css + \"filter\"] = \"url(#\" + this.filterID + \")\";\n\t  };\n\n\t  MotionPath.prototype.parseEl = function(el) {\n\t    if (typeof el === 'string') {\n\t      return document.querySelector(el);\n\t    }\n\t    if (el instanceof HTMLElement) {\n\t      return el;\n\t    }\n\t    if (el._setProp != null) {\n\t      this.isModule = true;\n\t      return el;\n\t    }\n\t  };\n\n\t  MotionPath.prototype.getPath = function() {\n\t    var path;\n\t    path = h.parsePath(this.props.path);\n\t    if (path) {\n\t      return path;\n\t    }\n\t    if (this.props.path.x || this.props.path.y) {\n\t      return this.curveToPath({\n\t        start: {\n\t          x: 0,\n\t          y: 0\n\t        },\n\t        shift: {\n\t          x: this.props.path.x || 0,\n\t          y: this.props.path.y || 0\n\t        },\n\t        curvature: {\n\t          x: this.props.curvature.x || this.defaults.curvature.x,\n\t          y: this.props.curvature.y || this.defaults.curvature.y\n\t        }\n\t      });\n\t    }\n\t  };\n\n\t  MotionPath.prototype.getScaler = function() {\n\t    var end, size, start;\n\t    this.cSize = {\n\t      width: this.container.offsetWidth || 0,\n\t      height: this.container.offsetHeight || 0\n\t    };\n\t    start = this.path.getPointAtLength(0);\n\t    end = this.path.getPointAtLength(this.len);\n\t    size = {};\n\t    this.scaler = {};\n\t    size.width = end.x >= start.x ? end.x - start.x : start.x - end.x;\n\t    size.height = end.y >= start.y ? end.y - start.y : start.y - end.y;\n\t    switch (this.fillRule) {\n\t      case 'all':\n\t        this.calcWidth(size);\n\t        return this.calcHeight(size);\n\t      case 'width':\n\t        this.calcWidth(size);\n\t        return this.scaler.y = this.scaler.x;\n\t      case 'height':\n\t        this.calcHeight(size);\n\t        return this.scaler.x = this.scaler.y;\n\t    }\n\t  };\n\n\t  MotionPath.prototype.calcWidth = function(size) {\n\t    this.scaler.x = this.cSize.width / size.width;\n\t    return !isFinite(this.scaler.x) && (this.scaler.x = 1);\n\t  };\n\n\t  MotionPath.prototype.calcHeight = function(size) {\n\t    this.scaler.y = this.cSize.height / size.height;\n\t    return !isFinite(this.scaler.y) && (this.scaler.y = 1);\n\t  };\n\n\t  MotionPath.prototype.run = function(o) {\n\t    var fistItem, key, value;\n\t    if (o) {\n\t      fistItem = this.history[0];\n\t      for (key in o) {\n\t        value = o[key];\n\t        if (h.callbacksMap[key] || h.tweenOptionMap[key]) {\n\t          h.warn(\"the property \\\"\" + key + \"\\\" property can not be overridden on run yet\");\n\t          delete o[key];\n\t        } else {\n\t          this.history[0][key] = value;\n\t        }\n\t      }\n\t      this.tuneOptions(o);\n\t    }\n\t    return this.startTween();\n\t  };\n\n\t  MotionPath.prototype.createTween = function() {\n\t    this.tween = new Tween({\n\t      duration: this.props.duration,\n\t      delay: this.props.delay,\n\t      yoyo: this.props.yoyo,\n\t      repeat: this.props.repeat,\n\t      easing: this.props.easing,\n\t      onStart: (function(_this) {\n\t        return function() {\n\t          var ref;\n\t          return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;\n\t        };\n\t      })(this),\n\t      onComplete: (function(_this) {\n\t        return function() {\n\t          var ref;\n\t          _this.props.motionBlur && _this.setBlur({\n\t            blur: {\n\t              x: 0,\n\t              y: 0\n\t            },\n\t            offset: {\n\t              x: 0,\n\t              y: 0\n\t            }\n\t          });\n\t          return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;\n\t        };\n\t      })(this),\n\t      onUpdate: (function(_this) {\n\t        return function(p) {\n\t          return _this.setProgress(p);\n\t        };\n\t      })(this),\n\t      onFirstUpdate: (function(_this) {\n\t        return function(isForward, isYoyo) {\n\t          if (!isForward) {\n\t            return _this.history.length > 1 && _this.tuneOptions(_this.history[0]);\n\t          }\n\t        };\n\t      })(this)\n\t    });\n\t    this.timeline = new Timeline;\n\t    this.timeline.add(this.tween);\n\t    !this.props.isRunLess && this.startTween();\n\t    return this.props.isPresetPosition && this.setProgress(0, true);\n\t  };\n\n\t  MotionPath.prototype.startTween = function() {\n\t    return setTimeout(((function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.timeline) != null ? ref.play() : void 0;\n\t      };\n\t    })(this)), 1);\n\t  };\n\n\t  MotionPath.prototype.setProgress = function(p, isInit) {\n\t    var len, point, x, y;\n\t    len = this.startLen + (!this.props.isReverse ? p * this.slicedLen : (1 - p) * this.slicedLen);\n\t    point = this.path.getPointAtLength(len);\n\t    x = point.x + this.props.offsetX;\n\t    y = point.y + this.props.offsetY;\n\t    this._getCurrentAngle(point, len, p);\n\t    this._setTransformOrigin(p);\n\t    this._setTransform(x, y, p, isInit);\n\t    return this.props.motionBlur && this.makeMotionBlur(x, y);\n\t  };\n\n\t  MotionPath.prototype.setElPosition = function(x, y, p) {\n\t    var composite, isComposite, rotate, transform;\n\t    rotate = this.angle !== 0 ? \"rotate(\" + this.angle + \"deg)\" : '';\n\t    isComposite = this.props.isCompositeLayer && h.is3d;\n\t    composite = isComposite ? 'translateZ(0)' : '';\n\t    transform = \"translate(\" + x + \"px,\" + y + \"px) \" + rotate + \" \" + composite;\n\t    return h.setPrefixedStyle(this.el, 'transform', transform);\n\t  };\n\n\t  MotionPath.prototype.setModulePosition = function(x, y) {\n\t    this.el._setProp({\n\t      shiftX: x + \"px\",\n\t      shiftY: y + \"px\",\n\t      angle: this.angle\n\t    });\n\t    return this.el._draw();\n\t  };\n\n\t  MotionPath.prototype._getCurrentAngle = function(point, len, p) {\n\t    var atan, isTransformFunOrigin, prevPoint, x1, x2;\n\t    isTransformFunOrigin = typeof this.props.transformOrigin === 'function';\n\t    if (this.props.isAngle || (this.props.angleOffset != null) || isTransformFunOrigin) {\n\t      prevPoint = this.path.getPointAtLength(len - 1);\n\t      x1 = point.y - prevPoint.y;\n\t      x2 = point.x - prevPoint.x;\n\t      atan = Math.atan(x1 / x2);\n\t      !isFinite(atan) && (atan = 0);\n\t      this.angle = atan * h.RAD_TO_DEG;\n\t      if ((typeof this.props.angleOffset) !== 'function') {\n\t        return this.angle += this.props.angleOffset || 0;\n\t      } else {\n\t        return this.angle = this.props.angleOffset.call(this, this.angle, p);\n\t      }\n\t    } else {\n\t      return this.angle = 0;\n\t    }\n\t  };\n\n\t  MotionPath.prototype._setTransform = function(x, y, p, isInit) {\n\t    var transform;\n\t    if (this.scaler) {\n\t      x *= this.scaler.x;\n\t      y *= this.scaler.y;\n\t    }\n\t    transform = null;\n\t    if (!isInit) {\n\t      transform = typeof this.onUpdate === \"function\" ? this.onUpdate(p, {\n\t        x: x,\n\t        y: y,\n\t        angle: this.angle\n\t      }) : void 0;\n\t    }\n\t    if (this.isModule) {\n\t      return this.setModulePosition(x, y);\n\t    } else {\n\t      if (typeof transform !== 'string') {\n\t        return this.setElPosition(x, y, p);\n\t      } else {\n\t        return h.setPrefixedStyle(this.el, 'transform', transform);\n\t      }\n\t    }\n\t  };\n\n\t  MotionPath.prototype._setTransformOrigin = function(p) {\n\t    var isTransformFunOrigin, tOrigin;\n\t    if (this.props.transformOrigin) {\n\t      isTransformFunOrigin = typeof this.props.transformOrigin === 'function';\n\t      tOrigin = !isTransformFunOrigin ? this.props.transformOrigin : this.props.transformOrigin(this.angle, p);\n\t      return h.setPrefixedStyle(this.el, 'transform-origin', tOrigin);\n\t    }\n\t  };\n\n\t  MotionPath.prototype.makeMotionBlur = function(x, y) {\n\t    var absoluteAngle, coords, dX, dY, signX, signY, tailAngle;\n\t    tailAngle = 0;\n\t    signX = 1;\n\t    signY = 1;\n\t    if ((this.prevCoords.x == null) || (this.prevCoords.y == null)) {\n\t      this.speedX = 0;\n\t      this.speedY = 0;\n\t    } else {\n\t      dX = x - this.prevCoords.x;\n\t      dY = y - this.prevCoords.y;\n\t      if (dX > 0) {\n\t        signX = -1;\n\t      }\n\t      if (signX < 0) {\n\t        signY = -1;\n\t      }\n\t      this.speedX = Math.abs(dX);\n\t      this.speedY = Math.abs(dY);\n\t      tailAngle = Math.atan(dY / dX) * (180 / Math.PI) + 90;\n\t    }\n\t    absoluteAngle = tailAngle - this.angle;\n\t    coords = this.angToCoords(absoluteAngle);\n\t    this.blurX = h.clamp((this.speedX / 16) * this.props.motionBlur, 0, 1);\n\t    this.blurY = h.clamp((this.speedY / 16) * this.props.motionBlur, 0, 1);\n\t    this.setBlur({\n\t      blur: {\n\t        x: 3 * this.blurX * this.blurAmount * Math.abs(coords.x),\n\t        y: 3 * this.blurY * this.blurAmount * Math.abs(coords.y)\n\t      },\n\t      offset: {\n\t        x: 3 * signX * this.blurX * coords.x * this.blurAmount,\n\t        y: 3 * signY * this.blurY * coords.y * this.blurAmount\n\t      }\n\t    });\n\t    this.prevCoords.x = x;\n\t    return this.prevCoords.y = y;\n\t  };\n\n\t  MotionPath.prototype.setBlur = function(o) {\n\t    if (!this.isMotionBlurReset) {\n\t      this.filter.setAttribute('stdDeviation', o.blur.x + \",\" + o.blur.y);\n\t      this.filterOffset.setAttribute('dx', o.offset.x);\n\t      return this.filterOffset.setAttribute('dy', o.offset.y);\n\t    }\n\t  };\n\n\t  MotionPath.prototype.extendDefaults = function(o) {\n\t    var key, results, value;\n\t    results = [];\n\t    for (key in o) {\n\t      value = o[key];\n\t      results.push(this[key] = value);\n\t    }\n\t    return results;\n\t  };\n\n\t  MotionPath.prototype.extendOptions = function(o) {\n\t    var key, results, value;\n\t    results = [];\n\t    for (key in o) {\n\t      value = o[key];\n\t      results.push(this.props[key] = value);\n\t    }\n\t    return results;\n\t  };\n\n\t  MotionPath.prototype.then = function(o) {\n\t    var it, key, opts, prevOptions, value;\n\t    prevOptions = this.history[this.history.length - 1];\n\t    opts = {};\n\t    for (key in prevOptions) {\n\t      value = prevOptions[key];\n\t      if (!h.callbacksMap[key] && !h.tweenOptionMap[key] || key === 'duration') {\n\t        if (o[key] == null) {\n\t          o[key] = value;\n\t        }\n\t      } else {\n\t        if (o[key] == null) {\n\t          o[key] = void 0;\n\t        }\n\t      }\n\t      if (h.tweenOptionMap[key]) {\n\t        opts[key] = key !== 'duration' ? o[key] : o[key] != null ? o[key] : prevOptions[key];\n\t      }\n\t    }\n\t    this.history.push(o);\n\t    it = this;\n\t    opts.onUpdate = (function(_this) {\n\t      return function(p) {\n\t        return _this.setProgress(p);\n\t      };\n\t    })(this);\n\t    opts.onStart = (function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.props.onStart) != null ? ref.apply(_this) : void 0;\n\t      };\n\t    })(this);\n\t    opts.onComplete = (function(_this) {\n\t      return function() {\n\t        var ref;\n\t        return (ref = _this.props.onComplete) != null ? ref.apply(_this) : void 0;\n\t      };\n\t    })(this);\n\t    opts.onFirstUpdate = function() {\n\t      return it.tuneOptions(it.history[this.index]);\n\t    };\n\t    opts.isChained = !o.delay;\n\t    this.timeline.append(new Tween(opts));\n\t    return this;\n\t  };\n\n\t  MotionPath.prototype.tuneOptions = function(o) {\n\t    this.extendOptions(o);\n\t    return this.postVars();\n\t  };\n\n\t  MotionPath.prototype.angToCoords = function(angle) {\n\t    var radAngle, x, y;\n\t    angle = angle % 360;\n\t    radAngle = ((angle - 90) * Math.PI) / 180;\n\t    x = Math.cos(radAngle);\n\t    y = Math.sin(radAngle);\n\t    x = x < 0 ? Math.max(x, -0.7) : Math.min(x, .7);\n\t    y = y < 0 ? Math.max(y, -0.7) : Math.min(y, .7);\n\t    return {\n\t      x: x * 1.428571429,\n\t      y: y * 1.428571429\n\t    };\n\t  };\n\n\t  return MotionPath;\n\n\t})();\n\n\tmodule.exports = MotionPath;\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Easing, PI, PathEasing, approximate, bezier, easing, h, mix, sin;\n\n\tbezier = __webpack_require__(44);\n\n\tPathEasing = __webpack_require__(45);\n\n\tmix = __webpack_require__(46);\n\n\th = __webpack_require__(19);\n\n\tapproximate = __webpack_require__(47)[\"default\"] || __webpack_require__(47);\n\n\tsin = Math.sin;\n\n\tPI = Math.PI;\n\n\tEasing = (function() {\n\t  function Easing() {}\n\n\t  Easing.prototype.bezier = bezier;\n\n\t  Easing.prototype.PathEasing = PathEasing;\n\n\t  Easing.prototype.path = (new PathEasing('creator')).create;\n\n\t  Easing.prototype.approximate = approximate;\n\n\t  Easing.prototype.inverse = function(p) {\n\t    return 1 - p;\n\t  };\n\n\t  Easing.prototype.linear = {\n\t    none: function(k) {\n\t      return k;\n\t    }\n\t  };\n\n\t  Easing.prototype.ease = {\n\t    \"in\": bezier.apply(Easing, [0.42, 0, 1, 1]),\n\t    out: bezier.apply(Easing, [0, 0, 0.58, 1]),\n\t    inout: bezier.apply(Easing, [0.42, 0, 0.58, 1])\n\t  };\n\n\t  Easing.prototype.sin = {\n\t    \"in\": function(k) {\n\t      return 1 - Math.cos(k * PI / 2);\n\t    },\n\t    out: function(k) {\n\t      return sin(k * PI / 2);\n\t    },\n\t    inout: function(k) {\n\t      return 0.5 * (1 - Math.cos(PI * k));\n\t    }\n\t  };\n\n\t  Easing.prototype.quad = {\n\t    \"in\": function(k) {\n\t      return k * k;\n\t    },\n\t    out: function(k) {\n\t      return k * (2 - k);\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k;\n\t      }\n\t      return -0.5 * (--k * (k - 2) - 1);\n\t    }\n\t  };\n\n\t  Easing.prototype.cubic = {\n\t    \"in\": function(k) {\n\t      return k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return --k * k * k + 1;\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k;\n\t      }\n\t      return 0.5 * ((k -= 2) * k * k + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.quart = {\n\t    \"in\": function(k) {\n\t      return k * k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return 1 - (--k * k * k * k);\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k * k;\n\t      }\n\t      return -0.5 * ((k -= 2) * k * k * k - 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.quint = {\n\t    \"in\": function(k) {\n\t      return k * k * k * k * k;\n\t    },\n\t    out: function(k) {\n\t      return --k * k * k * k * k + 1;\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * k * k * k * k * k;\n\t      }\n\t      return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.expo = {\n\t    \"in\": function(k) {\n\t      if (k === 0) {\n\t        return 0;\n\t      } else {\n\t        return Math.pow(1024, k - 1);\n\t      }\n\t    },\n\t    out: function(k) {\n\t      if (k === 1) {\n\t        return 1;\n\t      } else {\n\t        return 1 - Math.pow(2, -10 * k);\n\t      }\n\t    },\n\t    inout: function(k) {\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * Math.pow(1024, k - 1);\n\t      }\n\t      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.circ = {\n\t    \"in\": function(k) {\n\t      return 1 - Math.sqrt(1 - k * k);\n\t    },\n\t    out: function(k) {\n\t      return Math.sqrt(1 - (--k * k));\n\t    },\n\t    inout: function(k) {\n\t      if ((k *= 2) < 1) {\n\t        return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t      }\n\t      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t    }\n\t  };\n\n\t  Easing.prototype.back = {\n\t    \"in\": function(k) {\n\t      var s;\n\t      s = 1.70158;\n\t      return k * k * ((s + 1) * k - s);\n\t    },\n\t    out: function(k) {\n\t      var s;\n\t      s = 1.70158;\n\t      return --k * k * ((s + 1) * k + s) + 1;\n\t    },\n\t    inout: function(k) {\n\t      var s;\n\t      s = 1.70158 * 1.525;\n\t      if ((k *= 2) < 1) {\n\t        return 0.5 * (k * k * ((s + 1) * k - s));\n\t      }\n\t      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t    }\n\t  };\n\n\t  Easing.prototype.elastic = {\n\t    \"in\": function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t    },\n\t    out: function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n\t    },\n\t    inout: function(k) {\n\t      var a, p, s;\n\t      s = void 0;\n\t      p = 0.4;\n\t      if (k === 0) {\n\t        return 0;\n\t      }\n\t      if (k === 1) {\n\t        return 1;\n\t      }\n\t      a = 1;\n\t      s = p / 4;\n\t      if ((k *= 2) < 1) {\n\t        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n\t      }\n\t      return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t    }\n\t  };\n\n\t  Easing.prototype.bounce = {\n\t    \"in\": function(k) {\n\t      return 1 - easing.bounce.out(1 - k);\n\t    },\n\t    out: function(k) {\n\t      if (k < (1 / 2.75)) {\n\t        return 7.5625 * k * k;\n\t      } else if (k < (2 / 2.75)) {\n\t        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n\t      } else if (k < (2.5 / 2.75)) {\n\t        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n\t      } else {\n\t        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n\t      }\n\t    },\n\t    inout: function(k) {\n\t      if (k < 0.5) {\n\t        return easing.bounce[\"in\"](k * 2) * 0.5;\n\t      }\n\t      return easing.bounce.out(k * 2 - 1) * 0.5 + 0.5;\n\t    }\n\t  };\n\n\t  Easing.prototype.parseEasing = function(easing) {\n\t    var easingParent, type;\n\t    if (easing == null) {\n\t      easing = 'linear.none';\n\t    }\n\t    type = typeof easing;\n\t    if (type === 'string') {\n\t      if (easing.charAt(0).toLowerCase() === 'm') {\n\t        return this.path(easing);\n\t      } else {\n\t        easing = this._splitEasing(easing);\n\t        easingParent = this[easing[0]];\n\t        if (!easingParent) {\n\t          h.error(\"Easing with name \\\"\" + easing[0] + \"\\\" was not found, fallback to \\\"linear.none\\\" instead\");\n\t          return this['linear']['none'];\n\t        }\n\t        return easingParent[easing[1]];\n\t      }\n\t    }\n\t    if (h.isArray(easing)) {\n\t      return this.bezier.apply(this, easing);\n\t    }\n\t    if ('function') {\n\t      return easing;\n\t    }\n\t  };\n\n\t  Easing.prototype._splitEasing = function(string) {\n\t    var firstPart, secondPart, split;\n\t    if (typeof string === 'function') {\n\t      return string;\n\t    }\n\t    if (typeof string === 'string' && string.length) {\n\t      split = string.split('.');\n\t      firstPart = split[0].toLowerCase() || 'linear';\n\t      secondPart = split[1].toLowerCase() || 'none';\n\t      return [firstPart, secondPart];\n\t    } else {\n\t      return ['linear', 'none'];\n\t    }\n\t  };\n\n\t  return Easing;\n\n\t})();\n\n\teasing = new Easing;\n\n\teasing.mix = mix(easing);\n\n\tmodule.exports = easing;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\texports.default = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\n\t  return call && ((typeof call === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _setPrototypeOf = __webpack_require__(48);\n\n\tvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\n\tvar _create = __webpack_require__(49);\n\n\tvar _create2 = _interopRequireDefault(_create);\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(superClass)));\n\t  }\n\n\t  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _module = __webpack_require__(16);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Bit = function (_Module) {\n\t  (0, _inherits3.default)(Bit, _Module);\n\n\t  function Bit() {\n\t    (0, _classCallCheck3.default)(this, Bit);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Module.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t  */\n\n\t  Bit.prototype._declareDefaults = function _declareDefaults() {\n\t    this._defaults = {\n\t      'ns': 'http://www.w3.org/2000/svg',\n\t      'tag': 'ellipse',\n\t      'parent': document.body,\n\t      'ratio': 1,\n\t      'radius': 50,\n\t      'radiusX': null,\n\t      'radiusY': null,\n\t      'stroke': 'hotpink',\n\t      'stroke-dasharray': '',\n\t      'stroke-dashoffset': '',\n\t      'stroke-linecap': '',\n\t      'stroke-width': 2,\n\t      'stroke-opacity': 1,\n\t      'fill': 'transparent',\n\t      'fill-opacity': 1,\n\t      'width': 0,\n\t      'height': 0\n\t    };\n\t    this._drawMap = ['stroke', 'stroke-width', 'stroke-opacity', 'stroke-dasharray', 'fill', 'stroke-dashoffset', 'stroke-linecap', 'fill-opacity', 'transform'];\n\t  };\n\n\t  Bit.prototype._vars = function _vars() {\n\t    this._state = {};\n\t    this._drawMapLength = this._drawMap.length;\n\t  };\n\t  /*\n\t    Method for initial render of the shape.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._render = function _render() {\n\t    if (this._isRendered) {\n\t      return;\n\t    }\n\t    // set `_isRendered` hatch\n\t    this._isRendered = true;\n\t    // create `SVG` canvas to draw in\n\t    this._createSVGCanvas();\n\t    // set canvas size\n\t    this._setCanvasSize();\n\t    // draw the initial state\n\t    // this._draw();\n\t    // append the canvas to the parent from props\n\t    this._props.parent.appendChild(this._canvas);\n\t  };\n\t  /*\n\t    Method to create `SVG` canvas to draw in.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._createSVGCanvas = function _createSVGCanvas() {\n\t    var p = this._props;\n\t    // create canvas - `svg` element to draw in\n\t    this._canvas = document.createElementNS(p.ns, 'svg');\n\t    // create the element shape element and add it to the canvas\n\t    this.el = document.createElementNS(p.ns, p.tag);\n\t    this._canvas.appendChild(this.el);\n\t  };\n\t  /*\n\t    Method to set size of the _canvas.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._setCanvasSize = function _setCanvasSize() {\n\t    var p = this._props,\n\t        style = this._canvas.style;\n\n\t    style.display = 'block';\n\t    style.width = '100%';\n\t    style.height = '100%';\n\t    style.left = '0px';\n\t    style.top = '0px';\n\t  };\n\t  /*\n\t    Method to draw the shape.\n\t    Called on every frame.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._draw = function _draw() {\n\t    this._props.length = this._getLength();\n\n\t    var state = this._state,\n\t        props = this._props;\n\n\t    var len = this._drawMapLength;\n\t    while (len--) {\n\t      var name = this._drawMap[len];\n\t      switch (name) {\n\t        case 'stroke-dasharray':\n\t        case 'stroke-dashoffset':\n\t          this.castStrokeDash(name);\n\t      }\n\t      this._setAttrIfChanged(name, this._props[name]);\n\t    }\n\t    this._state.radius = this._props.radius;\n\t  };\n\n\t  Bit.prototype.castStrokeDash = function castStrokeDash(name) {\n\t    // # if array of values\n\t    var p = this._props;\n\t    if (_h2.default.isArray(p[name])) {\n\t      var stroke = '';\n\t      for (var i = 0; i < p[name].length; i++) {\n\t        var dash = p[name][i],\n\t            cast = dash.unit === '%' ? this.castPercent(dash.value) : dash.value;\n\t        stroke += cast + ' ';\n\t      }\n\t      p[name] = stroke === '0 ' ? stroke = '' : stroke;\n\t      return p[name] = stroke;\n\t    }\n\t    // # if single value\n\t    if ((0, _typeof3.default)(p[name]) === 'object') {\n\t      stroke = p[name].unit === '%' ? this.castPercent(p[name].value) : p[name].value;\n\t      p[name] = stroke === 0 ? stroke = '' : stroke;\n\t    }\n\t  };\n\n\t  Bit.prototype.castPercent = function castPercent(percent) {\n\t    return percent * (this._props.length / 100);\n\t  };\n\n\t  /*\n\t    Method to set props to attributes and cache the values.\n\t    @private\n\t  */\n\n\n\t  Bit.prototype._setAttrIfChanged = function _setAttrIfChanged(name, value) {\n\t    if (this._state[name] !== value) {\n\t      // this.el.style[name] = value;\n\t      this.el.setAttribute(name, value);\n\t      this._state[name] = value;\n\t    }\n\t  };\n\t  /*\n\t    Method to length of the shape.\n\t    @private\n\t    @returns {Number} Length of the shape.\n\t  */\n\n\n\t  Bit.prototype._getLength = function _getLength() {\n\t    var p = this._props,\n\t        len = 0,\n\t        isGetLength = !!(this.el && this.el.getTotalLength);\n\n\t    if (isGetLength && this.el.getAttribute('d')) {\n\t      len = this.el.getTotalLength();\n\t    } else {\n\t      len = 2 * (p.radiusX != null ? p.radiusX : p.radius);\n\t    }\n\t    return len;\n\t  };\n\t  /*\n\t    Method to calculate total sum between points.\n\t    @private\n\t    @param {Array} Array of points.\n\t    @returns {Number} Distance bewtween all points.\n\t  */\n\n\n\t  Bit.prototype._getPointsPerimiter = function _getPointsPerimiter(points) {\n\t    var sum = 0;\n\n\t    for (var i = 1; i < points.length; i++) {\n\t      sum += this._pointsDelta(points[i - 1], points[i]);\n\t    }\n\n\t    sum += this._pointsDelta(points[0], _h2.default.getLastItem(points));\n\t    return sum;\n\t  };\n\t  /*\n\t    Method to get delta from two points.\n\t    @private\n\t    @param {Object} Point 1.\n\t    @param {Object} Point 2.\n\t    @returns {Number} Distance between the pooints.\n\t  */\n\n\n\t  Bit.prototype._pointsDelta = function _pointsDelta(point1, point2) {\n\t    var dx = Math.abs(point1.x - point2.x),\n\t        dy = Math.abs(point1.y - point2.y);\n\t    return Math.sqrt(dx * dx + dy * dy);\n\t  };\n\t  /*\n\t    Method to set module's size.\n\t    @private\n\t    @param {Number} Module width.\n\t    @param {Number} Module height.\n\t  */\n\n\n\t  Bit.prototype._setSize = function _setSize(width, height) {\n\t    var p = this._props;\n\t    p.width = width;\n\t    p.height = height;\n\t    this._draw();\n\t  };\n\n\t  return Bit;\n\t}(_module2.default);\n\n\texports.default = Bit;\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\texports.__esModule = true;\n\n\tvar _assign = __webpack_require__(50);\n\n\tvar _assign2 = _interopRequireDefault(_assign);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _assign2.default || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(52), __esModule: true };\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(51), __esModule: true };\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\t(function() {\n\t  'use strict';\n\t  var cancel, i, isOldBrowser, lastTime, vendors, vp, w;\n\t  vendors = ['webkit', 'moz'];\n\t  i = 0;\n\t  w = window;\n\t  while (i < vendors.length && !w.requestAnimationFrame) {\n\t    vp = vendors[i];\n\t    w.requestAnimationFrame = w[vp + 'RequestAnimationFrame'];\n\t    cancel = w[vp + 'CancelAnimationFrame'];\n\t    w.cancelAnimationFrame = cancel || w[vp + 'CancelRequestAnimationFrame'];\n\t    ++i;\n\t  }\n\t  isOldBrowser = !w.requestAnimationFrame || !w.cancelAnimationFrame;\n\t  if (/iP(ad|hone|od).*OS 6/.test(w.navigator.userAgent) || isOldBrowser) {\n\t    lastTime = 0;\n\t    w.requestAnimationFrame = function(callback) {\n\t      var nextTime, now;\n\t      now = Date.now();\n\t      nextTime = Math.max(lastTime + 16, now);\n\t      return setTimeout((function() {\n\t        callback(lastTime = nextTime);\n\t      }), nextTime - now);\n\t    };\n\t    w.cancelAnimationFrame = clearTimeout;\n\t  }\n\t})();\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\t(function(root) {\n\t  var offset, ref, ref1;\n\t  if (root.performance == null) {\n\t    root.performance = {};\n\t  }\n\t  Date.now = Date.now || function() {\n\t    return (new Date).getTime();\n\t  };\n\t  if (root.performance.now == null) {\n\t    offset = ((ref = root.performance) != null ? (ref1 = ref.timing) != null ? ref1.navigationStart : void 0 : void 0) ? performance.timing.navigationStart : Date.now();\n\t    return root.performance.now = function() {\n\t      return Date.now() - offset;\n\t    };\n\t  }\n\t})(window);\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(1), __esModule: true };\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(54), __esModule: true };\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\t/*!\n\t  LegoMushroom @legomushroom http://legomushroom.com\n\t  MIT License 2014\n\t */\n\n\t/* istanbul ignore next */\n\t(function() {\n\t  var Main;\n\t  Main = (function() {\n\t    function Main(o) {\n\t      this.o = o != null ? o : {};\n\t      if (window.isAnyResizeEventInited) {\n\t        return;\n\t      }\n\t      this.vars();\n\t      this.redefineProto();\n\t    }\n\n\t    Main.prototype.vars = function() {\n\t      window.isAnyResizeEventInited = true;\n\t      this.allowedProtos = [HTMLDivElement, HTMLFormElement, HTMLLinkElement, HTMLBodyElement, HTMLParagraphElement, HTMLFieldSetElement, HTMLLegendElement, HTMLLabelElement, HTMLButtonElement, HTMLUListElement, HTMLOListElement, HTMLLIElement, HTMLHeadingElement, HTMLQuoteElement, HTMLPreElement, HTMLBRElement, HTMLFontElement, HTMLHRElement, HTMLModElement, HTMLParamElement, HTMLMapElement, HTMLTableElement, HTMLTableCaptionElement, HTMLImageElement, HTMLTableCellElement, HTMLSelectElement, HTMLInputElement, HTMLTextAreaElement, HTMLAnchorElement, HTMLObjectElement, HTMLTableColElement, HTMLTableSectionElement, HTMLTableRowElement];\n\t      return this.timerElements = {\n\t        img: 1,\n\t        textarea: 1,\n\t        input: 1,\n\t        embed: 1,\n\t        object: 1,\n\t        svg: 1,\n\t        canvas: 1,\n\t        tr: 1,\n\t        tbody: 1,\n\t        thead: 1,\n\t        tfoot: 1,\n\t        a: 1,\n\t        select: 1,\n\t        option: 1,\n\t        optgroup: 1,\n\t        dl: 1,\n\t        dt: 1,\n\t        br: 1,\n\t        basefont: 1,\n\t        font: 1,\n\t        col: 1,\n\t        iframe: 1\n\t      };\n\t    };\n\n\t    Main.prototype.redefineProto = function() {\n\t      var i, it, proto, t;\n\t      it = this;\n\t      return t = (function() {\n\t        var j, len, ref, results;\n\t        ref = this.allowedProtos;\n\t        results = [];\n\t        for (i = j = 0, len = ref.length; j < len; i = ++j) {\n\t          proto = ref[i];\n\t          if (proto.prototype == null) {\n\t            continue;\n\t          }\n\t          results.push((function(proto) {\n\t            var listener, remover;\n\t            listener = proto.prototype.addEventListener || proto.prototype.attachEvent;\n\t            (function(listener) {\n\t              var wrappedListener;\n\t              wrappedListener = function() {\n\t                var option;\n\t                if (this !== window || this !== document) {\n\t                  option = arguments[0] === 'onresize' && !this.isAnyResizeEventInited;\n\t                  option && it.handleResize({\n\t                    args: arguments,\n\t                    that: this\n\t                  });\n\t                }\n\t                return listener.apply(this, arguments);\n\t              };\n\t              if (proto.prototype.addEventListener) {\n\t                return proto.prototype.addEventListener = wrappedListener;\n\t              } else if (proto.prototype.attachEvent) {\n\t                return proto.prototype.attachEvent = wrappedListener;\n\t              }\n\t            })(listener);\n\t            remover = proto.prototype.removeEventListener || proto.prototype.detachEvent;\n\t            return (function(remover) {\n\t              var wrappedRemover;\n\t              wrappedRemover = function() {\n\t                this.isAnyResizeEventInited = false;\n\t                this.iframe && this.removeChild(this.iframe);\n\t                return remover.apply(this, arguments);\n\t              };\n\t              if (proto.prototype.removeEventListener) {\n\t                return proto.prototype.removeEventListener = wrappedRemover;\n\t              } else if (proto.prototype.detachEvent) {\n\t                return proto.prototype.detachEvent = wrappedListener;\n\t              }\n\t            })(remover);\n\t          })(proto));\n\t        }\n\t        return results;\n\t      }).call(this);\n\t    };\n\n\t    Main.prototype.handleResize = function(args) {\n\t      var computedStyle, el, iframe, isEmpty, isNoPos, isStatic, ref;\n\t      el = args.that;\n\t      if (!this.timerElements[el.tagName.toLowerCase()]) {\n\t        iframe = document.createElement('iframe');\n\t        el.appendChild(iframe);\n\t        iframe.style.width = '100%';\n\t        iframe.style.height = '100%';\n\t        iframe.style.position = 'absolute';\n\t        iframe.style.zIndex = -999;\n\t        iframe.style.opacity = 0;\n\t        iframe.style.top = 0;\n\t        iframe.style.left = 0;\n\t        computedStyle = window.getComputedStyle ? getComputedStyle(el) : el.currentStyle;\n\t        isNoPos = el.style.position === '';\n\t        isStatic = computedStyle.position === 'static' && isNoPos;\n\t        isEmpty = computedStyle.position === '' && el.style.position === '';\n\t        if (isStatic || isEmpty) {\n\t          el.style.position = 'relative';\n\t        }\n\t        if ((ref = iframe.contentWindow) != null) {\n\t          ref.onresize = (function(_this) {\n\t            return function(e) {\n\t              return _this.dispatchEvent(el);\n\t            };\n\t          })(this);\n\t        }\n\t        el.iframe = iframe;\n\t      } else {\n\t        this.initTimer(el);\n\t      }\n\t      return el.isAnyResizeEventInited = true;\n\t    };\n\n\t    Main.prototype.initTimer = function(el) {\n\t      var height, width;\n\t      width = 0;\n\t      height = 0;\n\t      return this.interval = setInterval((function(_this) {\n\t        return function() {\n\t          var newHeight, newWidth;\n\t          newWidth = el.offsetWidth;\n\t          newHeight = el.offsetHeight;\n\t          if (newWidth !== width || newHeight !== height) {\n\t            _this.dispatchEvent(el);\n\t            width = newWidth;\n\t            return height = newHeight;\n\t          }\n\t        };\n\t      })(this), this.o.interval || 62.5);\n\t    };\n\n\t    Main.prototype.dispatchEvent = function(el) {\n\t      var e;\n\t      if (document.createEvent) {\n\t        e = document.createEvent('HTMLEvents');\n\t        e.initEvent('onresize', false, false);\n\t        return el.dispatchEvent(e);\n\t      } else if (document.createEventObject) {\n\t        e = document.createEventObject();\n\t        return el.fireEvent('onresize', e);\n\t      } else {\n\t        return false;\n\t      }\n\t    };\n\n\t    Main.prototype.destroy = function() {\n\t      var i, it, j, len, proto, ref, results;\n\t      clearInterval(this.interval);\n\t      this.interval = null;\n\t      window.isAnyResizeEventInited = false;\n\t      it = this;\n\t      ref = this.allowedProtos;\n\t      results = [];\n\t      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n\t        proto = ref[i];\n\t        if (proto.prototype == null) {\n\t          continue;\n\t        }\n\t        results.push((function(proto) {\n\t          var listener;\n\t          listener = proto.prototype.addEventListener || proto.prototype.attachEvent;\n\t          if (proto.prototype.addEventListener) {\n\t            proto.prototype.addEventListener = Element.prototype.addEventListener;\n\t          } else if (proto.prototype.attachEvent) {\n\t            proto.prototype.attachEvent = Element.prototype.attachEvent;\n\t          }\n\t          if (proto.prototype.removeEventListener) {\n\t            return proto.prototype.removeEventListener = Element.prototype.removeEventListener;\n\t          } else if (proto.prototype.detachEvent) {\n\t            return proto.prototype.detachEvent = Element.prototype.detachEvent;\n\t          }\n\t        })(proto));\n\t      }\n\t      return results;\n\t    };\n\n\t    return Main;\n\n\t  })();\n\t  if (true) {\n\t    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t      return new Main;\n\t    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if ((typeof module === \"object\") && (typeof module.exports === \"object\")) {\n\t    return module.exports = new Main;\n\t  } else {\n\t    if (typeof window !== \"undefined\" && window !== null) {\n\t      window.AnyResizeEvent = Main;\n\t    }\n\t    return typeof window !== \"undefined\" && window !== null ? window.anyResizeEvent = new Main : void 0;\n\t  }\n\t})();\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Rect,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tRect = (function(superClass) {\n\t  extend(Rect, superClass);\n\n\t  function Rect() {\n\t    return Rect.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Rect.prototype._declareDefaults = function() {\n\t    Rect.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'rect';\n\t    this._defaults.rx = 0;\n\t    return this._defaults.ry = 0;\n\t  };\n\n\t  Rect.prototype._draw = function() {\n\t    var p, radiusX, radiusY;\n\t    Rect.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\t    this._setAttrIfChanged('width', 2 * radiusX);\n\t    this._setAttrIfChanged('height', 2 * radiusY);\n\t    this._setAttrIfChanged('x', (p.width / 2) - radiusX);\n\t    this._setAttrIfChanged('y', (p.height / 2) - radiusY);\n\t    this._setAttrIfChanged('rx', p.rx);\n\t    return this._setAttrIfChanged('ry', p.ry);\n\t  };\n\n\t  Rect.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * (2 * radiusX + 2 * radiusY);\n\t  };\n\n\t  return Rect;\n\n\t})(Bit);\n\n\tmodule.exports = Rect;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _bit = __webpack_require__(26);\n\n\tvar _bit2 = _interopRequireDefault(_bit);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Custom = function (_Bit) {\n\t  (0, _inherits3.default)(Custom, _Bit);\n\n\t  function Custom() {\n\t    (0, _classCallCheck3.default)(this, Custom);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\t  Custom.prototype._declareDefaults = function _declareDefaults() {\n\t    _Bit.prototype._declareDefaults.call(this);\n\n\t    this._defaults.tag = 'path';\n\t    this._defaults.parent = null;\n\n\t    // remove `stroke-width` from `_drawMap`\n\t    // because we need to recal strokeWidth size regarding scale\n\t    for (var i = 0; i < this._drawMap.length; i++) {\n\t      if (this._drawMap[i] === 'stroke-width') {\n\t        this._drawMap.splice(i, 1);\n\t      }\n\t    }\n\t  };\n\t  /*\n\t    Method to get shape to set on module's path.\n\t    @public\n\t    @returns {String} Empty string.\n\t  */\n\n\n\t  Custom.prototype.getShape = function getShape() {\n\t    return '';\n\t  };\n\t  /*\n\t    Method to get shape perimeter length.\n\t    @public\n\t    @returns {Number} Default length string.\n\t  */\n\n\n\t  Custom.prototype.getLength = function getLength() {\n\t    return 100;\n\t  };\n\t  /*\n\t    Method to draw the shape.\n\t    Called on every frame.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Custom.prototype._draw = function _draw() {\n\t    var p = this._props,\n\t        state = this._state,\n\t        radiusXChange = state['radiusX'] !== p.radiusX,\n\t        radiusYChange = state['radiusY'] !== p.radiusY,\n\t        radiusChange = state['radius'] !== p.radius;\n\n\t    // update transform only if one of radiuses changed\n\t    if (radiusXChange || radiusYChange || radiusChange) {\n\t      this.el.setAttribute('transform', this._getScale());\n\t      state['radiusX'] = p.radiusX;\n\t      state['radiusY'] = p.radiusY;\n\t      state['radius'] = p.radius;\n\t    }\n\n\t    this._setAttrIfChanged('stroke-width', p['stroke-width'] / p.maxScale);\n\n\t    _Bit.prototype._draw.call(this);\n\t  };\n\t  /*\n\t    Method for initial render of the shape.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Custom.prototype._render = function _render() {\n\t    if (this._isRendered) {\n\t      return;\n\t    }\n\t    this._isRendered = true;\n\n\t    this._length = this.getLength();\n\n\t    var p = this._props;\n\t    p.parent.innerHTML = '<svg id=\"js-mojs-shape-canvas\" xmlns=\"http://www.w3.org/2000/svg\" xlink=\"http://www.w3.org/1999/xlink\"><g id=\"js-mojs-shape-el\">' + this.getShape() + '</g></svg>';\n\n\t    this._canvas = p.parent.querySelector('#js-mojs-shape-canvas');\n\t    this.el = p.parent.querySelector('#js-mojs-shape-el');\n\t    this._setCanvasSize();\n\t  };\n\t  /*\n\t    Method to get scales for the shape.\n\t    @private\n\t    @mutates @props\n\t  */\n\n\n\t  Custom.prototype._getScale = function _getScale() {\n\t    var p = this._props,\n\t        radiusX = p.radiusX ? p.radiusX : p.radius,\n\t        radiusY = p.radiusY ? p.radiusY : p.radius;\n\n\t    p.scaleX = 2 * radiusX / 100;\n\t    p.scaleY = 2 * radiusY / 100;\n\t    p.maxScale = Math.max(p.scaleX, p.scaleY);\n\n\t    p.shiftX = p.width / 2 - 50 * p.scaleX;\n\t    p.shiftY = p.height / 2 - 50 * p.scaleY;\n\n\t    var translate = 'translate(' + p.shiftX + ', ' + p.shiftY + ')';\n\t    return translate + ' scale(' + p.scaleX + ', ' + p.scaleY + ')';\n\t  };\n\t  /*\n\t    Method to length of the shape.\n\t    @private\n\t    @returns {Number} Length of the shape.\n\t  */\n\n\n\t  Custom.prototype._getLength = function _getLength() {\n\t    return this._length;\n\t  };\n\n\t  return Custom;\n\t}(_bit2.default);\n\n\texports.default = Custom;\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Circle,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tCircle = (function(superClass) {\n\t  extend(Circle, superClass);\n\n\t  function Circle() {\n\t    return Circle.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Circle.prototype._declareDefaults = function() {\n\t    Circle.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.shape = 'ellipse';\n\t  };\n\n\t  Circle.prototype._draw = function() {\n\t    var rx, ry;\n\t    rx = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    ry = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    this._setAttrIfChanged('rx', rx);\n\t    this._setAttrIfChanged('ry', ry);\n\t    this._setAttrIfChanged('cx', this._props.width / 2);\n\t    this._setAttrIfChanged('cy', this._props.height / 2);\n\t    return Circle.__super__._draw.apply(this, arguments);\n\t  };\n\n\t  Circle.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * Math.PI * Math.sqrt((radiusX * radiusX + radiusY * radiusY) / 2);\n\t  };\n\n\t  return Circle;\n\n\t})(Bit);\n\n\tmodule.exports = Circle;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Line,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tLine = (function(superClass) {\n\t  extend(Line, superClass);\n\n\t  function Line() {\n\t    return Line.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Line.prototype._declareDefaults = function() {\n\t    Line.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.tag = 'line';\n\t  };\n\n\t  Line.prototype._draw = function() {\n\t    var radiusX, x, y;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    this._setAttrIfChanged('x1', x - radiusX);\n\t    this._setAttrIfChanged('x2', x + radiusX);\n\t    this._setAttrIfChanged('y1', y);\n\t    this._setAttrIfChanged('y2', y);\n\t    return Line.__super__._draw.apply(this, arguments);\n\t  };\n\n\t  return Line;\n\n\t})(Bit);\n\n\tmodule.exports = Line;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Zigzag,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tZigzag = (function(superClass) {\n\t  extend(Zigzag, superClass);\n\n\t  function Zigzag() {\n\t    return Zigzag.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Zigzag.prototype._declareDefaults = function() {\n\t    Zigzag.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 3;\n\t  };\n\n\t  Zigzag.prototype._draw = function() {\n\t    var currentX, currentY, delta, i, isPoints, isRadiusX, isRadiusY, j, length, p, points, radiusX, radiusY, ref, stepX, x, y, yFlip;\n\t    Zigzag.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    if (!this._props.points) {\n\t      return;\n\t    }\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\t    x = p.width / 2;\n\t    y = p.height / 2;\n\t    currentX = x - radiusX;\n\t    currentY = y;\n\t    stepX = (2 * radiusX) / (p.points - 1);\n\t    yFlip = -1;\n\t    delta = Math.sqrt(stepX * stepX + radiusY * radiusY);\n\t    length = -delta;\n\t    points = \"M\" + currentX + \", \" + y + \" \";\n\t    for (i = j = 0, ref = p.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t      points += \"L\" + currentX + \", \" + currentY + \" \";\n\t      currentX += stepX;\n\t      length += delta;\n\t      currentY = yFlip === -1 ? y - radiusY : y;\n\t      yFlip = -yFlip;\n\t    }\n\t    this._length = length;\n\t    this.el.setAttribute('d', points);\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Zigzag.prototype._getLength = function() {\n\t    return this._length;\n\t  };\n\n\t  return Zigzag;\n\n\t})(Bit);\n\n\tmodule.exports = Zigzag;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Polygon, h,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\th = __webpack_require__(19);\n\n\tPolygon = (function(superClass) {\n\t  extend(Polygon, superClass);\n\n\t  function Polygon() {\n\t    return Polygon.__super__.constructor.apply(this, arguments);\n\t  }\n\n\n\t  /*\n\t    Method to declare defaults.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._declareDefaults = function() {\n\t    Polygon.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 3;\n\t  };\n\n\n\t  /*\n\t    Method to draw the shape.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._draw = function() {\n\t    var char, d, i, isPoints, isRadiusX, isRadiusY, j, k, len, p, point, radiusX, radiusY, ref, ref1, step;\n\t    p = this._props;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (!(isRadiusX && isRadiusY && isPoints)) {\n\t      step = 360 / this._props.points;\n\t      if (this._radialPoints == null) {\n\t        this._radialPoints = [];\n\t      } else {\n\t        this._radialPoints.length = 0;\n\t      }\n\t      for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t        this._radialPoints.push(h.getRadialPoint({\n\t          radius: this._props.radius,\n\t          radiusX: this._props.radiusX,\n\t          radiusY: this._props.radiusY,\n\t          angle: i * step,\n\t          center: {\n\t            x: p.width / 2,\n\t            y: p.height / 2\n\t          }\n\t        }));\n\t      }\n\t      d = '';\n\t      ref1 = this._radialPoints;\n\t      for (i = k = 0, len = ref1.length; k < len; i = ++k) {\n\t        point = ref1[i];\n\t        char = i === 0 ? 'M' : 'L';\n\t        d += \"\" + char + (point.x.toFixed(4)) + \",\" + (point.y.toFixed(4)) + \" \";\n\t      }\n\t      this._prevPoints = p.points;\n\t      this._prevRadiusX = radiusX;\n\t      this._prevRadiusY = radiusY;\n\t      this.el.setAttribute('d', (d += 'z'));\n\t    }\n\t    return Polygon.__super__._draw.apply(this, arguments);\n\t  };\n\n\n\t  /*\n\t    Method to get length of the shape.\n\t    @overrides @ Bit\n\t   */\n\n\t  Polygon.prototype._getLength = function() {\n\t    return this._getPointsPerimiter(this._radialPoints);\n\t  };\n\n\t  return Polygon;\n\n\t})(Bit);\n\n\tmodule.exports = Polygon;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Cross,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tCross = (function(superClass) {\n\t  extend(Cross, superClass);\n\n\t  function Cross() {\n\t    return Cross.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Cross.prototype._declareDefaults = function() {\n\t    Cross.__super__._declareDefaults.apply(this, arguments);\n\t    return this._defaults.tag = 'path';\n\t  };\n\n\t  Cross.prototype._draw = function() {\n\t    var d, isRadiusX, isRadiusY, line1, line2, p, radiusX, radiusY, x, x1, x2, y, y1, y2;\n\t    Cross.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    if (isRadiusX && isRadiusY) {\n\t      return;\n\t    }\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    x1 = x - radiusX;\n\t    x2 = x + radiusX;\n\t    line1 = \"M\" + x1 + \",\" + y + \" L\" + x2 + \",\" + y;\n\t    y1 = y - radiusY;\n\t    y2 = y + radiusY;\n\t    line2 = \"M\" + x + \",\" + y1 + \" L\" + x + \",\" + y2;\n\t    d = line1 + \" \" + line2;\n\t    this.el.setAttribute('d', d);\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Cross.prototype._getLength = function() {\n\t    var radiusX, radiusY;\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    return 2 * (radiusX + radiusY);\n\t  };\n\n\t  return Cross;\n\n\t})(Bit);\n\n\tmodule.exports = Cross;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _classCallCheck2 = __webpack_require__(23);\n\n\tvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\n\tvar _possibleConstructorReturn2 = __webpack_require__(24);\n\n\tvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\n\tvar _inherits2 = __webpack_require__(25);\n\n\tvar _inherits3 = _interopRequireDefault(_inherits2);\n\n\tvar _bit = __webpack_require__(26);\n\n\tvar _bit2 = _interopRequireDefault(_bit);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar Curve = function (_Bit) {\n\t  (0, _inherits3.default)(Curve, _Bit);\n\n\t  function Curve() {\n\t    (0, _classCallCheck3.default)(this, Curve);\n\t    return (0, _possibleConstructorReturn3.default)(this, _Bit.apply(this, arguments));\n\t  }\n\n\t  /*\n\t    Method to declare module's defaults.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\t  Curve.prototype._declareDefaults = function _declareDefaults() {\n\t    _Bit.prototype._declareDefaults.call(this);\n\t    this._defaults.tag = 'path';\n\t  };\n\t  /*\n\t    Method to draw the module.\n\t    @private\n\t    @overrides @ Bit\n\t  */\n\n\n\t  Curve.prototype._draw = function _draw() {\n\t    _Bit.prototype._draw.call(this);\n\t    var p = this._props;\n\n\t    var radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    var radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\n\t    var isRadiusX = radiusX === this._prevRadiusX;\n\t    var isRadiusY = radiusY === this._prevRadiusY;\n\t    var isPoints = p.points === this._prevPoints;\n\t    // skip if nothing changed\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\n\t    var x = p.width / 2;\n\t    var y = p.height / 2;\n\t    var x1 = x - radiusX;\n\t    var x2 = x + radiusX;\n\n\t    var d = 'M' + x1 + ' ' + y + ' Q ' + x + ' ' + (y - 2 * radiusY) + ' ' + x2 + ' ' + y;\n\n\t    // set the `d` attribute and save it to `_prevD`\n\t    this.el.setAttribute('d', d);\n\t    // save the properties\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    this._prevRadiusY = radiusY;\n\t  };\n\n\t  Curve.prototype._getLength = function _getLength() {\n\t    var p = this._props;\n\n\t    var radiusX = p.radiusX != null ? p.radiusX : p.radius;\n\t    var radiusY = p.radiusY != null ? p.radiusY : p.radius;\n\n\t    var dRadius = radiusX + radiusY;\n\t    var sqrt = Math.sqrt((3 * radiusX + radiusY) * (radiusX + 3 * radiusY));\n\n\t    return .5 * Math.PI * (3 * dRadius - sqrt);\n\t  };\n\n\t  return Curve;\n\t}(_bit2.default); // istanbul ignore next\n\n\n\texports.default = Curve;\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/* istanbul ignore next */\n\tvar Bit, Equal,\n\t  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n\t  hasProp = {}.hasOwnProperty;\n\n\tBit = __webpack_require__(26)[\"default\"] || __webpack_require__(26);\n\n\tEqual = (function(superClass) {\n\t  extend(Equal, superClass);\n\n\t  function Equal() {\n\t    return Equal.__super__.constructor.apply(this, arguments);\n\t  }\n\n\t  Equal.prototype._declareDefaults = function() {\n\t    Equal.__super__._declareDefaults.apply(this, arguments);\n\t    this._defaults.tag = 'path';\n\t    return this._defaults.points = 2;\n\t  };\n\n\t  Equal.prototype._draw = function() {\n\t    var d, i, isPoints, isRadiusX, isRadiusY, j, p, radiusX, radiusY, ref, x, x1, x2, y, yStart, yStep;\n\t    Equal.__super__._draw.apply(this, arguments);\n\t    p = this._props;\n\t    if (!this._props.points) {\n\t      return;\n\t    }\n\t    radiusX = this._props.radiusX != null ? this._props.radiusX : this._props.radius;\n\t    radiusY = this._props.radiusY != null ? this._props.radiusY : this._props.radius;\n\t    isRadiusX = radiusX === this._prevRadiusX;\n\t    isRadiusY = radiusY === this._prevRadiusY;\n\t    isPoints = p.points === this._prevPoints;\n\t    if (isRadiusX && isRadiusY && isPoints) {\n\t      return;\n\t    }\n\t    x = this._props.width / 2;\n\t    y = this._props.height / 2;\n\t    x1 = x - radiusX;\n\t    x2 = x + radiusX;\n\t    d = '';\n\t    yStep = 2 * radiusY / (this._props.points - 1);\n\t    yStart = y - radiusY;\n\t    for (i = j = 0, ref = this._props.points; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n\t      y = \"\" + (i * yStep + yStart);\n\t      d += \"M\" + x1 + \", \" + y + \" L\" + x2 + \", \" + y + \" \";\n\t    }\n\t    this.el.setAttribute('d', d);\n\t    this._prevPoints = p.points;\n\t    this._prevRadiusX = radiusX;\n\t    return this._prevRadiusY = radiusY;\n\t  };\n\n\t  Equal.prototype._getLength = function() {\n\t    return 2 * (this._props.radiusX != null ? this._props.radiusX : this._props.radius);\n\t  };\n\n\t  return Equal;\n\n\t})(Bit);\n\n\tmodule.exports = Equal;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var BezierEasing, bezierEasing, h,\n\t  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n\th = __webpack_require__(19);\n\n\n\t/**\n\t * Copyright (c) 2014 Gaëtan Renaudeau http://goo.gl/El3k7u\n\t * Adopted from https://github.com/gre/bezier-easing\n\t */\n\n\tBezierEasing = (function() {\n\t  function BezierEasing(o) {\n\t    this.vars();\n\t    return this.generate;\n\t  }\n\n\t  BezierEasing.prototype.vars = function() {\n\t    return this.generate = h.bind(this.generate, this);\n\t  };\n\n\t  BezierEasing.prototype.generate = function(mX1, mY1, mX2, mY2) {\n\t    var A, B, C, NEWTON_ITERATIONS, NEWTON_MIN_SLOPE, SUBDIVISION_MAX_ITERATIONS, SUBDIVISION_PRECISION, _precomputed, arg, binarySubdivide, calcBezier, calcSampleValues, f, float32ArraySupported, getSlope, getTForX, i, j, kSampleStepSize, kSplineTableSize, mSampleValues, newtonRaphsonIterate, precompute, str;\n\t    if (arguments.length < 4) {\n\t      return this.error('Bezier function expects 4 arguments');\n\t    }\n\t    for (i = j = 0; j < 4; i = ++j) {\n\t      arg = arguments[i];\n\t      if (typeof arg !== \"number\" || isNaN(arg) || !isFinite(arg)) {\n\t        return this.error('Bezier function expects 4 arguments');\n\t      }\n\t    }\n\t    if (mX1 < 0 || mX1 > 1 || mX2 < 0 || mX2 > 1) {\n\t      return this.error('Bezier x values should be > 0 and < 1');\n\t    }\n\t    NEWTON_ITERATIONS = 4;\n\t    NEWTON_MIN_SLOPE = 0.001;\n\t    SUBDIVISION_PRECISION = 0.0000001;\n\t    SUBDIVISION_MAX_ITERATIONS = 10;\n\t    kSplineTableSize = 11;\n\t    kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\t    float32ArraySupported = indexOf.call(global, 'Float32Array') >= 0;\n\t    A = function(aA1, aA2) {\n\t      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n\t    };\n\t    B = function(aA1, aA2) {\n\t      return 3.0 * aA2 - 6.0 * aA1;\n\t    };\n\t    C = function(aA1) {\n\t      return 3.0 * aA1;\n\t    };\n\t    calcBezier = function(aT, aA1, aA2) {\n\t      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n\t    };\n\t    getSlope = function(aT, aA1, aA2) {\n\t      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n\t    };\n\t    newtonRaphsonIterate = function(aX, aGuessT) {\n\t      var currentSlope, currentX;\n\t      i = 0;\n\t      while (i < NEWTON_ITERATIONS) {\n\t        currentSlope = getSlope(aGuessT, mX1, mX2);\n\n\t        /* istanbul ignore if */\n\t        if (currentSlope === 0.0) {\n\t          return aGuessT;\n\t        }\n\t        currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n\t        aGuessT -= currentX / currentSlope;\n\t        ++i;\n\t      }\n\t      return aGuessT;\n\t    };\n\t    calcSampleValues = function() {\n\t      i = 0;\n\t      while (i < kSplineTableSize) {\n\t        mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n\t        ++i;\n\t      }\n\t    };\n\n\t    /* istanbul ignore next */\n\t    binarySubdivide = function(aX, aA, aB) {\n\t      var currentT, currentX, isBig;\n\t      currentX = void 0;\n\t      currentT = void 0;\n\t      i = 0;\n\t      while (true) {\n\t        currentT = aA + (aB - aA) / 2.0;\n\t        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\t        if (currentX > 0.0) {\n\t          aB = currentT;\n\t        } else {\n\t          aA = currentT;\n\t        }\n\t        isBig = Math.abs(currentX) > SUBDIVISION_PRECISION;\n\t        if (!(isBig && ++i < SUBDIVISION_MAX_ITERATIONS)) {\n\t          break;\n\t        }\n\t      }\n\t      return currentT;\n\t    };\n\t    getTForX = function(aX) {\n\t      var currentSample, delta, dist, guessForT, initialSlope, intervalStart, lastSample;\n\t      intervalStart = 0.0;\n\t      currentSample = 1;\n\t      lastSample = kSplineTableSize - 1;\n\t      while (currentSample !== lastSample && mSampleValues[currentSample] <= aX) {\n\t        intervalStart += kSampleStepSize;\n\t        ++currentSample;\n\t      }\n\t      --currentSample;\n\t      delta = mSampleValues[currentSample + 1] - mSampleValues[currentSample];\n\t      dist = (aX - mSampleValues[currentSample]) / delta;\n\t      guessForT = intervalStart + dist * kSampleStepSize;\n\t      initialSlope = getSlope(guessForT, mX1, mX2);\n\t      if (initialSlope >= NEWTON_MIN_SLOPE) {\n\t        return newtonRaphsonIterate(aX, guessForT);\n\t      } else {\n\n\t        /* istanbul ignore next */\n\t        if (initialSlope === 0.0) {\n\t          return guessForT;\n\t        } else {\n\t          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n\t        }\n\t      }\n\t    };\n\t    precompute = function() {\n\t      var _precomputed;\n\t      _precomputed = true;\n\t      if (mX1 !== mY1 || mX2 !== mY2) {\n\t        return calcSampleValues();\n\t      }\n\t    };\n\t    mSampleValues = !float32ArraySupported ? new Array(kSplineTableSize) : new Float32Array(kSplineTableSize);\n\t    _precomputed = false;\n\t    f = function(aX) {\n\t      if (!_precomputed) {\n\t        precompute();\n\t      }\n\t      if (mX1 === mY1 && mX2 === mY2) {\n\t        return aX;\n\t      }\n\t      if (aX === 0) {\n\t        return 0;\n\t      }\n\t      if (aX === 1) {\n\t        return 1;\n\t      }\n\t      return calcBezier(getTForX(aX), mY1, mY2);\n\t    };\n\t    str = \"bezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\t    f.toStr = function() {\n\t      return str;\n\t    };\n\t    return f;\n\t  };\n\n\t  BezierEasing.prototype.error = function(msg) {\n\t    return h.error(msg);\n\t  };\n\n\t  return BezierEasing;\n\n\t})();\n\n\tbezierEasing = new BezierEasing;\n\n\tmodule.exports = bezierEasing;\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar PathEasing, h;\n\n\th = __webpack_require__(19);\n\n\tPathEasing = (function() {\n\t  PathEasing.prototype._vars = function() {\n\t    this._precompute = h.clamp(this.o.precompute || 1450, 100, 10000);\n\t    this._step = 1 / this._precompute;\n\t    this._rect = this.o.rect || 100;\n\t    this._approximateMax = this.o.approximateMax || 5;\n\t    this._eps = this.o.eps || 0.001;\n\t    return this._boundsPrevProgress = -1;\n\t  };\n\n\t  function PathEasing(path, o1) {\n\t    this.o = o1 != null ? o1 : {};\n\t    if (path === 'creator') {\n\t      return;\n\t    }\n\t    this.path = h.parsePath(path);\n\t    if (this.path == null) {\n\t      return h.error('Error while parsing the path');\n\t    }\n\t    this._vars();\n\t    this.path.setAttribute('d', this._normalizePath(this.path.getAttribute('d')));\n\t    this.pathLength = this.path.getTotalLength();\n\t    this.sample = h.bind(this.sample, this);\n\t    this._hardSample = h.bind(this._hardSample, this);\n\t    this._preSample();\n\t    this;\n\t  }\n\n\t  PathEasing.prototype._preSample = function() {\n\t    var i, j, length, point, progress, ref, results;\n\t    this._samples = [];\n\t    results = [];\n\t    for (i = j = 0, ref = this._precompute; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {\n\t      progress = i * this._step;\n\t      length = this.pathLength * progress;\n\t      point = this.path.getPointAtLength(length);\n\t      results.push(this._samples[i] = {\n\t        point: point,\n\t        length: length,\n\t        progress: progress\n\t      });\n\t    }\n\t    return results;\n\t  };\n\n\t  PathEasing.prototype._findBounds = function(array, p) {\n\t    var buffer, direction, end, i, j, len, loopEnd, pointP, pointX, ref, ref1, start, value;\n\t    if (p === this._boundsPrevProgress) {\n\t      return this._prevBounds;\n\t    }\n\t    if (this._boundsStartIndex == null) {\n\t      this._boundsStartIndex = 0;\n\t    }\n\t    len = array.length;\n\t    if (this._boundsPrevProgress > p) {\n\t      loopEnd = 0;\n\t      direction = 'reverse';\n\t    } else {\n\t      loopEnd = len;\n\t      direction = 'forward';\n\t    }\n\t    if (direction === 'forward') {\n\t      start = array[0];\n\t      end = array[array.length - 1];\n\t    } else {\n\t      start = array[array.length - 1];\n\t      end = array[0];\n\t    }\n\t    for (i = j = ref = this._boundsStartIndex, ref1 = loopEnd; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {\n\t      value = array[i];\n\t      pointX = value.point.x / this._rect;\n\t      pointP = p;\n\t      if (direction === 'reverse') {\n\t        buffer = pointX;\n\t        pointX = pointP;\n\t        pointP = buffer;\n\t      }\n\t      if (pointX < pointP) {\n\t        start = value;\n\t        this._boundsStartIndex = i;\n\t      } else {\n\t        end = value;\n\t        break;\n\t      }\n\t    }\n\t    this._boundsPrevProgress = p;\n\t    return this._prevBounds = {\n\t      start: start,\n\t      end: end\n\t    };\n\t  };\n\n\t  PathEasing.prototype.sample = function(p) {\n\t    var bounds, res;\n\t    p = h.clamp(p, 0, 1);\n\t    bounds = this._findBounds(this._samples, p);\n\t    res = this._checkIfBoundsCloseEnough(p, bounds);\n\t    if (res != null) {\n\t      return res;\n\t    }\n\t    return this._findApproximate(p, bounds.start, bounds.end);\n\t  };\n\n\t  PathEasing.prototype._checkIfBoundsCloseEnough = function(p, bounds) {\n\t    var point, y;\n\t    point = void 0;\n\t    y = this._checkIfPointCloseEnough(p, bounds.start.point);\n\t    if (y != null) {\n\t      return y;\n\t    }\n\t    return this._checkIfPointCloseEnough(p, bounds.end.point);\n\t  };\n\n\t  PathEasing.prototype._checkIfPointCloseEnough = function(p, point) {\n\t    if (h.closeEnough(p, point.x / this._rect, this._eps)) {\n\t      return this._resolveY(point);\n\t    }\n\t  };\n\n\t  PathEasing.prototype._approximate = function(start, end, p) {\n\t    var deltaP, percentP;\n\t    deltaP = end.point.x - start.point.x;\n\t    percentP = (p - (start.point.x / this._rect)) / (deltaP / this._rect);\n\t    return start.length + percentP * (end.length - start.length);\n\t  };\n\n\t  PathEasing.prototype._findApproximate = function(p, start, end, approximateMax) {\n\t    var approximation, args, newPoint, point, x;\n\t    if (approximateMax == null) {\n\t      approximateMax = this._approximateMax;\n\t    }\n\t    approximation = this._approximate(start, end, p);\n\t    point = this.path.getPointAtLength(approximation);\n\t    x = point.x / this._rect;\n\t    if (h.closeEnough(p, x, this._eps)) {\n\t      return this._resolveY(point);\n\t    } else {\n\t      if (--approximateMax < 1) {\n\t        return this._resolveY(point);\n\t      }\n\t      newPoint = {\n\t        point: point,\n\t        length: approximation\n\t      };\n\t      args = p < x ? [p, start, newPoint, approximateMax] : [p, newPoint, end, approximateMax];\n\t      return this._findApproximate.apply(this, args);\n\t    }\n\t  };\n\n\t  PathEasing.prototype._resolveY = function(point) {\n\t    return 1 - (point.y / this._rect);\n\t  };\n\n\t  PathEasing.prototype._normalizePath = function(path) {\n\t    var commands, endIndex, normalizedPath, points, startIndex, svgCommandsRegexp;\n\t    svgCommandsRegexp = /[M|L|H|V|C|S|Q|T|A]/gim;\n\t    points = path.split(svgCommandsRegexp);\n\t    points.shift();\n\t    commands = path.match(svgCommandsRegexp);\n\t    startIndex = 0;\n\t    points[startIndex] = this._normalizeSegment(points[startIndex]);\n\t    endIndex = points.length - 1;\n\t    points[endIndex] = this._normalizeSegment(points[endIndex], this._rect || 100);\n\t    return normalizedPath = this._joinNormalizedPath(commands, points);\n\t  };\n\n\t  PathEasing.prototype._joinNormalizedPath = function(commands, points) {\n\t    var command, i, j, len1, normalizedPath, space;\n\t    normalizedPath = '';\n\t    for (i = j = 0, len1 = commands.length; j < len1; i = ++j) {\n\t      command = commands[i];\n\t      space = i === 0 ? '' : ' ';\n\t      normalizedPath += \"\" + space + command + (points[i].trim());\n\t    }\n\t    return normalizedPath;\n\t  };\n\n\t  PathEasing.prototype._normalizeSegment = function(segment, value) {\n\t    var i, j, lastPoint, len1, nRgx, pairs, parsedX, point, space, x;\n\t    if (value == null) {\n\t      value = 0;\n\t    }\n\t    segment = segment.trim();\n\t    nRgx = /(-|\\+)?((\\d+(\\.(\\d|\\e(-|\\+)?)+)?)|(\\.?(\\d|\\e|(\\-|\\+))+))/gim;\n\t    pairs = this._getSegmentPairs(segment.match(nRgx));\n\t    lastPoint = pairs[pairs.length - 1];\n\t    x = lastPoint[0];\n\t    parsedX = Number(x);\n\t    if (parsedX !== value) {\n\t      segment = '';\n\t      lastPoint[0] = value;\n\t      for (i = j = 0, len1 = pairs.length; j < len1; i = ++j) {\n\t        point = pairs[i];\n\t        space = i === 0 ? '' : ' ';\n\t        segment += \"\" + space + point[0] + \",\" + point[1];\n\t      }\n\t    }\n\t    return segment;\n\t  };\n\n\t  PathEasing.prototype._getSegmentPairs = function(array) {\n\t    var i, j, len1, newArray, pair, value;\n\t    if (array.length % 2 !== 0) {\n\t      h.error('Failed to parse the path - segment pairs are not even.', array);\n\t    }\n\t    newArray = [];\n\t    for (i = j = 0, len1 = array.length; j < len1; i = j += 2) {\n\t      value = array[i];\n\t      pair = [array[i], array[i + 1]];\n\t      newArray.push(pair);\n\t    }\n\t    return newArray;\n\t  };\n\n\t  PathEasing.prototype.create = function(path, o) {\n\t    var handler;\n\t    handler = new PathEasing(path, o);\n\t    handler.sample.path = handler.path;\n\t    return handler.sample;\n\t  };\n\n\t  return PathEasing;\n\n\t})();\n\n\tmodule.exports = PathEasing;\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar create, easing, getNearest, mix, parseIfEasing, sort,\n\t  slice = [].slice;\n\n\teasing = null;\n\n\tparseIfEasing = function(item) {\n\t  if (typeof item.value === 'number') {\n\t    return item.value;\n\t  } else {\n\t    return easing.parseEasing(item.value);\n\t  }\n\t};\n\n\tsort = function(a, b) {\n\t  var returnValue;\n\t  a.value = parseIfEasing(a);\n\t  b.value = parseIfEasing(b);\n\t  returnValue = 0;\n\t  a.to < b.to && (returnValue = -1);\n\t  a.to > b.to && (returnValue = 1);\n\t  return returnValue;\n\t};\n\n\tgetNearest = function(array, progress) {\n\t  var i, index, j, len, value;\n\t  index = 0;\n\t  for (i = j = 0, len = array.length; j < len; i = ++j) {\n\t    value = array[i];\n\t    index = i;\n\t    if (value.to > progress) {\n\t      break;\n\t    }\n\t  }\n\t  return index;\n\t};\n\n\tmix = function() {\n\t  var args;\n\t  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n\t  if (args.length > 1) {\n\t    args = args.sort(sort);\n\t  } else {\n\t    args[0].value = parseIfEasing(args[0]);\n\t  }\n\t  return function(progress) {\n\t    var index, value;\n\t    index = getNearest(args, progress);\n\t    if (index !== -1) {\n\t      value = args[index].value;\n\t      if (index === args.length - 1 && progress > args[index].to) {\n\t        return 1;\n\t      }\n\t      if (typeof value === 'function') {\n\t        return value(progress);\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\t  };\n\t};\n\n\tcreate = function(e) {\n\t  easing = e;\n\t  return mix;\n\t};\n\n\tmodule.exports = create;\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\t/*\n\t  Method to bootstrap approximation function.\n\t  @private\n\t  @param   {Object} Samples Object.\n\t  @returns {Function} Approximate function.\n\t*/\n\tvar _proximate = function _proximate(samples) {\n\t  var n = samples.base,\n\t      samplesAmount = Math.pow(10, n),\n\t      samplesStep = 1 / samplesAmount;\n\n\t  function RoundNumber(input, numberDecimals) {\n\t    numberDecimals = +numberDecimals || 0; // +var magic!\n\n\t    var multiplyer = Math.pow(10.0, numberDecimals);\n\n\t    return Math.round(input * multiplyer) / multiplyer;\n\t  }\n\n\t  var cached = function cached(p) {\n\t    var newKey = RoundNumber(p, n),\n\t        sample = samples[newKey.toString()];\n\n\t    if (Math.abs(p - newKey) < samplesStep) {\n\t      return sample;\n\t    }\n\n\t    if (p > newKey) {\n\t      var nextIndex = newKey + samplesStep;\n\t      var nextValue = samples[nextIndex];\n\t    } else {\n\t      var nextIndex = newKey - samplesStep;\n\t      var nextValue = samples[nextIndex];\n\t    }\n\n\t    var dLength = nextIndex - newKey;\n\t    var dValue = nextValue - sample;\n\t    if (dValue < samplesStep) {\n\t      return sample;\n\t    }\n\n\t    var progressScale = (p - newKey) / dLength;\n\t    var coef = nextValue > sample ? -1 : 1;\n\t    var scaledDifference = coef * progressScale * dValue;\n\n\t    return sample + scaledDifference;\n\t  };\n\n\t  cached.getSamples = function () {\n\t    return samples;\n\t  };\n\n\t  return cached;\n\t};\n\t/*\n\t    Method to take samples of the function and call the _proximate\n\t    method with the dunction and samples. Or if samples passed - pipe\n\t    them to the _proximate method without sampling.\n\t    @private\n\t    @param {Function} Function to sample.\n\t    @param {Number, Object, String} Precision or precomputed samples.\n\t  */\n\tvar _sample = function _sample(fn) {\n\t  var n = arguments.length <= 1 || arguments[1] === undefined ? 4 : arguments[1];\n\n\n\t  var nType = typeof n === 'undefined' ? 'undefined' : (0, _typeof3.default)(n);\n\n\t  var samples = {};\n\t  if (nType === 'number') {\n\t    var p = 0,\n\t        samplesCount = Math.pow(10, n),\n\t        step = 1 / samplesCount;\n\n\t    samples[0] = fn(0);\n\t    for (var i = 0; i < samplesCount - 1; i++) {\n\t      p += step;\n\n\t      var index = parseFloat(p.toFixed(n));\n\t      samples[index] = fn(p);\n\t    }\n\t    samples[1] = fn(1);\n\n\t    samples.base = n;\n\t  } else if (nType === 'object') {\n\t    samples = n;\n\t  } else if (nType === 'string') {\n\t    samples = JSON.parse(n);\n\t  }\n\n\t  return Approximate._sample._proximate(samples);\n\t};\n\n\tvar Approximate = { _sample: _sample, _proximate: _proximate };\n\tApproximate._sample._proximate = Approximate._proximate;\n\n\texports.default = Approximate._sample;\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(55), __esModule: true };\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(56), __esModule: true };\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(57), __esModule: true };\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(58);\n\t__webpack_require__(59);\n\tmodule.exports = __webpack_require__(60);\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(67);\n\tmodule.exports = __webpack_require__(64).Object.keys;\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {'use strict';\n\n\texports.__esModule = true;\n\n\tvar _typeof2 = __webpack_require__(18);\n\n\tvar _typeof3 = _interopRequireDefault(_typeof2);\n\n\tvar _h = __webpack_require__(19);\n\n\tvar _h2 = _interopRequireDefault(_h);\n\n\tvar _shapesMap = __webpack_require__(20);\n\n\tvar _shapesMap2 = _interopRequireDefault(_shapesMap);\n\n\tvar _shape = __webpack_require__(2);\n\n\tvar _shape2 = _interopRequireDefault(_shape);\n\n\tvar _shapeSwirl = __webpack_require__(3);\n\n\tvar _shapeSwirl2 = _interopRequireDefault(_shapeSwirl);\n\n\tvar _burst = __webpack_require__(4);\n\n\tvar _burst2 = _interopRequireDefault(_burst);\n\n\tvar _html = __webpack_require__(5);\n\n\tvar _html2 = _interopRequireDefault(_html);\n\n\tvar _stagger = __webpack_require__(6);\n\n\tvar _stagger2 = _interopRequireDefault(_stagger);\n\n\tvar _spriter = __webpack_require__(7);\n\n\tvar _spriter2 = _interopRequireDefault(_spriter);\n\n\tvar _motionPath = __webpack_require__(21);\n\n\tvar _motionPath2 = _interopRequireDefault(_motionPath);\n\n\tvar _tween = __webpack_require__(8);\n\n\tvar _tween2 = _interopRequireDefault(_tween);\n\n\tvar _timeline = __webpack_require__(9);\n\n\tvar _timeline2 = _interopRequireDefault(_timeline);\n\n\tvar _tweener = __webpack_require__(10);\n\n\tvar _tweener2 = _interopRequireDefault(_tweener);\n\n\tvar _tweenable = __webpack_require__(11);\n\n\tvar _tweenable2 = _interopRequireDefault(_tweenable);\n\n\tvar _thenable = __webpack_require__(12);\n\n\tvar _thenable2 = _interopRequireDefault(_thenable);\n\n\tvar _tunable = __webpack_require__(13);\n\n\tvar _tunable2 = _interopRequireDefault(_tunable);\n\n\tvar _delta = __webpack_require__(14);\n\n\tvar _delta2 = _interopRequireDefault(_delta);\n\n\tvar _deltas = __webpack_require__(15);\n\n\tvar _deltas2 = _interopRequireDefault(_deltas);\n\n\tvar _module = __webpack_require__(16);\n\n\tvar _module2 = _interopRequireDefault(_module);\n\n\tvar _easing = __webpack_require__(22);\n\n\tvar _easing2 = _interopRequireDefault(_easing);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tvar mojs = {\n\t  revision: '0.288.1', isDebug: true, helpers: _h2.default,\n\t  Shape: _shape2.default, ShapeSwirl: _shapeSwirl2.default, Burst: _burst2.default, Html: _html2.default, stagger: _stagger2.default, Spriter: _spriter2.default, MotionPath: _motionPath2.default,\n\t  Tween: _tween2.default, Timeline: _timeline2.default, Tweenable: _tweenable2.default, Thenable: _thenable2.default, Tunable: _tunable2.default, Module: _module2.default,\n\t  tweener: _tweener2.default, easing: _easing2.default, shapesMap: _shapesMap2.default, _pool: { Delta: _delta2.default, Deltas: _deltas2.default }\n\t};\n\n\t// functions alias\n\tmojs.h = mojs.helpers;\n\tmojs.delta = mojs.h.delta;\n\t// custom shape add function and class\n\tmojs.addShape = mojs.shapesMap.addShape;\n\tmojs.CustomShape = mojs.shapesMap.custom;\n\t// module alias\n\tmojs.Transit = mojs.Shape;\n\tmojs.Swirl = mojs.ShapeSwirl;\n\n\t// TODO:\n\t/*\n\t  H/V in paths\n\n\t  rand for direction\n\t  burst children angle after tune\n\t  burst pathScale after tune\n\t  swirl then issue\n\t  'rand' angle flick with `then`\n\t  not able to `play()` in `onComplete` callback\n\t  ---\n\t  module names\n\t  swirls in then chains for x/y\n\t  parse rand(stagger(20, 10), 20) values\n\t  percentage for radius\n\n\t  issue:\n\t    const shape = new mojs.Shape({\n\t      scale: { 0: 1 },\n\t      duration: 1000\n\t    })\n\t    .then({ scale: 0 })\n\t    .then({ scale: 1, onComplete () { this.pause(); } })\n\t    .then({ scale: 0 })\n\t    .then({ scale: 1 })\n\t    ;\n\n\t    document.addEventListener('click', () => {\n\t      shape\n\t        .tune({ fill: 'cyan' })\n\t        .play();\n\t    });\n\t*/\n\n\t// istanbul ignore next\n\tif (true) {\n\t  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t    return mojs;\n\t  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t// istanbul ignore next\n\tif ((false ? 'undefined' : (0, _typeof3.default)(module)) === \"object\" && (0, _typeof3.default)(module.exports) === \"object\") {\n\t  module.exports = mojs;\n\t}\n\n\texports.default = mojs;\n\n\n\ttypeof window !== 'undefined' && (window.mojs = mojs);\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(17)(module)))\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(62);\n\t__webpack_require__(63);\n\tmodule.exports = __webpack_require__(64).Symbol;\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(65);\n\tmodule.exports = __webpack_require__(64).Object.setPrototypeOf;\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(66);\n\tmodule.exports = function create(P, D){\n\t  return $.create(P, D);\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(68);\n\tmodule.exports = __webpack_require__(64).Object.assign;\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(69);\n\tvar Iterators = __webpack_require__(70);\n\tIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $at  = __webpack_require__(71)(true);\n\n\t// 21.1.3.27 String.prototype[@@iterator]()\n\t__webpack_require__(72)(String, 'String', function(iterated){\n\t  this._t = String(iterated); // target\n\t  this._i = 0;                // next index\n\t// 21.1.5.2.1 %StringIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , index = this._i\n\t    , point;\n\t  if(index >= O.length)return {value: undefined, done: true};\n\t  point = $at(O, index);\n\t  this._i += point.length;\n\t  return {value: point, done: false};\n\t});\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(73)\n\t  , get      = __webpack_require__(74);\n\tmodule.exports = __webpack_require__(64).getIterator = function(it){\n\t  var iterFn = get(it);\n\t  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n\t  return anObject(iterFn.call(it));\n\t};\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store  = __webpack_require__(75)('wks')\n\t  , uid    = __webpack_require__(76)\n\t  , Symbol = __webpack_require__(77).Symbol;\n\tmodule.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar $              = __webpack_require__(66)\n\t  , global         = __webpack_require__(77)\n\t  , has            = __webpack_require__(78)\n\t  , DESCRIPTORS    = __webpack_require__(79)\n\t  , $export        = __webpack_require__(80)\n\t  , redefine       = __webpack_require__(81)\n\t  , $fails         = __webpack_require__(82)\n\t  , shared         = __webpack_require__(75)\n\t  , setToStringTag = __webpack_require__(83)\n\t  , uid            = __webpack_require__(76)\n\t  , wks            = __webpack_require__(61)\n\t  , keyOf          = __webpack_require__(84)\n\t  , $names         = __webpack_require__(85)\n\t  , enumKeys       = __webpack_require__(86)\n\t  , isArray        = __webpack_require__(87)\n\t  , anObject       = __webpack_require__(73)\n\t  , toIObject      = __webpack_require__(88)\n\t  , createDesc     = __webpack_require__(89)\n\t  , getDesc        = $.getDesc\n\t  , setDesc        = $.setDesc\n\t  , _create        = $.create\n\t  , getNames       = $names.get\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , setter         = false\n\t  , HIDDEN         = wks('_hidden')\n\t  , isEnum         = $.isEnum\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , useNative      = typeof $Symbol == 'function'\n\t  , ObjectProto    = Object.prototype;\n\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(setDesc({}, 'a', {\n\t    get: function(){ return setDesc(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = getDesc(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  setDesc(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)setDesc(ObjectProto, key, protoDesc);\n\t} : setDesc;\n\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol.prototype);\n\t  sym._k = tag;\n\t  DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {\n\t    configurable: true,\n\t    set: function(value){\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    }\n\t  });\n\t  return sym;\n\t};\n\n\tvar isSymbol = function(it){\n\t  return typeof it == 'symbol';\n\t};\n\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(D && has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))setDesc(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return setDesc(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key);\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key]\n\t    ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  var D = getDesc(it = toIObject(it), key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(!has(AllSymbols, key = names[i++]) && key != HIDDEN)result.push(key);\n\t  return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var names  = getNames(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i)if(has(AllSymbols, key = names[i++]))result.push(AllSymbols[key]);\n\t  return result;\n\t};\n\tvar $stringify = function stringify(it){\n\t  if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t  var args = [it]\n\t    , i    = 1\n\t    , $$   = arguments\n\t    , replacer, $replacer;\n\t  while($$.length > i)args.push($$[i++]);\n\t  replacer = args[1];\n\t  if(typeof replacer == 'function')$replacer = replacer;\n\t  if($replacer || !isArray(replacer))replacer = function(key, value){\n\t    if($replacer)value = $replacer.call(this, key, value);\n\t    if(!isSymbol(value))return value;\n\t  };\n\t  args[1] = replacer;\n\t  return _stringify.apply($JSON, args);\n\t};\n\tvar buggyJSON = $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t});\n\n\t// 19.4.1.1 Symbol([description])\n\tif(!useNative){\n\t  $Symbol = function Symbol(){\n\t    if(isSymbol(this))throw TypeError('Symbol is not a constructor');\n\t    return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));\n\t  };\n\t  redefine($Symbol.prototype, 'toString', function toString(){\n\t    return this._k;\n\t  });\n\n\t  isSymbol = function(it){\n\t    return it instanceof $Symbol;\n\t  };\n\n\t  $.create     = $create;\n\t  $.isEnum     = $propertyIsEnumerable;\n\t  $.getDesc    = $getOwnPropertyDescriptor;\n\t  $.setDesc    = $defineProperty;\n\t  $.setDescs   = $defineProperties;\n\t  $.getNames   = $names.get = $getOwnPropertyNames;\n\t  $.getSymbols = $getOwnPropertySymbols;\n\n\t  if(DESCRIPTORS && !__webpack_require__(90)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t}\n\n\tvar symbolStatics = {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    return keyOf(SymbolRegistry, key);\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t};\n\t// 19.4.2.2 Symbol.hasInstance\n\t// 19.4.2.3 Symbol.isConcatSpreadable\n\t// 19.4.2.4 Symbol.iterator\n\t// 19.4.2.6 Symbol.match\n\t// 19.4.2.8 Symbol.replace\n\t// 19.4.2.9 Symbol.search\n\t// 19.4.2.10 Symbol.species\n\t// 19.4.2.11 Symbol.split\n\t// 19.4.2.12 Symbol.toPrimitive\n\t// 19.4.2.13 Symbol.toStringTag\n\t// 19.4.2.14 Symbol.unscopables\n\t$.each.call((\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,' +\n\t  'species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), function(it){\n\t  var sym = wks(it);\n\t  symbolStatics[it] = useNative ? sym : wrap(sym);\n\t});\n\n\tsetter = true;\n\n\t$export($export.G + $export.W, {Symbol: $Symbol});\n\n\t$export($export.S, 'Symbol', symbolStatics);\n\n\t$export($export.S + $export.F * !useNative, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});\n\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core = module.exports = {version: '1.2.6'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(80);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(91).set});\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 Object.keys(O)\n\tvar toObject = __webpack_require__(92);\n\n\t__webpack_require__(93)('keys', function($keys){\n\t  return function keys(it){\n\t    return $keys(toObject(it));\n\t  };\n\t});\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(80);\n\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(94)});\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(95)\n\t  , step             = __webpack_require__(96)\n\t  , Iterators        = __webpack_require__(70)\n\t  , toIObject        = __webpack_require__(88);\n\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(72)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(97)\n\t  , defined   = __webpack_require__(98);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(90)\n\t  , $export        = __webpack_require__(80)\n\t  , redefine       = __webpack_require__(81)\n\t  , hide           = __webpack_require__(99)\n\t  , has            = __webpack_require__(78)\n\t  , Iterators      = __webpack_require__(70)\n\t  , $iterCreate    = __webpack_require__(100)\n\t  , setToStringTag = __webpack_require__(83)\n\t  , getProto       = __webpack_require__(66).getProto\n\t  , ITERATOR       = __webpack_require__(61)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\n\tvar returnThis = function(){ return this; };\n\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , methods, key;\n\t  // Fix native\n\t  if($native){\n\t    var IteratorPrototype = getProto($default.call(new Base));\n\t    // Set @@toStringTag to native iterators\n\t    setToStringTag(IteratorPrototype, TAG, true);\n\t    // FF fix\n\t    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    // fix Array#{values, @@iterator}.name in V8 / FF\n\t    if(DEF_VALUES && $native.name !== VALUES){\n\t      VALUES_BUG = true;\n\t      $default = function values(){ return $native.call(this); };\n\t    }\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n\t      keys:    IS_SET      ? $default : getMethod(KEYS),\n\t      entries: !DEF_VALUES ? $default : getMethod('entries')\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(101);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(102)\n\t  , ITERATOR  = __webpack_require__(61)('iterator')\n\t  , Iterators = __webpack_require__(70);\n\tmodule.exports = __webpack_require__(64).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(77)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(82)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(77)\n\t  , core      = __webpack_require__(64)\n\t  , ctx       = __webpack_require__(103)\n\t  , PROTOTYPE = 'prototype';\n\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , IS_WRAP   = type & $export.W\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n\t    , key, own, out;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && key in target;\n\t    if(own && key in exports)continue;\n\t    // export native or passed\n\t    out = own ? target[key] : source[key];\n\t    // prevent global pollution for namespaces\n\t    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n\t    // bind timers to global for call from export context\n\t    : IS_BIND && own ? ctx(out, global)\n\t    // wrap global constructors for prevent change them in library\n\t    : IS_WRAP && target[key] == out ? (function(C){\n\t      var F = function(param){\n\t        return this instanceof C ? new C(param) : C(param);\n\t      };\n\t      F[PROTOTYPE] = C[PROTOTYPE];\n\t      return F;\n\t    // make static versions for prototype methods\n\t    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;\n\t  }\n\t};\n\t// type bitmap\n\t$export.F = 1;  // forced\n\t$export.G = 2;  // global\n\t$export.S = 4;  // static\n\t$export.P = 8;  // proto\n\t$export.B = 16; // bind\n\t$export.W = 32; // wrap\n\tmodule.exports = $export;\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(99);\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(66).setDesc\n\t  , has = __webpack_require__(78)\n\t  , TAG = __webpack_require__(61)('toStringTag');\n\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $         = __webpack_require__(66)\n\t  , toIObject = __webpack_require__(88);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = $.getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(88)\n\t  , getNames  = __webpack_require__(66).getNames\n\t  , toString  = {}.toString;\n\n\tvar windowNames = typeof window == 'object' && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return getNames(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\n\tmodule.exports.get = function getOwnPropertyNames(it){\n\t  if(windowNames && toString.call(it) == '[object Window]')return getWindowNames(it);\n\t  return getNames(toIObject(it));\n\t};\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar $ = __webpack_require__(66);\n\tmodule.exports = function(it){\n\t  var keys       = $.getKeys(it)\n\t    , getSymbols = $.getSymbols;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = $.isEnum\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))keys.push(key);\n\t  }\n\t  return keys;\n\t};\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(104);\n\tmodule.exports = Array.isArray || function(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(105)\n\t  , defined = __webpack_require__(98);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = true;\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar getDesc  = __webpack_require__(66).getDesc\n\t  , isObject = __webpack_require__(101)\n\t  , anObject = __webpack_require__(73);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(103)(Function.call, getDesc(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(98);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// most Object methods by ES6 should accept primitives\n\tvar $export = __webpack_require__(80)\n\t  , core    = __webpack_require__(64)\n\t  , fails   = __webpack_require__(82);\n\tmodule.exports = function(KEY, exec){\n\t  var fn  = (core.Object || {})[KEY] || Object[KEY]\n\t    , exp = {};\n\t  exp[KEY] = exec(fn);\n\t  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n\t};\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar $        = __webpack_require__(66)\n\t  , toObject = __webpack_require__(92)\n\t  , IObject  = __webpack_require__(105);\n\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = __webpack_require__(82)(function(){\n\t  var a = Object.assign\n\t    , A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , $$    = arguments\n\t    , $$len = $$.length\n\t    , index = 1\n\t    , getKeys    = $.getKeys\n\t    , getSymbols = $.getSymbols\n\t    , isEnum     = $.isEnum;\n\t  while($$len > index){\n\t    var S      = IObject($$[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  }\n\t  return T;\n\t} : Object.assign;\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(){ /* empty */ };\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $          = __webpack_require__(66)\n\t  , createDesc = __webpack_require__(89);\n\tmodule.exports = __webpack_require__(79) ? function(object, key, value){\n\t  return $.setDesc(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $              = __webpack_require__(66)\n\t  , descriptor     = __webpack_require__(89)\n\t  , setToStringTag = __webpack_require__(83)\n\t  , IteratorPrototype = {};\n\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(99)(IteratorPrototype, __webpack_require__(61)('iterator'), function(){ return this; });\n\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(104)\n\t  , TAG = __webpack_require__(61)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(106);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toString = {}.toString;\n\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(104);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ }\n/******/ ])\n});\n;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9tby1qcy9idWlsZC9tby5qcz9lNjkyIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibW9qc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJtb2pzXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcImJ1aWxkL1wiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cblxuLyoqKi8gfSxcbi8qIDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSgnaXRlcmF0b3InKTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0dmFyIF90aGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cdHZhciBfdGhlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbmFibGUpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cdHZhciBfdHVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dW5hYmxlKTtcblxuXHR2YXIgX3R3ZWVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdHZhciBfdHdlZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuYWJsZSk7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgQml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cdHZhciBzaGFwZXNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcblxuXG5cdC8vIFRPRE9cblx0Ly8gIC0gcmVmYWN0b3Jcblx0Ly8gICAgLSBhZGQgc2V0SWZDaGFuZ2VkIHRvIE1vZHVsZVxuXHQvLyAgLS1cblx0Ly8gIC0gdHdlZW4gZm9yIGV2ZXJ5IHByb3BcblxuXHR2YXIgU2hhcGUgPSBmdW5jdGlvbiAoX1R1bmFibGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShTaGFwZSwgX1R1bmFibGUpO1xuXG5cdCAgZnVuY3Rpb24gU2hhcGUoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTaGFwZSk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfVHVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICAvLyBERUZBVUxUUyAvIEFQSXNcblx0ICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuXHQgICAgICAvLyB3aGVyZSB0byBhcHBlbmQgdGhlIG1vZHVsZSB0byBbc2VsZWN0b3IsIEhUTUxFbGVtZW50XVxuXHQgICAgICBwYXJlbnQ6IGRvY3VtZW50LmJvZHksXG5cdCAgICAgIC8vIGNsYXNzIG5hbWUgZm9yIHRoZSBgZWxgXG5cdCAgICAgIGNsYXNzTmFtZTogJycsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogW2NpcmNsZSwgbGluZSwgemlnemFnLCByZWN0LCBwb2x5Z29uLCBjcm9zcywgZXF1YWwgXVxuXHQgICAgICBzaGFwZTogJ2NpcmNsZScsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFtjb2xvciBuYW1lLCByZ2IsIHJnYmEsIGhleF1cblx0ICAgICAgc3Ryb2tlOiAndHJhbnNwYXJlbnQnLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIDAuLjEgXVxuXHQgICAgICBzdHJva2VPcGFjaXR5OiAxLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsnYnV0dCcgfCAncm91bmQnIHwgJ3NxdWFyZSddXG5cdCAgICAgIHN0cm9rZUxpbmVjYXA6ICcnLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHN0cm9rZVdpZHRoOiAyLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgc3Ryb2tlRGFzaGFycmF5OiAwLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgc3Ryb2tlRGFzaG9mZnNldDogMCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogW2NvbG9yIG5hbWUsIHJnYiwgcmdiYSwgaGV4XVxuXHQgICAgICBmaWxsOiAnZGVlcHBpbmsnLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIDAuLjEgXVxuXHQgICAgICBmaWxsT3BhY2l0eTogMSxcblx0ICAgICAgLy8ge0Jvb2xlYW59IC0gaWYgc2hvdWxkIGhpZGUgbW9kdWxlIHdpdGggYG9wYWNpdHlgIGluc3RlYWQgb2YgYGRpc3BsYXlgXG5cdCAgICAgIGlzU29mdEhpZGU6IHRydWUsXG5cdCAgICAgIC8vIHtCb29sZWFufSAtIGlmIHNob3VsZCB0cmlnZ2VyIGNvbXBvc2l0ZSBsYXllciBmb3IgdGhlIGBlbGBcblx0ICAgICAgaXNGb3JjZTNkOiBmYWxzZSxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIGxlZnQ6ICc1MCUnLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgdG9wOiAnNTAlJyxcblx0ICAgICAgLy8g4oiGIDo6IFVuaXRzIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIHg6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICB5OiAwLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIGFuZ2xlOiAwLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHNjYWxlOiAxLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdIEZhbGxiYWNrcyB0byBgc2NhbGVgLlxuXHQgICAgICBzY2FsZVg6IG51bGwsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF0gRmFsbGJhY2tzIHRvIGBzY2FsZWAuXG5cdCAgICAgIHNjYWxlWTogbnVsbCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIsIHN0cmluZyBdXG5cdCAgICAgIG9yaWdpbjogJzUwJSA1MCUnLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIDAuLjEgXVxuXHQgICAgICBvcGFjaXR5OiAxLFxuXHQgICAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgICAgcng6IDAsXG5cdCAgICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgICByeTogMCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICBwb2ludHM6IDMsXG5cdCAgICAgIC8vIOKIhiA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblx0ICAgICAgcmFkaXVzOiA1MCxcblx0ICAgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICByYWRpdXNYOiBudWxsLFxuXHQgICAgICAvLyDiiIYgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciBdXG5cdCAgICAgIHJhZGl1c1k6IG51bGwsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBib29sZWFuIF1cblx0ICAgICAgaXNTaG93U3RhcnQ6IGZhbHNlLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgYm9vbGVhbiBdXG5cdCAgICAgIGlzU2hvd0VuZDogdHJ1ZSxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIGJvb2xlYW4gXVxuXHQgICAgICBpc1JlZnJlc2hTdGF0ZTogdHJ1ZSxcblx0ICAgICAgLy8gUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciA+IDAgXVxuXHQgICAgICBkdXJhdGlvbjogNDAwLFxuXHQgICAgICAvLyBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyIF1cblxuXHQgICAgICAvKiB0ZWNobmljYWwgb25lczogKi9cblx0ICAgICAgLy8gZXhwbGljaXQgd2lkdGggb2YgdGhlIG1vZHVsZSBjYW52YXNcblx0ICAgICAgd2lkdGg6IG51bGwsXG5cdCAgICAgIC8vIGV4cGxpY2l0IGhlaWdodCBvZiB0aGUgbW9kdWxlIGNhbnZhc1xuXHQgICAgICBoZWlnaHQ6IG51bGwsXG5cdCAgICAgIC8vIFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgICAvLyBzaXplR2FwOiAgICAgICAgICAwLFxuXHQgICAgICAvKiBbYm9vbGVhbl0gOjogSWYgc2hvdWxkIGhhdmUgY2hpbGQgc2hhcGUuICovXG5cdCAgICAgIGlzV2l0aFNoYXBlOiB0cnVlLFxuXHQgICAgICAvLyBjb250ZXh0IGZvciBhbGwgdGhlIGNhbGxiYWNrc1xuXHQgICAgICBjYWxsYmFja3NDb250ZXh0OiB0aGlzXG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGggb3B0aW9uYWwgbmV3IG9wdGlvbnMuXG5cdCAgICBAcHVibGljXG5cdCAgICBAb3ZlcnJpZGVzIEAgVHVuYWJsZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE5ldyBvcHRpb25zIHRvIHNldCBvbiB0aGUgcnVuLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUudHVuZSA9IGZ1bmN0aW9uIHR1bmUobykge1xuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLnR1bmUuY2FsbCh0aGlzLCBvKTtcblx0ICAgIC8vIHVwZGF0ZSBzaGFwZU1vZHVsZSdzIHNpemUgdG8gdGhlIG1heCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgIHRoaXMuX2dldE1heFNpemVJbkNoYWluKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIGEgdGhlbiByZWNvcmQgZm9yIHRoZSBtb2R1bGUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAb3ZlcnJpZGVzIEAgVGhlbmFibGVcblx0ICAgIEBwYXJhbSAgICB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGUgbmV4dCBhbmltYXRpb24uXG5cdCAgICBAcmV0dXJucyAge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gdGhpcy5fbWFrZVRpbWVsaW5lKClcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywgbyk7XG5cdCAgICAvLyB1cGRhdGUgc2hhcGVNb2R1bGUncyBzaXplIHRvIHRoZSBtYXggaW4gYHRoZW5gIGNoYWluXG5cdCAgICB0aGlzLl9nZXRNYXhTaXplSW5DaGFpbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIHZhcmlhYmxlcy5cblx0ICAgIEBvdmVycmlkZXMgVGhlbmFibGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIC8vIGNhbGwgX3ZhcnMgbWV0aG9kIG9uIFRoZW5hYmxlXG5cdCAgICBfVHVuYWJsZS5wcm90b3R5cGUuX3ZhcnMuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2xhc3RTZXQgPSB7fTtcblx0ICAgIC8vIHNhdmUgcHJldmlvdXMgbW9kdWxlIGluIHRoZSBjaGFpblxuXHQgICAgdGhpcy5fcHJldkNoYWluTW9kdWxlID0gdGhpcy5fby5wcmV2Q2hhaW5Nb2R1bGU7XG5cdCAgICAvLyBzaG91bGQgZHJhdyBvbiBmb3JlaWduIHN2ZyBjYW52YXNcblx0ICAgIHRoaXMuaXNGb3JlaWduID0gISF0aGlzLl9vLmN0eDtcblx0ICAgIC8vIHRoaXMuX28uaXNUaW1lbGluZUxlc3MgPSB0cnVlO1xuXHQgICAgLy8gc2hvdWxkIHRha2UgYW4gc3ZnIGVsZW1lbnQgYXMgc2VsZiBiaXRcblx0ICAgIHJldHVybiB0aGlzLmlzRm9yZWlnbkJpdCA9ICEhdGhpcy5fby5zaGFwZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5pdGlhbGl6ZSBtb2R1bGVzIHByZXNlbnRhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIGlmICghdGhpcy5faXNSZW5kZXJlZCAmJiAhdGhpcy5faXNDaGFpbmVkKSB7XG5cdCAgICAgIC8vIGNyZWF0ZSBgbW9qc2Agc2hhcGUgZWxlbWVudFxuXHQgICAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICAgIC8vIHNldCBuYW1lIG9uIHRoZSBgZWxgXG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5hbWUnLCAnbW9qcy1zaGFwZScpO1xuXHQgICAgICAvLyBzZXQgY2xhc3Mgb24gdGhlIGBlbGBcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5fcHJvcHMuY2xhc3NOYW1lKTtcblx0ICAgICAgLy8gY3JlYXRlIHNoYXBlIG1vZHVsZVxuXHQgICAgICB0aGlzLl9jcmVhdGVTaGFwZSgpO1xuXHQgICAgICAvLyBhcHBlbmQgYGVsYCB0byBwYXJlbnRcblx0ICAgICAgdGhpcy5fcHJvcHMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXHQgICAgICAvLyBzZXQgcG9zaXRpb24gc3R5bGVzIG9uIHRoZSBlbFxuXHQgICAgICB0aGlzLl9zZXRFbFN0eWxlcygpO1xuXHQgICAgICAvLyBzZXQgaW5pdGlhbCBwb3NpdGlvbiBmb3IgdGhlIGZpcnN0IG1vZHVsZSBpbiB0aGUgY2hhaW5cblx0ICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoMCwgMCk7XG5cdCAgICAgIC8vIHNob3cgYXQgc3RhcnQgaWYgYGlzU2hvd1N0YXJ0YFxuXHQgICAgICBpZiAodGhpcy5fcHJvcHMuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgICB0aGlzLl9zaG93KCk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5faGlkZSgpO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHNldCBgX2lzUmVuZGVyZWRgIGhhdGNoXG5cdCAgICAgIHRoaXMuX2lzUmVuZGVyZWQgPSB0cnVlO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9pc0NoYWluZWQpIHtcblx0ICAgICAgLy8gc2F2ZSBlbGVtZW50cyBmcm9tIG1hc3RlciBtb2R1bGVcblx0ICAgICAgdGhpcy5lbCA9IHRoaXMuX21hc3Rlck1vZHVsZS5lbDtcblx0ICAgICAgdGhpcy5zaGFwZU1vZHVsZSA9IHRoaXMuX21hc3Rlck1vZHVsZS5zaGFwZU1vZHVsZTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBlbCBzdHlsZXMgb24gaW5pdGlhbGl6YXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fc2V0RWxTdHlsZXMgPSBmdW5jdGlvbiBfc2V0RWxTdHlsZXMoKSB7XG5cdCAgICBpZiAoIXRoaXMuZWwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgKCF0aGlzLmlzRm9yZWlnbikge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBzdHlsZSA9IHRoaXMuZWwuc3R5bGUsXG5cdCAgICAgICAgd2lkdGggPSBwLnNoYXBlV2lkdGgsXG5cdCAgICAgICAgaGVpZ2h0ID0gcC5zaGFwZUhlaWdodDtcblxuXHQgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHQgICAgdGhpcy5fc2V0RWxTaXplU3R5bGVzKHdpZHRoLCBoZWlnaHQpO1xuXG5cdCAgICBpZiAocC5pc0ZvcmNlM2QpIHtcblx0ICAgICAgdmFyIG5hbWUgPSAnYmFja2ZhY2UtdmlzaWJpbGl0eSc7XG5cdCAgICAgIHN0eWxlWycnICsgbmFtZV0gPSAnaGlkZGVuJztcblx0ICAgICAgc3R5bGVbJycgKyBoLnByZWZpeC5jc3MgKyBuYW1lXSA9ICdoaWRkZW4nO1xuXHQgICAgfVxuXHQgICAgLy8gfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgYHdpZHRoYC9gaGVpZ2h0YC9gbWFyZ2luc2AgdG8gdGhlIGBlbGAgc3R5bGVzLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFdpZHRoLlxuXHQgICAgQHBhcmFtIHtoZWlnaHR9IEhlaWdodC5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3NldEVsU2l6ZVN0eWxlcyA9IGZ1bmN0aW9uIF9zZXRFbFNpemVTdHlsZXMod2lkdGgsIGhlaWdodCkge1xuXHQgICAgdmFyIHN0eWxlID0gdGhpcy5lbC5zdHlsZTtcblx0ICAgIHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHQgICAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jztcblx0ICAgIHN0eWxlWydtYXJnaW4tbGVmdCddID0gLXdpZHRoIC8gMiArICdweCc7XG5cdCAgICBzdHlsZVsnbWFyZ2luLXRvcCddID0gLWhlaWdodCAvIDIgKyAncHgnO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiBfZHJhdygpIHtcblx0ICAgIGlmICghdGhpcy5zaGFwZU1vZHVsZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgYlAgPSB0aGlzLnNoYXBlTW9kdWxlLl9wcm9wcztcblx0ICAgIC8vIHNldCBwcm9wcyBvbiBiaXRcblx0ICAgIC8vIGJQLnggICAgICAgICAgICAgICAgICAgID0gdGhpcy5fb3JpZ2luLng7XG5cdCAgICAvLyBiUC55ICAgICAgICAgICAgICAgICAgICA9IHRoaXMuX29yaWdpbi55O1xuXHQgICAgYlAucnggPSBwLnJ4O1xuXHQgICAgYlAucnkgPSBwLnJ5O1xuXHQgICAgYlAuc3Ryb2tlID0gcC5zdHJva2U7XG5cdCAgICBiUFsnc3Ryb2tlLXdpZHRoJ10gPSBwLnN0cm9rZVdpZHRoO1xuXHQgICAgYlBbJ3N0cm9rZS1vcGFjaXR5J10gPSBwLnN0cm9rZU9wYWNpdHk7XG5cdCAgICBiUFsnc3Ryb2tlLWRhc2hhcnJheSddID0gcC5zdHJva2VEYXNoYXJyYXk7XG5cdCAgICBiUFsnc3Ryb2tlLWRhc2hvZmZzZXQnXSA9IHAuc3Ryb2tlRGFzaG9mZnNldDtcblx0ICAgIGJQWydzdHJva2UtbGluZWNhcCddID0gcC5zdHJva2VMaW5lY2FwO1xuXHQgICAgYlBbJ2ZpbGwnXSA9IHAuZmlsbDtcblx0ICAgIGJQWydmaWxsLW9wYWNpdHknXSA9IHAuZmlsbE9wYWNpdHk7XG5cdCAgICBiUC5yYWRpdXMgPSBwLnJhZGl1cztcblx0ICAgIGJQLnJhZGl1c1ggPSBwLnJhZGl1c1g7XG5cdCAgICBiUC5yYWRpdXNZID0gcC5yYWRpdXNZO1xuXHQgICAgYlAucG9pbnRzID0gcC5wb2ludHM7XG5cblx0ICAgIHRoaXMuc2hhcGVNb2R1bGUuX2RyYXcoKTtcblx0ICAgIHRoaXMuX2RyYXdFbCgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgY3VycmVudCBtb2R1bGVzIHByb3BzIHRvIG1haW4gZGl2IGVsLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2RyYXdFbCA9IGZ1bmN0aW9uIF9kcmF3RWwoKSB7XG5cdCAgICAvLyByZXR1cm47XG5cdCAgICBpZiAodGhpcy5lbCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG5cblx0ICAgIC8vIHN0eWxlLm9wYWNpdHkgPSBwLm9wYWNpdHk7XG5cdCAgICB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdvcGFjaXR5JykgJiYgKHN0eWxlLm9wYWNpdHkgPSBwLm9wYWNpdHkpO1xuXHQgICAgaWYgKCF0aGlzLmlzRm9yZWlnbikge1xuXHQgICAgICB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdsZWZ0JykgJiYgKHN0eWxlLmxlZnQgPSBwLmxlZnQpO1xuXHQgICAgICB0aGlzLl9pc1Byb3BDaGFuZ2VkKCd0b3AnKSAmJiAoc3R5bGUudG9wID0gcC50b3ApO1xuXG5cdCAgICAgIHZhciBpc1ggPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCd4JyksXG5cdCAgICAgICAgICBpc1kgPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCd5JyksXG5cdCAgICAgICAgICBpc1RyYW5zbGF0ZSA9IGlzWCB8fCBpc1ksXG5cdCAgICAgICAgICBpc1NjYWxlWCA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ3NjYWxlWCcpLFxuXHQgICAgICAgICAgaXNTY2FsZVkgPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdzY2FsZVknKSxcblx0ICAgICAgICAgIGlzU2NhbGUgPSB0aGlzLl9pc1Byb3BDaGFuZ2VkKCdzY2FsZScpLFxuXHQgICAgICAgICAgaXNTY2FsZSA9IGlzU2NhbGUgfHwgaXNTY2FsZVggfHwgaXNTY2FsZVksXG5cdCAgICAgICAgICBpc1JvdGF0ZSA9IHRoaXMuX2lzUHJvcENoYW5nZWQoJ2FuZ2xlJyk7XG5cblx0ICAgICAgaWYgKGlzVHJhbnNsYXRlIHx8IGlzU2NhbGUgfHwgaXNSb3RhdGUpIHtcblx0ICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5fZmlsbFRyYW5zZm9ybSgpO1xuXHQgICAgICAgIHN0eWxlW2gucHJlZml4LmNzcyArICd0cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybTtcblx0ICAgICAgICBzdHlsZVsndHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5faXNQcm9wQ2hhbmdlZCgnb3JpZ2luJykgfHwgdGhpcy5fZGVsdGFzWydvcmlnaW4nXSkge1xuXHQgICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLl9maWxsT3JpZ2luKCk7XG5cdCAgICAgICAgc3R5bGVbaC5wcmVmaXguY3NzICsgJ3RyYW5zZm9ybS1vcmlnaW4nXSA9IG9yaWdpbjtcblx0ICAgICAgICBzdHlsZVsndHJhbnNmb3JtLW9yaWdpbiddID0gb3JpZ2luO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHByb3BlcnR5IGNoYW5nZWQgYWZ0ZXIgdGhlIGxhdGVzdCBjaGVjay5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2suXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX2lzUHJvcENoYW5nZWQgPSBmdW5jdGlvbiBfaXNQcm9wQ2hhbmdlZChuYW1lKSB7XG5cdCAgICAvLyBpZiB0aGVyZSBpcyBubyByZWNvZCBmb3IgdGhlIHByb3BlcnR5IC0gY3JlYXRlIGl0XG5cdCAgICBpZiAodGhpcy5fbGFzdFNldFtuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX2xhc3RTZXRbbmFtZV0gPSB7fTtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLl9sYXN0U2V0W25hbWVdLnZhbHVlICE9PSB0aGlzLl9wcm9wc1tuYW1lXSkge1xuXHQgICAgICB0aGlzLl9sYXN0U2V0W25hbWVdLnZhbHVlID0gdGhpcy5fcHJvcHNbbmFtZV07XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0dW5lIG5ldyBvcHRpb24gb24gcnVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9ICBPcHRpb24gdG8gdHVuZSBvbiBydW4uXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl90dW5lTmV3T3B0aW9ucyA9IGZ1bmN0aW9uIF90dW5lTmV3T3B0aW9ucyhvKSB7XG5cdCAgICAvLyBjYWxsIHN1cGVyIG9uIE1vZHVsZVxuXHQgICAgX1R1bmFibGUucHJvdG90eXBlLl90dW5lTmV3T3B0aW9ucy5jYWxsKHRoaXMsIG8pO1xuXHQgICAgLy8gcmV0dXJuIGlmIGVtcHR5IG9iamVjdFxuXHQgICAgaWYgKCEobyAhPSBudWxsICYmICgwLCBfa2V5czIuZGVmYXVsdCkobykubGVuZ3RoKSkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblxuXHQgICAgLy8gdGhpcy5fY2FsY1NpemUoKTtcblx0ICAgIHRoaXMuX3NldEVsU3R5bGVzKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBtYXggcmFkaXVzWCB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUmFkaXVzIG5hbWUuXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9nZXRNYXhSYWRpdXMgPSBmdW5jdGlvbiBfZ2V0TWF4UmFkaXVzKG5hbWUpIHtcblx0ICAgIHZhciBzZWxmU2l6ZSwgc2VsZlNpemVYO1xuXHQgICAgc2VsZlNpemUgPSB0aGlzLl9nZXRSYWRpdXNTaXplKCdyYWRpdXMnKTtcblx0ICAgIHJldHVybiB0aGlzLl9nZXRSYWRpdXNTaXplKG5hbWUsIHNlbGZTaXplKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5jcmVhc2UgY2FsY3VsYXRlZCBzaXplIGJhc2VkIG9uIGVhc2luZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9pbmNyZWFzZVNpemVXaXRoRWFzaW5nID0gZnVuY3Rpb24gX2luY3JlYXNlU2l6ZVdpdGhFYXNpbmcoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGVhc2luZyA9IHRoaXMuX28uZWFzaW5nLFxuXHQgICAgICAgIGlzU3RyaW5nRWFzaW5nID0gZWFzaW5nICYmIHR5cGVvZiBlYXNpbmcgPT09ICdzdHJpbmcnO1xuXG5cdCAgICBzd2l0Y2ggKGlzU3RyaW5nRWFzaW5nICYmIGVhc2luZy50b0xvd2VyQ2FzZSgpKSB7XG5cdCAgICAgIGNhc2UgJ2VsYXN0aWMub3V0Jzpcblx0ICAgICAgY2FzZSAnZWxhc3RpYy5pbm91dCc6XG5cdCAgICAgICAgcC5zaXplICo9IDEuMjU7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIGNhc2UgJ2JhY2sub3V0Jzpcblx0ICAgICAgY2FzZSAnYmFjay5pbm91dCc6XG5cdCAgICAgICAgcC5zaXplICo9IDEuMTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5jcmVhc2UgY2FsY3VsYXRlZCBzaXplIGJhc2VkIG9uIGJpdCByYXRpby5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblx0ICAvLyBfaW5jcmVhc2VTaXplV2l0aEJpdFJhdGlvICgpIHtcblx0ICAvLyAgIHZhciBwICAgPSB0aGlzLl9wcm9wcztcblx0ICAvLyAgIC8vIHAuc2l6ZSAqPSB0aGlzLnNoYXBlLl9wcm9wcy5yYXRpbztcblx0ICAvLyAgIHAuc2l6ZSArPSAyICogcC5zaXplR2FwO1xuXHQgIC8vIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBtYXhpbXVtIHJhZGl1cyBzaXplIHdpdGggb3B0aW9uYWwgZmFsbGJhY2suXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9XG5cdCAgICAgIEBwYXJhbSBrZXkge1N0cmluZ30gTmFtZSBvZiB0aGUgcmFkaXVzIC0gW3JhZGl1c3xyYWRpdXNYfHJhZGl1c1ldLlxuXHQgICAgICBAcGFyYW0gQG9wdGlvbmFsIGZhbGxiYWNrIHtOdW1iZXJ9ICBPcHRpb25hbCBudW1iZXIgdG8gc2V0IGlmIHRoZXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG5vIHZhbHVlIGZvciB0aGUga2V5LlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0UmFkaXVzU2l6ZSA9IGZ1bmN0aW9uIF9nZXRSYWRpdXNTaXplKG5hbWUpIHtcblx0ICAgIHZhciBmYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMV07XG5cblx0ICAgIHZhciBkZWx0YSA9IHRoaXMuX2RlbHRhc1tuYW1lXTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIGRlbHRhIHZhbHVlXG5cdCAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuXHQgICAgICAvLyBnZXQgbWF4aW11bSBudW1iZXIgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcyBvZiB0aGUgZGVsdGFcblx0ICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKGRlbHRhLmVuZCksIE1hdGguYWJzKGRlbHRhLnN0YXJ0KSk7XG5cdCAgICB9IGVsc2UgaWYgKHRoaXMuX3Byb3BzW25hbWVdICE9IG51bGwpIHtcblx0ICAgICAgLy8gZWxzZSBnZXQgdGhlIHZhbHVlIGZyb20gcHJvcHMgb2JqZWN0XG5cdCAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBmYWxsYmFjaztcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IG1heCBzaGFwZSBjYW52YXMgc2l6ZSBhbmQgc2F2ZSBpdCB0byBfcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0U2hhcGVTaXplID0gZnVuY3Rpb24gX2dldFNoYXBlU2l6ZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cblx0ICAgIC8vIGdldCBtYXhpbXVtIHN0cm9rZSB2YWx1ZVxuXHQgICAgc3Ryb2tlID0gdGhpcy5fZ2V0TWF4U3Ryb2tlKCk7XG5cdCAgICAvLyBzYXZlIHNoYXBlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHRvIGBfcHJvcHNgXG5cdCAgICBwLnNoYXBlV2lkdGggPSBwLndpZHRoICE9IG51bGwgPyBwLndpZHRoIDogMiAqIHRoaXMuX2dldE1heFJhZGl1cygncmFkaXVzWCcpICsgc3Ryb2tlO1xuXG5cdCAgICBwLnNoYXBlSGVpZ2h0ID0gcC5oZWlnaHQgIT0gbnVsbCA/IHAuaGVpZ2h0IDogMiAqIHRoaXMuX2dldE1heFJhZGl1cygncmFkaXVzWScpICsgc3Ryb2tlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiBfY3JlYXRlU2hhcGUoKSB7XG5cdCAgICAvLyBjYWxjdWxhdGUgbWF4IHNoYXBlIGNhbnZhcyBzaXplIGFuZCBzZXQgdG8gX3Byb3BzXG5cdCAgICB0aGlzLl9nZXRTaGFwZVNpemUoKTtcblx0ICAgIC8vIGRvbid0IGNyZWF0ZSBhY3R1YWwgc2hhcGUgaWYgIWBpc1dpdGhTaGFwZWBcblx0ICAgIGlmICghdGhpcy5fcHJvcHMuaXNXaXRoU2hhcGUpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgLy8gZ2V0IHNoYXBlJ3MgY2xhc3Ncblx0ICAgIHZhciBTaGFwZSA9IHNoYXBlc01hcC5nZXRTaGFwZSh0aGlzLl9wcm9wcy5zaGFwZSk7XG5cdCAgICAvLyBjcmVhdGUgYF9zaGFwZWAgbW9kdWxlXG5cdCAgICB0aGlzLnNoYXBlTW9kdWxlID0gbmV3IFNoYXBlKHtcblx0ICAgICAgd2lkdGg6IHAuc2hhcGVXaWR0aCxcblx0ICAgICAgaGVpZ2h0OiBwLnNoYXBlSGVpZ2h0LFxuXHQgICAgICBwYXJlbnQ6IHRoaXMuZWxcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4IHNpemUgaW4gYHRoZW5gIGNoYWluXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZ2V0TWF4U2l6ZUluQ2hhaW4gPSBmdW5jdGlvbiBfZ2V0TWF4U2l6ZUluQ2hhaW4oKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIG1heFcgPSAwLFxuXHQgICAgICAgIG1heEggPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fbW9kdWxlc1tpXS5fZ2V0U2hhcGVTaXplKCk7XG5cdCAgICAgIG1heFcgPSBNYXRoLm1heChtYXhXLCB0aGlzLl9tb2R1bGVzW2ldLl9wcm9wcy5zaGFwZVdpZHRoKTtcblx0ICAgICAgbWF4SCA9IE1hdGgubWF4KG1heEgsIHRoaXMuX21vZHVsZXNbaV0uX3Byb3BzLnNoYXBlSGVpZ2h0KTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5zaGFwZU1vZHVsZSAmJiB0aGlzLnNoYXBlTW9kdWxlLl9zZXRTaXplKG1heFcsIG1heEgpO1xuXHQgICAgdGhpcy5fc2V0RWxTaXplU3R5bGVzKG1heFcsIG1heEgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgbWF4IHZhbHVlIG9mIHRoZSBzdHJva2VXaWR0aC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9nZXRNYXhTdHJva2UgPSBmdW5jdGlvbiBfZ2V0TWF4U3Ryb2tlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHZhciBkU3Ryb2tlID0gdGhpcy5fZGVsdGFzWydzdHJva2VXaWR0aCddO1xuXHQgICAgcmV0dXJuIGRTdHJva2UgIT0gbnVsbCA/IE1hdGgubWF4KGRTdHJva2Uuc3RhcnQsIGRTdHJva2UuZW5kKSA6IHAuc3Ryb2tlV2lkdGg7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtICAge051bWJlcn0gIEVhc2VkUHJvZ3Jlc3MgdG8gc2V0IC0gWzAuLjFdLlxuXHQgICAgQHBhcmFtICAge051bWJlcn0gIFByb2dyZXNzIHRvIHNldCAtIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICAvLyBjYWxsIHRoZSBzdXBlciBvbiBNb2R1bGVcblx0ICAgIF9tb2R1bGUyLmRlZmF1bHQucHJvdG90eXBlLl9zZXRQcm9ncmVzcy5jYWxsKHRoaXMsIGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICAgIC8vIGRyYXcgY3VycmVudCBwcm9ncmVzc1xuXHQgICAgdGhpcy5fZHJhdyhlYXNlZFByb2dyZXNzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYWRkIGNhbGxiYWNrIG92ZXJyaWRlcyB0byBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gYWRkIHRoZSBvdmVycmlkZXMgdG8uXG5cdCAgKi9cblxuXG5cdCAgU2hhcGUucHJvdG90eXBlLl9hcHBseUNhbGxiYWNrT3ZlcnJpZGVzID0gZnVuY3Rpb24gX2FwcGx5Q2FsbGJhY2tPdmVycmlkZXMob2JqKSB7XG5cdCAgICB2YXIgaXQgPSB0aGlzLFxuXHQgICAgICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIHNwZWNpZnkgY29udHJvbCBmdW5jdGlvbnMgZm9yIHRoZSBtb2R1bGVcblx0ICAgIG9iai5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGVwLCBwKSB7XG5cdCAgICAgICAgcmV0dXJuIGl0Ll9zZXRQcm9ncmVzcyhlcCwgcCk7XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoaXNGd2QpIHtcblx0ICAgICAgICAvLyBkb24ndCB0b3VjaCBtYWluIGBlbGAgb25TdGFydCBpbiBjaGFpbmVkIGVsZW1lbnRzXG5cdCAgICAgICAgaWYgKGl0Ll9pc0NoYWluZWQpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGlmIChpc0Z3ZCkge1xuXHQgICAgICAgICAgaXQuX3Nob3coKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKCFwLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgICAgICAgIGl0Ll9oaWRlKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIGlmIG5vdCB0aGUgbGFzdCBpbiBgdGhlbmAgY2hhaW5cblx0ICAgICAgICBpZiAoIWl0Ll9pc0xhc3RJbkNoYWluKCkpIHtcblx0ICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGlzRndkKSB7XG5cdCAgICAgICAgICBpZiAoIXAuaXNTaG93RW5kKSB7XG5cdCAgICAgICAgICAgIGl0Ll9oaWRlKCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGl0Ll9zaG93KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXHQgICAgICBvblJlZnJlc2g6IGZ1bmN0aW9uIG9uUmVmcmVzaChpc0JlZm9yZSkge1xuXHQgICAgICAgIHAuaXNSZWZyZXNoU3RhdGUgJiYgaXNCZWZvcmUgJiYgaXQuX3JlZnJlc2hCZWZvcmUoKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0dXAgdHdlZW4gYW5kIHRpbWVsaW5lIG9wdGlvbnMgYmVmb3JlIGNyZWF0aW5nIHRoZW0uXG5cdCAgICBAb3ZlcnJpZGUgQCBUd2VlbmFibGVcblx0ICAgIEBwcml2YXRlICBcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3RyYW5zZm9ybVR3ZWVuT3B0aW9ucyA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1Ud2Vlbk9wdGlvbnMoKSB7XG5cdCAgICB0aGlzLl9hcHBseUNhbGxiYWNrT3ZlcnJpZGVzKHRoaXMuX28pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdHJhbnNmb3JtIHN0cmluZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBUcmFuc2Zvcm0gc3RyaW5nLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZmlsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9maWxsVHJhbnNmb3JtKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBzY2FsZVggPSBwLnNjYWxlWCAhPSBudWxsID8gcC5zY2FsZVggOiBwLnNjYWxlLFxuXHQgICAgICAgIHNjYWxlWSA9IHAuc2NhbGVZICE9IG51bGwgPyBwLnNjYWxlWSA6IHAuc2NhbGUsXG5cdCAgICAgICAgc2NhbGUgPSBzY2FsZVggKyAnLCAnICsgc2NhbGVZO1xuXHQgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHAueCArICcsICcgKyBwLnkgKyAnKSByb3RhdGUoJyArIHAuYW5nbGUgKyAnZGVnKSBzY2FsZSgnICsgc2NhbGUgKyAnKSc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0cmFuc2Zvcm0tb3JpZ2luIHN0cmluZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBUcmFuc2Zvcm0gc3RyaW5nLlxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fZmlsbE9yaWdpbiA9IGZ1bmN0aW9uIF9maWxsT3JpZ2luKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBzdHIgPSAnJztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5vcmlnaW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3RyICs9IHAub3JpZ2luW2ldLnN0cmluZyArICcgJztcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdHI7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlZnJlc2ggc3RhdGUgYmVmb3Igc3RhcnRUaW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZS5wcm90b3R5cGUuX3JlZnJlc2hCZWZvcmUgPSBmdW5jdGlvbiBfcmVmcmVzaEJlZm9yZSgpIHtcblx0ICAgIC8vIGNhbGwgc2V0UHJvZ3Jlc3Mgd2l0aCBlYXNlZCBhbmQgbm9ybWFsIHByb2dyZXNzXG5cdCAgICB0aGlzLl9zZXRQcm9ncmVzcyh0aGlzLnR3ZWVuLl9wcm9wcy5lYXNpbmcoMCksIDApO1xuXG5cdCAgICBpZiAodGhpcy5fcHJvcHMuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgdGhpcy5fc2hvdygpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5faGlkZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIGBzb2Z0YCBzaG93IG9mIHRoZSBtb2R1bGUsXG5cdCAgICBpdCBzaG91bGQgcmVzdG9yZSB0cmFuc2Zvcm0gc3R5bGVzIG9mIHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIFNoYXBlLnByb3RvdHlwZS5fc2hvd0J5VHJhbnNmb3JtID0gZnVuY3Rpb24gX3Nob3dCeVRyYW5zZm9ybSgpIHtcblx0ICAgIC8vIHJlc2V0IHRoZSBjYWNoZSBvZiB0aGUgc2NhbGUgcHJvcFxuXHQgICAgdGhpcy5fbGFzdFNldC5zY2FsZSA9IG51bGw7XG5cdCAgICAvLyBkcmF3IGVsIGFjY3JvZGluZyB0byBpdCdzIHByb3BzXG5cdCAgICB0aGlzLl9kcmF3RWwoKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFNoYXBlO1xuXHR9KF90dW5hYmxlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBTaGFwZTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfc2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cdHZhciBfc2hhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGUpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXG5cdCAgKlRPRE86KlxuXHQgIC0tLVxuXHQgIC0gdHdlYWsgdGhlbiBjaGFpbnNcblx0Ki9cblxuXHR2YXIgU2hhcGVTd2lybCA9IGZ1bmN0aW9uIChfU2hhcGUpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShTaGFwZVN3aXJsLCBfU2hhcGUpO1xuXG5cdCAgZnVuY3Rpb24gU2hhcGVTd2lybCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFNoYXBlU3dpcmwpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1NoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHQgIH1cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBfZGVmYXVsdHMgYW5kIG90aGVyIGRlZmF1bHQgb2JqZWN0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBTaGFwZVxuXHQgICovXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9TaGFwZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXG5cdCAgICAvKiBfREVGQVVMVFMgQVJFIC0gU2hhcGUgREVGQVVMVFMgKyBUSEVTRTogKi9cblxuXHQgICAgLyogW2Jvb2xlYW5dIDo6IElmIHNoYXBlIHNob3VsZCBmb2xsb3cgc2ludXNvaWRhbCBwYXRoLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuaXNTd2lybCA9IHRydWU7XG5cdCAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IERlZ3JlZSBzaXplIG9mIHRoZSBzaW51c29pZGFsIHBhdGguICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5zd2lybFNpemUgPSAxMDtcblx0ICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogRnJlcXVlbmN5IG9mIHRoZSBzaW51c29pZGFsIHBhdGguICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5zd2lybEZyZXF1ZW5jeSA9IDM7XG5cdCAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IFNpbnVzb2lkYWwgcGF0aCBsZW5ndGggc2NhbGUuICovXG5cdCAgICB0aGlzLl9kZWZhdWx0cy5wYXRoU2NhbGUgPSAxO1xuXHQgICAgLyog4oiGIDo6IFtudW1iZXJdIDo6IERlZ3JlZSBzaGlmdCBmb3IgdGhlIHNpbnVzb2lkYWwgcGF0aC4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLmRlZ3JlZVNoaWZ0ID0gMDtcblx0ICAgIC8qIOKIhiA6OiBbbnVtYmVyXSA6OiBSYWRpdXMgb2YgdGhlIHNoYXBlLiAqL1xuXHQgICAgdGhpcy5fZGVmYXVsdHMucmFkaXVzID0gNTtcblx0ICAgIC8vIOKIhiA6OiBVbml0cyA6OiBQb3NzaWJsZSB2YWx1ZXM6IFsgbnVtYmVyLCBzdHJpbmcgXVxuXHQgICAgdGhpcy5fZGVmYXVsdHMueCA9IDA7XG5cdCAgICAvLyDiiIYgOjogVW5pdHMgOjogUG9zc2libGUgdmFsdWVzOiBbIG51bWJlciwgc3RyaW5nIF1cblx0ICAgIHRoaXMuX2RlZmF1bHRzLnkgPSAwO1xuXHQgICAgLy8g4oiGIDo6IFBvc3NpYmxlIHZhbHVlczogWyBudW1iZXIgXVxuXHQgICAgdGhpcy5fZGVmYXVsdHMuc2NhbGUgPSB7IDE6IDAgfTtcblx0ICAgIC8qIFtudW1iZXI6IC0xLCAxXSA6OiBEaXJlY3RvbiBvZiBTd2lybC4gKi9cblx0ICAgIHRoaXMuX2RlZmF1bHRzLmRpcmVjdGlvbiA9IDE7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IF9vIG9wdGlvbnMgdG8gX3Byb3BzIHdpdGhcblx0ICAgIGZhbGxiYWNrIHRvIF9kZWZhdWx0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICBfU2hhcGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cy5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy5fY2FsY1Bvc0RhdGEoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBuZXcgb3ByaW9ucyB0byBfbyBhbmQgX3Byb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBvYmplY3QgdG8gdHVuZSB0by5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fdHVuZU5ld09wdGlvbnMgPSBmdW5jdGlvbiBfdHVuZU5ld09wdGlvbnMobykge1xuXHQgICAgaWYgKG8gPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIF9TaGFwZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zLmNhbGwodGhpcywgbyk7XG5cdCAgICBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcblx0ICAgICAgdGhpcy5fY2FsY1Bvc0RhdGEoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIFN3aXJsJ3MgcG9zaXRpb24gZGF0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX2NhbGNQb3NEYXRhID0gZnVuY3Rpb24gX2NhbGNQb3NEYXRhKCkge1xuXHQgICAgdmFyIHggPSB0aGlzLl9nZXRQb3NWYWx1ZSgneCcpLFxuXHQgICAgICAgIHkgPSB0aGlzLl9nZXRQb3NWYWx1ZSgneScpLFxuXHQgICAgICAgIGFuZ2xlID0gOTAgKyBNYXRoLmF0YW4oeS5kZWx0YSAvIHguZGVsdGEgfHwgMCkgKiBfaDIuZGVmYXVsdC5SQURfVE9fREVHO1xuXG5cdCAgICB0aGlzLl9wb3NEYXRhID0ge1xuXHQgICAgICByYWRpdXM6IE1hdGguc3FydCh4LmRlbHRhICogeC5kZWx0YSArIHkuZGVsdGEgKiB5LmRlbHRhKSxcblx0ICAgICAgYW5nbGU6IHguZGVsdGEgPCAwID8gYW5nbGUgKyAxODAgOiBhbmdsZSxcblx0ICAgICAgeDogeCwgeTogeVxuXHQgICAgfTtcblx0ICAgIC8vIHNldCB0aGUgbGFzdCBwb3NpdGlvbiB0byBfcHJvcHNcblx0ICAgIC8vIHRoaXMuX2NhbGNTd2lybFhZKCAxICk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgR2V0cyBgeGAgb3IgYHlgIHBvc2l0aW9uIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZ2V0UG9zVmFsdWUgPSBmdW5jdGlvbiBfZ2V0UG9zVmFsdWUobmFtZSkge1xuXHQgICAgdmFyIGRlbHRhID0gdGhpcy5fZGVsdGFzW25hbWVdO1xuXHQgICAgaWYgKGRlbHRhKSB7XG5cdCAgICAgIC8vIGRlbGV0ZSBmcm9tIGRlbHRhcyB0byBwcmV2ZW50IG5vcm1hbFxuXHQgICAgICBkZWxldGUgdGhpcy5fZGVsdGFzW25hbWVdO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIHN0YXJ0OiBkZWx0YS5zdGFydC52YWx1ZSxcblx0ICAgICAgICBlbmQ6IGRlbHRhLmVuZC52YWx1ZSxcblx0ICAgICAgICBkZWx0YTogZGVsdGEuZGVsdGEsXG5cdCAgICAgICAgdW5pdHM6IGRlbHRhLmVuZC51bml0XG5cdCAgICAgIH07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgcG9zID0gX2gyLmRlZmF1bHQucGFyc2VVbml0KHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgICAgcmV0dXJuIHsgc3RhcnQ6IHBvcy52YWx1ZSwgZW5kOiBwb3MudmFsdWUsIGRlbHRhOiAwLCB1bml0czogcG9zLnVuaXQgfTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHRoZSBwcm9ncmVzcyBvZiB0aGUgU3dpcmwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFNoYXBlXG5cdCAgICBAcGFyYW0ge051bWVyfSBFYXNlZCBwcm9ncmVzcyBvZiB0aGUgU3dpcmwgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgICBAcGFyYW0ge051bWVyfSBQcm9ncmVzcyBvZiB0aGUgU3dpcmwgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgKi9cblxuXG5cdCAgU2hhcGVTd2lybC5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICB0aGlzLl9wcm9ncmVzcyA9IGVhc2VkUHJvZ3Jlc3M7XG5cdCAgICB0aGlzLl9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICAgIHRoaXMuX2NhbGNTd2lybFhZKGVhc2VkUHJvZ3Jlc3MpO1xuXHQgICAgLy8gdGhpcy5fY2FsY09yaWdpbigpO1xuXHQgICAgdGhpcy5fZHJhdyhlYXNlZFByb2dyZXNzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHgveSBmb3IgU3dpcmwncyBwcm9ncmVzc1xuXHQgICAgQHByaXZhdGVcblx0ICAgIEBtdXRhdGVzIF9wcm9wc1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEN1cnJlbnQgcHJvZ3Jlc3MgaW4gWzAuLi4xXVxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9jYWxjU3dpcmxYWSA9IGZ1bmN0aW9uIF9jYWxjU3dpcmxYWShwcm9jKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGFuZ2xlID0gdGhpcy5fcG9zRGF0YS5hbmdsZSArIHAuZGVncmVlU2hpZnQsXG5cdCAgICAgICAgcG9pbnQgPSBfaDIuZGVmYXVsdC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgIGFuZ2xlOiBwLmlzU3dpcmwgPyBhbmdsZSArIHRoaXMuX2dldFN3aXJsKHByb2MpIDogYW5nbGUsXG5cdCAgICAgIHJhZGl1czogcHJvYyAqIHRoaXMuX3Bvc0RhdGEucmFkaXVzICogcC5wYXRoU2NhbGUsXG5cdCAgICAgIGNlbnRlcjoge1xuXHQgICAgICAgIHg6IHRoaXMuX3Bvc0RhdGEueC5zdGFydCxcblx0ICAgICAgICB5OiB0aGlzLl9wb3NEYXRhLnkuc3RhcnRcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBpZiBmb3JlaWduIHN2ZyBjYW52YXMgLSBzZXQgcG9zaXRpb24gd2l0aG91dCB1bml0c1xuXHQgICAgdmFyIHggPSBwb2ludC54LFxuXHQgICAgICAgIHkgPSBwb2ludC55LFxuXHQgICAgICAgIHNtYWxsTnVtYmVyID0gMC4wMDAwMDE7XG5cblx0ICAgIC8vIHJlbW92ZSB2ZXJ5IHNtYWxsIG51bWJlcnMgdG8gcHJldmVudCBleHBvbmVudGlhbCBmb3Jtc1xuXHQgICAgaWYgKHggPiAwICYmIHggPCBzbWFsbE51bWJlcikge1xuXHQgICAgICB4ID0gc21hbGxOdW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoeSA+IDAgJiYgeSA8IHNtYWxsTnVtYmVyKSB7XG5cdCAgICAgIHkgPSBzbWFsbE51bWJlcjtcblx0ICAgIH1cblx0ICAgIGlmICh4IDwgMCAmJiB4ID4gLXNtYWxsTnVtYmVyKSB7XG5cdCAgICAgIHggPSAtc21hbGxOdW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAoeSA8IDAgJiYgeSA+IC1zbWFsbE51bWJlcikge1xuXHQgICAgICB5ID0gLXNtYWxsTnVtYmVyO1xuXHQgICAgfVxuXG5cdCAgICBwLnggPSB0aGlzLl9vLmN0eCA/IHggOiAnJyArIHggKyB0aGlzLl9wb3NEYXRhLngudW5pdHM7XG5cdCAgICBwLnkgPSB0aGlzLl9vLmN0eCA/IHkgOiAnJyArIHkgKyB0aGlzLl9wb3NEYXRhLnkudW5pdHM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBwcm9ncmVzcyBvZiB0aGUgc3dpcmwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIG9mIHRoZSBTd2lybC5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFByb2dyZXNzIG9mIHRoZSBzd2lybC5cblx0ICAqL1xuXG5cblx0ICBTaGFwZVN3aXJsLnByb3RvdHlwZS5fZ2V0U3dpcmwgPSBmdW5jdGlvbiBfZ2V0U3dpcmwocHJvYykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHJldHVybiBwLmRpcmVjdGlvbiAqIHAuc3dpcmxTaXplICogTWF0aC5zaW4ocC5zd2lybEZyZXF1ZW5jeSAqIHByb2MpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkcmF3IHNoYXBlLlxuXHQgICAgSWYgIWlzV2l0aFNoYXBlIC0gZHJhdyBzZWxmIGVsIG9ubHksIGJ1dCBub3Qgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIFNoYXBlLlxuXHQgICovXG5cblxuXHQgIFNoYXBlU3dpcmwucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICAvLyBjYWxsIF9kcmF3IG9yIGp1c3QgX2RyYXdFbCBAIFNoYXBlIGRlcGVuZGluZyBpZiB0aGVyZSBpcyBgc2hhcGVgXG5cdCAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMuX3Byb3BzLmlzV2l0aFNoYXBlID8gJ19kcmF3JyA6ICdfZHJhd0VsJztcblx0ICAgIF9zaGFwZTIuZGVmYXVsdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0uY2FsbCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFNoYXBlU3dpcmw7XG5cdH0oX3NoYXBlMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBTaGFwZVN3aXJsO1xuXG4vKioqLyB9LFxuLyogNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfdGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5cdHZhciBfdGltZWxpbmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGltZWxpbmUpO1xuXG5cdHZhciBfc2hhcGVTd2lybCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblx0dmFyIF9zaGFwZVN3aXJsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlU3dpcmwpO1xuXG5cdHZhciBfdHVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG5cdHZhciBfdHVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90dW5hYmxlKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvLyBpbXBvcnQgU2hhcGUgICAgZnJvbSAnLi9zaGFwZSc7XG5cblx0dmFyIEJ1cnN0ID0gZnVuY3Rpb24gKF9UdW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoQnVyc3QsIF9UdW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIEJ1cnN0KCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQnVyc3QpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R1bmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdCAgfVxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIGRlZmF1bHRzLlxuXHQgICAgQG92ZXJyaWRlIEAgU2hhcGVTd2lybC5cblx0ICAqL1xuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8qIFtudW1iZXIgPiAwXSA6OiBRdWFudGl0eSBvZiBCdXJzdCBwYXJ0aWNsZXMuICovXG5cdCAgICAgIGNvdW50OiA1LFxuXHQgICAgICAvKiBbMCA8IG51bWJlciA8IDM2MF0gOjogRGVncmVlIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgZGVncmVlOiAzNjAsXG5cdCAgICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogUmFkaXVzIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgcmFkaXVzOiB7IDA6IDUwIH0sXG5cdCAgICAgIC8qIOKIhiA6OiBbbnVtYmVyID4gMF0gOjogWCByYWRpdXMgb2YgdGhlIEJ1cnN0LiAqL1xuXHQgICAgICByYWRpdXNYOiBudWxsLFxuXHQgICAgICAvKiDiiIYgOjogW251bWJlciA+IDBdIDo6IFkgcmFkaXVzIG9mIHRoZSBCdXJzdC4gKi9cblx0ICAgICAgcmFkaXVzWTogbnVsbCxcblx0ICAgICAgLyogW251bWJlciA+PSAwXSA6OiB3aWR0aCBvZiB0aGUgbWFpbiBzd2lybC4gKi9cblx0ICAgICAgd2lkdGg6IDAsXG5cdCAgICAgIC8qIFtudW1iZXIgPj0gMF0gOjogaGVpZ2h0IG9mIHRoZSBtYWluIHN3aXJsLiAqL1xuXHQgICAgICBoZWlnaHQ6IDBcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBhIHRoZW4gcmVjb3JkIGZvciB0aGUgbW9kdWxlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgb3ZlcnJpZGVzIEAgVGhlbmFibGVcblx0ICAgIEBwYXJhbSAgICB7T2JqZWN0fSBPcHRpb25zIGZvciB0aGUgbmV4dCBhbmltYXRpb24uXG5cdCAgICBAcmV0dXJucyAge09iamVjdH0gdGhpcy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gcmVtb3ZlIHR3ZWVuIHByb3BlcnRpZXMgKG5vdCBjYWxsYmFja3MpXG5cdCAgICB0aGlzLl9yZW1vdmVUd2VlblByb3BlcnRpZXMobyk7XG5cblx0ICAgIHZhciBuZXdNYXN0ZXIgPSB0aGlzLl9tYXN0ZXJUaGVuKG8pLFxuXHQgICAgICAgIG5ld1N3aXJscyA9IHRoaXMuX2NoaWxkVGhlbihvKTtcblxuXHQgICAgdGhpcy5fc2V0U3dpcmxEdXJhdGlvbihuZXdNYXN0ZXIsIHRoaXMuX2NhbGNQYWNrVGltZShuZXdTd2lybHMpKTtcblxuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aCBvcHRpb25hbCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byBzZXQgb24gdGhlIHJ1bi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLnR1bmUgPSBmdW5jdGlvbiB0dW5lKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICAvLyBzYXZlIHRpbWVsaW5lIG9wdGlvbnMgdG8gX3RpbWVsaW5lT3B0aW9uc1xuXHQgICAgLy8gYW5kIGRlbGV0ZSB0aGUgdGltZWxpbmUgb3B0aW9ucyBvbiBvXG5cdCAgICAvLyBjdXogbWFzdGVyU3dpcmwgc2hvdWxkIG5vdCBnZXQgdGhlbVxuXHQgICAgdGhpcy5fc2F2ZVRpbWVsaW5lT3B0aW9ucyhvKTtcblxuXHQgICAgLy8gYWRkIG5ldyB0aW1lbGluZSBwcm9wZXJ0aWVzIHRvIHRpbWVsaW5lXG5cdCAgICB0aGlzLnRpbWVsaW5lLl9zZXRQcm9wKHRoaXMuX3RpbWVsaW5lT3B0aW9ucyk7XG5cblx0ICAgIC8vIHJlbW92ZSB0d2VlbiBvcHRpb25zIChub3QgY2FsbGJhY2tzKVxuXHQgICAgdGhpcy5fcmVtb3ZlVHdlZW5Qcm9wZXJ0aWVzKG8pO1xuXG5cdCAgICAvLyB0dW5lIF9wcm9wc1xuXHQgICAgdGhpcy5fdHVuZU5ld09wdGlvbnMobyk7XG5cblx0ICAgIC8vIHR1bmUgbWFzdGVyIHN3aXJsXG5cdCAgICB0aGlzLm1hc3RlclN3aXJsLnR1bmUobyk7XG5cblx0ICAgIC8vIHR1bmUgY2hpbGQgc3dpcmxzXG5cdCAgICB0aGlzLl90dW5lU3dpcmxzKG8pO1xuXG5cdCAgICAvLyByZWNhbGMgdGltZSBmb3IgbW9kdWxlc1xuXHQgICAgdGhpcy5fcmVjYWxjTW9kdWxlc1RpbWUoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EUyBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRFMgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IGBfb2Agb3B0aW9ucyB0byBgX3Byb3BzYCBvYmplY3Rcblx0ICAgIHdpdGggZmFsbGJhY2sgdG8gYF9kZWZhdWx0c2AuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICAvLyByZW1vdmUgdHdlZW4gcHJvcGVydGllcyAobm90IGNhbGxiYWNrcylcblx0ICAgIHRoaXMuX3JlbW92ZVR3ZWVuUHJvcGVydGllcyh0aGlzLl9vKTtcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVtb3ZlIGFsbCB0d2VlbiAoZXhjbHVkaW5nXG5cdCAgICBjYWxsYmFja3MpIHByb3BzIGZyb20gb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3Qgd2hpY2ggc2hvdWxkIGJlIGNsZWFuZWRcblx0ICAgICAgICAgICAgICAgICAgICB1cCBmcm9tIHR3ZWVuIHByb3BlcnRpZXMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZW1vdmVUd2VlblByb3BlcnRpZXMgPSBmdW5jdGlvbiBfcmVtb3ZlVHdlZW5Qcm9wZXJ0aWVzKG8pIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBfaDIuZGVmYXVsdC50d2Vlbk9wdGlvbk1hcCkge1xuXHQgICAgICAvLyByZW1vdmUgYWxsIGl0ZW1zIHRoYXQgYXJlIG5vdCBkZWNsYXJlZCBpbiBfZGVmYXVsdHNcblx0ICAgICAgaWYgKHRoaXMuX2RlZmF1bHRzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgIGRlbGV0ZSBvW2tleV07XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVjYWxjIG1vZHVsZXMgY2hhaW4gdHdlZW5cblx0ICAgIHRpbWVzIGFmdGVyIHR1bmluZyBuZXcgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9yZWNhbGNNb2R1bGVzVGltZSA9IGZ1bmN0aW9uIF9yZWNhbGNNb2R1bGVzVGltZSgpIHtcblx0ICAgIHZhciBtb2R1bGVzID0gdGhpcy5tYXN0ZXJTd2lybC5fbW9kdWxlcyxcblx0ICAgICAgICBzd2lybHMgPSB0aGlzLl9zd2lybHMsXG5cdCAgICAgICAgc2hpZnRUaW1lID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0d2VlbiA9IG1vZHVsZXNbaV0udHdlZW4sXG5cdCAgICAgICAgICBwYWNrVGltZSA9IHRoaXMuX2NhbGNQYWNrVGltZShzd2lybHNbaV0pO1xuXHQgICAgICB0d2Vlbi5fc2V0UHJvcCh7ICdkdXJhdGlvbic6IHBhY2tUaW1lLCAnc2hpZnRUaW1lJzogc2hpZnRUaW1lIH0pO1xuXHQgICAgICBzaGlmdFRpbWUgKz0gcGFja1RpbWU7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBTd2lybHMgd2l0aCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gTmV3IG9wdGlvbnMuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl90dW5lU3dpcmxzID0gZnVuY3Rpb24gX3R1bmVTd2lybHMobykge1xuXHQgICAgLy8gZ2V0IHN3aXJscyBpbiBmaXJzdCBwYWNrXG5cdCAgICB2YXIgcGFjazAgPSB0aGlzLl9zd2lybHNbMF07XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2swLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBzd2lybCA9IHBhY2swW2ldLFxuXHQgICAgICAgICAgb3B0aW9uID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24obyB8fCB7fSwgaSk7XG5cblx0ICAgICAgLy8gc2luY2UgdGhlIGBkZWdyZWVTaGlmdGAgcGFydGljaXBhdGUgaW5cblx0ICAgICAgLy8gY2hpbGRyZW4gcG9zaXRpb24gY2FsY3VsYXRpb25zLCB3ZSBuZWVkIHRvIGtlZXBcblx0ICAgICAgLy8gdGhlIG9sZCBgZGVncmVlU2hpZnRgIHZhbHVlIGlmIG5ldyBub3Qgc2V0XG5cdCAgICAgIHZhciBpc0RlZ3JlZVNoaWZ0ID0gb3B0aW9uLmRlZ3JlZVNoaWZ0ICE9IG51bGw7XG5cdCAgICAgIGlmICghaXNEZWdyZWVTaGlmdCkge1xuXHQgICAgICAgIG9wdGlvbi5kZWdyZWVTaGlmdCA9IHRoaXMuX3N3aXJsc1swXVtpXS5fcHJvcHMuZGVncmVlU2hpZnQ7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9hZGRCdXJzdFByb3BlcnRpZXMob3B0aW9uLCBpKTtcblxuXHQgICAgICAvLyBhZnRlciBidXJzdCBwb3NpdGlvbiBjYWxjdWxhdGlvbiAtIGRlbGV0ZSB0aGUgb2xkIGBkZWdyZWVTaGlmdGBcblx0ICAgICAgLy8gZnJvbSB0aGUgb3B0aW9ucywgc2luY2UgYW55d2F5cyB3ZSBoYXZlIGNvcGllZCBpdCBmcm9tIHRoZSBzd2lybFxuXHQgICAgICBpZiAoIWlzRGVncmVlU2hpZnQpIHtcblx0ICAgICAgICBkZWxldGUgb3B0aW9uLmRlZ3JlZVNoaWZ0O1xuXHQgICAgICB9XG5cblx0ICAgICAgc3dpcmwudHVuZShvcHRpb24pO1xuXHQgICAgICB0aGlzLl9yZWZyZXNoQnVyc3RPcHRpb25zKHN3aXJsLl9tb2R1bGVzLCBpKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVmcmVzaCBidXJzdCB4L3kvYW5nbGUgb3B0aW9ucyBvbiBmdXJ0aGVyIGNoYWluZWQgXG5cdCAgICBzd2lybHMsIGJlY2F1c2UgdGhleSB3aWxsIGJlIG92ZXJyaWRlbiBhZnRlciBgdHVuZWAgY2FsbCBvblxuXHQgICAgdmVyeSBmaXJzdCBzd2lybC5cblx0ICAgIEBwYXJhbSB7QXJyYXl9IENoYWluZWQgbW9kdWxlcyBhcnJheVxuXHQgICAgcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIGZpcnN0IHN3aXJsIGluIHRoZSBjaGFpbi5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3JlZnJlc2hCdXJzdE9wdGlvbnMgPSBmdW5jdGlvbiBfcmVmcmVzaEJ1cnN0T3B0aW9ucyhtb2R1bGVzLCBpKSB7XG5cdCAgICBmb3IgKHZhciBqID0gMTsgaiA8IG1vZHVsZXMubGVuZ3RoOyBqKyspIHtcblx0ICAgICAgdmFyIG1vZHVsZSA9IG1vZHVsZXNbal0sXG5cdCAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgIHRoaXMuX2FkZEJ1cnN0UHJvcGVydGllcyhvcHRpb25zLCBpLCBqKTtcblx0ICAgICAgbW9kdWxlLl90dW5lTmV3T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCB0aGVuIG9uIG1hc3RlclN3aXJsLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFRoZW4gb3B0aW9ucy5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE5ldyBtYXN0ZXIgc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9tYXN0ZXJUaGVuID0gZnVuY3Rpb24gX21hc3RlclRoZW4obykge1xuXHQgICAgdGhpcy5tYXN0ZXJTd2lybC50aGVuKG8pO1xuXHQgICAgLy8gZ2V0IHRoZSBsYXRlc3QgbWFzdGVyIHN3aXJsIGluIHRoZW4gY2hhaW5cblx0ICAgIHZhciBuZXdNYXN0ZXJTd2lybCA9IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHRoaXMubWFzdGVyU3dpcmwuX21vZHVsZXMpO1xuXHQgICAgLy8gc2F2ZSB0byBtYXN0ZXJTd2lybHNcblx0ICAgIHRoaXMuX21hc3RlclN3aXJscy5wdXNoKG5ld01hc3RlclN3aXJsKTtcblx0ICAgIHJldHVybiBuZXdNYXN0ZXJTd2lybDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCB0aGVuIG9uIGNoaWxkIHN3aWxycy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaGVuIG9wdGlvbnMuXG5cdCAgICBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbmV3IFN3aXJscy5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2NoaWxkVGhlbiA9IGZ1bmN0aW9uIF9jaGlsZFRoZW4obykge1xuXHQgICAgdmFyIHBhY2sgPSB0aGlzLl9zd2lybHNbMF0sXG5cdCAgICAgICAgbmV3UGFjayA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IG9wdGlvbiBieSBtb2R1bHVzXG5cdCAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24obywgaSk7XG5cdCAgICAgIHZhciBzd2lybCA9IHBhY2tbaV07XG5cdCAgICAgIHZhciBsYXN0U3dpcmwgPSBfaDIuZGVmYXVsdC5nZXRMYXN0SXRlbShzd2lybC5fbW9kdWxlcyk7XG5cdCAgICAgIC8vIGFkZCBuZXcgTWFzdGVyIFN3aXJsIGFzIHBhcmVudCBvZiBuZXcgY2hpbGRzd2lybFxuXHQgICAgICBvcHRpb25zLnBhcmVudCA9IHRoaXMuZWw7XG5cblx0ICAgICAgdGhpcy5fYWRkQnVyc3RQcm9wZXJ0aWVzKG9wdGlvbnMsIGksIHRoaXMuX21hc3RlclN3aXJscy5sZW5ndGggLSAxKTtcblxuXHQgICAgICBzd2lybC50aGVuKG9wdGlvbnMpO1xuXG5cdCAgICAgIC8vIHNhdmUgdGhlIG5ldyBpdGVtIGluIGB0aGVuYCBjaGFpblxuXHQgICAgICBuZXdQYWNrLnB1c2goX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0oc3dpcmwuX21vZHVsZXMpKTtcblx0ICAgIH1cblx0ICAgIC8vIHNhdmUgdGhlIHBhY2sgdG8gX3N3aXJscyBvYmplY3Rcblx0ICAgIHRoaXMuX3N3aXJsc1t0aGlzLl9tYXN0ZXJTd2lybHMubGVuZ3RoIC0gMV0gPSBuZXdQYWNrO1xuXHQgICAgcmV0dXJuIG5ld1BhY2s7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGluaXRpYWxpemUgcHJvcGVydGllcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVGhlbmFibGVcblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIF9UdW5hYmxlLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgICAgLy8ganVzdCBidWZmZXIgdGltZWxpbmUgZm9yIGNhbGN1bGF0aW9uc1xuXHQgICAgdGhpcy5fYnVmZmVyVGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiB0aGUgbW9kdWxlLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIHRoaXMuX28uaXNXaXRoU2hhcGUgPSBmYWxzZTtcblx0ICAgIHRoaXMuX28uaXNTd2lybCA9IHRoaXMuX3Byb3BzLmlzU3dpcmw7XG5cdCAgICB0aGlzLl9vLmNhbGxiYWNrc0NvbnRleHQgPSB0aGlzO1xuXHQgICAgLy8gc2F2ZSB0aW1lbGluZSBvcHRpb25zIGFuZCByZW1vdmUgZnJvbSBfb1xuXHQgICAgLy8gY3V6IHRoZSBtYXN0ZXIgc3dpcmwgc2hvdWxkIG5vdCBnZXQgdGhlbVxuXHQgICAgdGhpcy5fc2F2ZVRpbWVsaW5lT3B0aW9ucyh0aGlzLl9vKTtcblxuXHQgICAgdGhpcy5tYXN0ZXJTd2lybCA9IG5ldyBNYWluU3dpcmwodGhpcy5fbyk7XG5cdCAgICB0aGlzLl9tYXN0ZXJTd2lybHMgPSBbdGhpcy5tYXN0ZXJTd2lybF07XG5cdCAgICB0aGlzLmVsID0gdGhpcy5tYXN0ZXJTd2lybC5lbDtcblxuXHQgICAgdGhpcy5fcmVuZGVyU3dpcmxzKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvciBpbml0aWFsIHJlbmRlciBvZiBzd2lybHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fcmVuZGVyU3dpcmxzID0gZnVuY3Rpb24gX3JlbmRlclN3aXJscygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgcGFjayA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuY291bnQ7IGkrKykge1xuXHQgICAgICB2YXIgb3B0aW9uID0gdGhpcy5fZ2V0Q2hpbGRPcHRpb24odGhpcy5fbywgaSk7XG5cdCAgICAgIHBhY2sucHVzaChuZXcgQ2hpbGRTd2lybCh0aGlzLl9hZGRPcHRpb25hbFByb3BzKG9wdGlvbiwgaSkpKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3N3aXJscyA9IHsgMDogcGFjayB9O1xuXHQgICAgdGhpcy5fc2V0U3dpcmxEdXJhdGlvbih0aGlzLm1hc3RlclN3aXJsLCB0aGlzLl9jYWxjUGFja1RpbWUocGFjaykpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzYXZlIHRpbWVsaW5lIG9wdGlvbnMgdG8gX3RpbWVsaW5lT3B0aW9uc1xuXHQgICAgYW5kIGRlbGV0ZSB0aGUgcHJvcGVydHkgb24gdGhlIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGhlIG9iamVjdCB0byBzYXZlIHRoZSB0aW1lbGluZSBvcHRpb25zIGZyb20uXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9zYXZlVGltZWxpbmVPcHRpb25zID0gZnVuY3Rpb24gX3NhdmVUaW1lbGluZU9wdGlvbnMobykge1xuXHQgICAgdGhpcy5fdGltZWxpbmVPcHRpb25zID0gby50aW1lbGluZTtcblx0ICAgIGRlbGV0ZSBvLnRpbWVsaW5lO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgdG90YWwgdGltZSBvZiBhcnJheSBvZlxuXHQgICAgY29uY3VycmVudCB0d2VlbnMuXG5cdCAgICBAcGFyYW0gICB7QXJyYXl9ICBQYWNrIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgdGltZSBmb3IuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBUb3RhbCBwYWNrIGR1cmF0aW9uLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fY2FsY1BhY2tUaW1lID0gZnVuY3Rpb24gX2NhbGNQYWNrVGltZShwYWNrKSB7XG5cdCAgICB2YXIgbWF4VGltZSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhY2subGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHR3ZWVuID0gcGFja1tpXS50d2Vlbixcblx0ICAgICAgICAgIHAgPSB0d2Vlbi5fcHJvcHM7XG5cblx0ICAgICAgbWF4VGltZSA9IE1hdGgubWF4KHAucmVwZWF0VGltZSAvIHAuc3BlZWQsIG1heFRpbWUpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbWF4VGltZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IGR1cmF0aW9uIGZvciBTd2lybC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTd2lybCBpbnN0YW5jZSB0byBzZXQgdGhlIGR1cmF0aW9uIHRvLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IER1cmF0aW9uIHRvIHNldC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3NldFN3aXJsRHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0U3dpcmxEdXJhdGlvbihzd2lybCwgZHVyYXRpb24pIHtcblx0ICAgIHN3aXJsLnR3ZWVuLl9zZXRQcm9wKCdkdXJhdGlvbicsIGR1cmF0aW9uKTtcblx0ICAgIHZhciBpc1JlY2FsYyA9IHN3aXJsLnRpbWVsaW5lICYmIHN3aXJsLnRpbWVsaW5lLl9yZWNhbGNUb3RhbER1cmF0aW9uO1xuXHQgICAgaXNSZWNhbGMgJiYgc3dpcmwudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGNoaWxkT3B0aW9uIGZvcm0gb2JqZWN0IGNhbGwgYnkgbW9kdWx1cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7T2JqZWN0fSBPYmplY3QgdG8gbG9vayBpbi5cblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBjdXJyZW50IFN3aXJsLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gT3B0aW9ucyBmb3IgdGhlIGN1cnJlbnQgc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRDaGlsZE9wdGlvbiA9IGZ1bmN0aW9uIF9nZXRDaGlsZE9wdGlvbihvYmosIGkpIHtcblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqLmNoaWxkcmVuKSB7XG5cdCAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMuX2dldFByb3BCeU1vZChrZXksIGksIG9iai5jaGlsZHJlbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHByb3BlcnR5IGJ5IG1vZHVsdXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IGZvciB0aGUgbW9kdWx1cy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTb3VyY2Ugb2JqZWN0IHRvIGNoZWNrIGluLlxuXHQgICAgQHJldHVybnMge0FueX0gUHJvcGVydHkuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRQcm9wQnlNb2QgPSBmdW5jdGlvbiBfZ2V0UHJvcEJ5TW9kKG5hbWUsIGluZGV4KSB7XG5cdCAgICB2YXIgc291cmNlT2JqID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMl07XG5cblx0ICAgIHZhciBwcm9wID0gc291cmNlT2JqW25hbWVdO1xuXHQgICAgcmV0dXJuIF9oMi5kZWZhdWx0LmlzQXJyYXkocHJvcCkgPyBwcm9wW2luZGV4ICUgcHJvcC5sZW5ndGhdIDogcHJvcDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYWRkIG9wdGlvbmFsIFN3aXJscycgcHJvcGVydGllcyB0byBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gYWRkIHRoZSBwcm9wZXJ0aWVzIHRvLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2FkZE9wdGlvbmFsUHJvcHMgPSBmdW5jdGlvbiBfYWRkT3B0aW9uYWxQcm9wcyhvcHRpb25zLCBpbmRleCkge1xuXHQgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXHQgICAgb3B0aW9ucy5wYXJlbnQgPSB0aGlzLm1hc3RlclN3aXJsLmVsO1xuXG5cdCAgICB0aGlzLl9hZGRCdXJzdFByb3BlcnRpZXMob3B0aW9ucywgaW5kZXgpO1xuXG5cdCAgICByZXR1cm4gb3B0aW9ucztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYWRkIEJ1cnN0IG9wdGlvbnMgdG8gb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIHRvIGFkZCB0aGUgcHJvcGVydGllcyB0by5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgU3dpcmwuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9hZGRCdXJzdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBfYWRkQnVyc3RQcm9wZXJ0aWVzKG9wdGlvbnMsIGluZGV4LCBpKSB7XG5cdCAgICAvLyBzYXZlIGluZGV4IG9mIHRoZSBtb2R1bGVcblx0ICAgIHZhciBtYWluSW5kZXggPSB0aGlzLl9pbmRleDtcblx0ICAgIC8vIHRlbXBvcmFyeSBjaGFuZ2UgdGhlIGluZGV4IHRvIHBhcnNlIGluZGV4IGJhc2VkIHByb3BlcnRpZXMgbGlrZSBzdGFnZ2VyXG5cdCAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuXHQgICAgLy8gcGFyc2UgZGVncmVlIHNoaWZ0IGZvciB0aGUgYml0XG5cdCAgICB2YXIgZGVncmVlU2hpZnQgPSB0aGlzLl9wYXJzZVByb3BlcnR5KCdkZWdyZWVTaGlmdCcsIG9wdGlvbnMuZGVncmVlU2hpZnQgfHwgMCk7XG5cdCAgICAvLyBwdXQgdGhlIGluZGV4IG9mIHRoZSBtb2R1bGUgYmFja1xuXHQgICAgdGhpcy5faW5kZXggPSBtYWluSW5kZXg7XG5cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgZGVncmVlQ250ID0gcC5kZWdyZWUgJSAzNjAgPT09IDAgPyBwLmNvdW50IDogcC5jb3VudCAtIDEgfHwgMSxcblx0ICAgICAgICBzdGVwID0gcC5kZWdyZWUgLyBkZWdyZWVDbnQsXG5cdCAgICAgICAgcG9pbnRTdGFydCA9IHRoaXMuX2dldFNpZGVQb2ludCgnc3RhcnQnLCBpbmRleCAqIHN0ZXAgKyBkZWdyZWVTaGlmdCwgaSksXG5cdCAgICAgICAgcG9pbnRFbmQgPSB0aGlzLl9nZXRTaWRlUG9pbnQoJ2VuZCcsIGluZGV4ICogc3RlcCArIGRlZ3JlZVNoaWZ0LCBpKTtcblxuXHQgICAgb3B0aW9ucy54ID0gdGhpcy5fZ2V0RGVsdGFGcm9tUG9pbnRzKCd4JywgcG9pbnRTdGFydCwgcG9pbnRFbmQpO1xuXHQgICAgb3B0aW9ucy55ID0gdGhpcy5fZ2V0RGVsdGFGcm9tUG9pbnRzKCd5JywgcG9pbnRTdGFydCwgcG9pbnRFbmQpO1xuXG5cdCAgICBvcHRpb25zLmFuZ2xlID0gdGhpcy5fZ2V0Qml0QW5nbGUob3B0aW9ucy5hbmdsZSB8fCAwLCBkZWdyZWVTaGlmdCwgaW5kZXgpO1xuXHQgIH07XG5cdCAgLyogXG5cdCAgICBNZXRob2QgdG8gZ2V0IHNoYXBlcyBhbmdsZSBpbiBidXJzdCBzb1xuXHQgICAgaXQgd2lsbCBmb2xsb3cgY2lyY3VsYXIgc2hhcGUuXG5cdCAgICAgXG5cdCAgICAgQHBhcmFtICAgIHtOdW1iZXIsIE9iamVjdH0gQmFzZSBhbmdsZS5cblx0ICAgICBAcGFyYW0gICAge051bWJlcn0gICAgICAgICBBbmdsZSBzaGlmdCBmb3IgdGhlIGJpdFxuXHQgICAgIEBwYXJhbSAgICB7TnVtYmVyfSAgICAgICAgIFNoYXBlJ3MgaW5kZXggaW4gYnVyc3QuXG5cdCAgICAgQHJldHVybnMgIHtOdW1iZXJ9ICAgICAgICAgQW5nbGUgaW4gYnVyc3QuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRCaXRBbmdsZSA9IGZ1bmN0aW9uIF9nZXRCaXRBbmdsZSgpIHtcblx0ICAgIHZhciBhbmdsZVByb3BlcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblx0ICAgIHZhciBhbmdsZVNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcblx0ICAgIHZhciBpID0gYXJndW1lbnRzWzJdO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGRlZ0NudCA9IHAuZGVncmVlICUgMzYwID09PSAwID8gcC5jb3VudCA6IHAuY291bnQgLSAxIHx8IDEsXG5cdCAgICAgICAgc3RlcCA9IHAuZGVncmVlIC8gZGVnQ250LFxuXHQgICAgICAgIGFuZ2xlID0gaSAqIHN0ZXAgKyA5MDtcblxuXHQgICAgYW5nbGUgKz0gYW5nbGVTaGlmdDtcblx0ICAgIC8vIGlmIG5vdCBkZWx0YSBvcHRpb25cblx0ICAgIGlmICghdGhpcy5faXNEZWx0YShhbmdsZVByb3BlcnR5KSkge1xuXHQgICAgICBhbmdsZVByb3BlcnR5ICs9IGFuZ2xlO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGRlbHRhID0ge30sXG5cdCAgICAgICAgICBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShhbmdsZVByb3BlcnR5KSxcblx0ICAgICAgICAgIHN0YXJ0ID0ga2V5c1swXSxcblx0ICAgICAgICAgIGVuZCA9IGFuZ2xlUHJvcGVydHlbc3RhcnRdO1xuXG5cdCAgICAgIHN0YXJ0ID0gX2gyLmRlZmF1bHQucGFyc2VTdHJpbmdPcHRpb24oc3RhcnQsIGkpO1xuXHQgICAgICBlbmQgPSBfaDIuZGVmYXVsdC5wYXJzZVN0cmluZ09wdGlvbihlbmQsIGkpO1xuXHQgICAgICAvLyBuZXcgc3RhcnQgPSBuZXdFbmRcblx0ICAgICAgZGVsdGFbcGFyc2VGbG9hdChzdGFydCkgKyBhbmdsZV0gPSBwYXJzZUZsb2F0KGVuZCkgKyBhbmdsZTtcblxuXHQgICAgICBhbmdsZVByb3BlcnR5ID0gZGVsdGE7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYW5nbGVQcm9wZXJ0eTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IHJhZGlhbCBwb2ludCBvbiBgc3RhcnRgIG9yIGBlbmRgLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaWRlIC0gW3N0YXJ0LCBlbmRdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEFuZ2xlIG9mIHRoZSByYWRpYWwgcG9pbnQuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgICBAcmV0dXJucyByYWRpYWwgcG9pbnQuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRTaWRlUG9pbnQgPSBmdW5jdGlvbiBfZ2V0U2lkZVBvaW50KHNpZGUsIGFuZ2xlLCBpKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHNpZGVSYWRpdXMgPSB0aGlzLl9nZXRTaWRlUmFkaXVzKHNpZGUsIGkpO1xuXG5cdCAgICByZXR1cm4gX2gyLmRlZmF1bHQuZ2V0UmFkaWFsUG9pbnQoe1xuXHQgICAgICByYWRpdXM6IHNpZGVSYWRpdXMucmFkaXVzLFxuXHQgICAgICByYWRpdXNYOiBzaWRlUmFkaXVzLnJhZGl1c1gsXG5cdCAgICAgIHJhZGl1c1k6IHNpZGVSYWRpdXMucmFkaXVzWSxcblx0ICAgICAgYW5nbGU6IGFuZ2xlLFxuXHQgICAgICAvLyBjZW50ZXI6ICB7IHg6IHAuY2VudGVyLCB5OiBwLmNlbnRlciB9XG5cdCAgICAgIGNlbnRlcjogeyB4OiAwLCB5OiAwIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcmFkaXVzIG9mIHRoZSBzaWRlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaWRlIC0gW3N0YXJ0LCBlbmRdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBtYWluIHN3aXJsLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUmFkaXVzLlxuXHQgICovXG5cblxuXHQgIEJ1cnN0LnByb3RvdHlwZS5fZ2V0U2lkZVJhZGl1cyA9IGZ1bmN0aW9uIF9nZXRTaWRlUmFkaXVzKHNpZGUsIGkpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHJhZGl1czogdGhpcy5fZ2V0UmFkaXVzQnlLZXkoJ3JhZGl1cycsIHNpZGUsIGkpLFxuXHQgICAgICByYWRpdXNYOiB0aGlzLl9nZXRSYWRpdXNCeUtleSgncmFkaXVzWCcsIHNpZGUsIGkpLFxuXHQgICAgICByYWRpdXNZOiB0aGlzLl9nZXRSYWRpdXNCeUtleSgncmFkaXVzWScsIHNpZGUsIGkpXG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgcmFkaXVzIGZyb20g4oiGIG9yIHBsYWluIHByb3BlcnR5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTaWRlIG5hbWUgLSBbc3RhcnQsIGVuZF0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1haW4gc3dpcmwuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBSYWRpdXMgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9nZXRSYWRpdXNCeUtleSA9IGZ1bmN0aW9uIF9nZXRSYWRpdXNCeUtleShrZXksIHNpZGUpIHtcblx0ICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcblxuXHQgICAgdmFyIHN3aXJsID0gdGhpcy5fbWFzdGVyU3dpcmxzW2ldLFxuXHQgICAgICAgIGRlbHRhcyA9IHN3aXJsLl9kZWx0YXMsXG5cdCAgICAgICAgcHJvcHMgPSBzd2lybC5fcHJvcHM7XG5cblx0ICAgIGlmIChkZWx0YXNba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBkZWx0YXNba2V5XVtzaWRlXTtcblx0ICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBwcm9wc1trZXldO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZGVsdGEgZnJvbSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIHBvaW50cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gS2V5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gU3RhcnQgcG9zaXRpb24gcG9pbnQuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRW5kIHBvc2l0aW9uIHBvaW50LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gRGVsdGEgb2YgdGhlIGVuZC9zdGFydC5cblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX2dldERlbHRhRnJvbVBvaW50cyA9IGZ1bmN0aW9uIF9nZXREZWx0YUZyb21Qb2ludHMoa2V5LCBwb2ludFN0YXJ0LCBwb2ludEVuZCkge1xuXHQgICAgdmFyIGRlbHRhID0ge307XG5cdCAgICBpZiAocG9pbnRTdGFydFtrZXldID09PSBwb2ludEVuZFtrZXldKSB7XG5cdCAgICAgIGRlbHRhID0gcG9pbnRTdGFydFtrZXldO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVsdGFbcG9pbnRTdGFydFtrZXldXSA9IHBvaW50RW5kW2tleV07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0aW1lbGluZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBUd2VlbmFibGVcblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX21ha2VUaW1lbGluZSA9IGZ1bmN0aW9uIF9tYWtlVGltZWxpbmUoKSB7XG5cdCAgICAvLyByZXN0b3JlIHRpbWVsaW5lIG9wdGlvbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgaW4gX3JlbmRlciBtZXRob2Rcblx0ICAgIHRoaXMuX28udGltZWxpbmUgPSB0aGlzLl90aW1lbGluZU9wdGlvbnM7XG5cdCAgICBfVHVuYWJsZS5wcm90b3R5cGUuX21ha2VUaW1lbGluZS5jYWxsKHRoaXMpO1xuXHQgICAgdGhpcy50aW1lbGluZS5hZGQodGhpcy5tYXN0ZXJTd2lybCwgdGhpcy5fc3dpcmxzWzBdKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbWFrZSBUd2VlbiBmb3IgdGhlIG1vZHVsZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBUd2VlbmFibGVcblx0ICAqL1xuXG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX21ha2VUd2VlbiA9IGZ1bmN0aW9uIF9tYWtlVHdlZW4oKSB7fSAvKiBkb24ndCBjcmVhdGUgYW55IHR3ZWVuICovXG5cdCAgLypcblx0ICAgIE92ZXJyaWRlIGBfaGlkZWAgYW5kIGBfc2hvd2AgbWV0aG9kcyBvbiBtb2R1bGVcblx0ICAgIHNpbmNlIHdlIGRvbid0IGhhdmUgdG8gaGlkZSBub3Igc2hvdyBvbiB0aGUgbW9kdWxlLlxuXHQgICovXG5cdCAgO1xuXG5cdCAgQnVyc3QucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24gX2hpZGUoKSB7LyogZG8gbm90aGluZyAqL307XG5cblx0ICBCdXJzdC5wcm90b3R5cGUuX3Nob3cgPSBmdW5jdGlvbiBfc2hvdygpIHsvKiBkbyBub3RoaW5nICovfTtcblxuXHQgIHJldHVybiBCdXJzdDtcblx0fShfdHVuYWJsZTIuZGVmYXVsdCk7XG5cblx0dmFyIENoaWxkU3dpcmwgPSBmdW5jdGlvbiAoX1NoYXBlU3dpcmwpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShDaGlsZFN3aXJsLCBfU2hhcGVTd2lybCk7XG5cblx0ICBmdW5jdGlvbiBDaGlsZFN3aXJsKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ2hpbGRTd2lybCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfU2hhcGVTd2lybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBDaGlsZFN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIF9TaGFwZVN3aXJsLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5pc1N3aXJsID0gZmFsc2U7XG5cdCAgICB0aGlzLl9vLmR1cmF0aW9uID0gdGhpcy5fby5kdXJhdGlvbiAhPSBudWxsID8gdGhpcy5fby5kdXJhdGlvbiA6IDcwMDtcblx0ICB9O1xuXHQgIC8vIGRpc2FibGUgZGVncmVlc2hpZnQgY2FsY3VsYXRpb25zXG5cblxuXHQgIENoaWxkU3dpcmwucHJvdG90eXBlLl9jYWxjU3dpcmxYWSA9IGZ1bmN0aW9uIF9jYWxjU3dpcmxYWShwcm9jKSB7XG5cdCAgICB2YXIgZGVncmVlU2hpZnQgPSB0aGlzLl9wcm9wcy5kZWdyZWVTaGlmdDtcblxuXHQgICAgdGhpcy5fcHJvcHMuZGVncmVlU2hpZnQgPSAwO1xuXHQgICAgX1NoYXBlU3dpcmwucHJvdG90eXBlLl9jYWxjU3dpcmxYWS5jYWxsKHRoaXMsIHByb2MpO1xuXHQgICAgdGhpcy5fcHJvcHMuZGVncmVlU2hpZnQgPSBkZWdyZWVTaGlmdDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENoaWxkU3dpcmw7XG5cdH0oX3NoYXBlU3dpcmwyLmRlZmF1bHQpO1xuXG5cdHZhciBNYWluU3dpcmwgPSBmdW5jdGlvbiAoX0NoaWxkU3dpcmwpIHtcblx0ICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShNYWluU3dpcmwsIF9DaGlsZFN3aXJsKTtcblxuXHQgIGZ1bmN0aW9uIE1haW5Td2lybCgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1haW5Td2lybCk7XG5cdCAgICByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfQ2hpbGRTd2lybC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBNYWluU3dpcmwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgX0NoaWxkU3dpcmwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnNjYWxlID0gMTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLndpZHRoID0gMDtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLmhlaWdodCA9IDA7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5yYWRpdXMgPSB7IDI1OiA3NSB9O1xuXHQgICAgLy8gdGhpcy5fZGVmYXVsdHMuZHVyYXRpb24gPSAyMDAwO1xuXHQgIH07XG5cblx0ICByZXR1cm4gTWFpblN3aXJsO1xuXHR9KENoaWxkU3dpcmwpO1xuXG5cdEJ1cnN0LkNoaWxkU3dpcmwgPSBDaGlsZFN3aXJsO1xuXHRCdXJzdC5NYWluU3dpcmwgPSBNYWluU3dpcmw7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gQnVyc3Q7XG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2V4dGVuZHM0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cblx0dmFyIF9leHRlbmRzNSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHM0KTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF90aGVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5cdHZhciBfdGhlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGhlbmFibGUpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdHZhciBfZGVsdGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cblx0dmFyIF9kZWx0YXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVsdGFzKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblxuXHQvLyBnZXQgdHdlZW4gcHJvcGVydGllc1xuXHR2YXIgb2JqID0ge307XG5cdF90d2VlbjIuZGVmYXVsdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKG9iaik7XG5cdHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvYmouX2RlZmF1bHRzKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgb2JqLl9kZWZhdWx0c1trZXlzW2ldXSA9IDE7XG5cdH1cblx0b2JqLl9kZWZhdWx0c1sndGltZWxpbmUnXSA9IDE7XG5cdHZhciBUV0VFTl9QUk9QRVJUSUVTID0gb2JqLl9kZWZhdWx0cztcblxuXHQvKlxuXHQgIFRPRE86XG5cblx0ICAgIC0gY2hhbmdlIF9wcm9wcyB0byBfcHJvcHNPYmogZm9yIGFuaW1hdGlvbnNcblx0ICAgIC0gY3VycmVudCB2YWx1ZXMgaW4gZGVsdGFzXG5cdCovXG5cblx0dmFyIEh0bWwgPSBmdW5jdGlvbiAoX1RoZW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoSHRtbCwgX1RoZW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIEh0bWwoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBIdG1sKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9UaGVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICBIdG1sLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuXHQgICAgICB4OiAwLFxuXHQgICAgICB5OiAwLFxuXHQgICAgICB6OiAwLFxuXG5cdCAgICAgIHNrZXdYOiAwLFxuXHQgICAgICBza2V3WTogMCxcblxuXHQgICAgICAvLyBhbmdsZTogICAgICAwLFxuXHQgICAgICBhbmdsZVg6IDAsXG5cdCAgICAgIGFuZ2xlWTogMCxcblx0ICAgICAgYW5nbGVaOiAwLFxuXG5cdCAgICAgIHNjYWxlOiAxLFxuXHQgICAgICBzY2FsZVg6IDEsXG5cdCAgICAgIHNjYWxlWTogMSxcblxuXHQgICAgICBpc1NvZnRIaWRlOiB0cnVlLFxuXHQgICAgICBpc1Nob3dTdGFydDogdHJ1ZSxcblx0ICAgICAgaXNTaG93RW5kOiB0cnVlLFxuXHQgICAgICBpc0ZvcmNlM2Q6IGZhbHNlLFxuXHQgICAgICBpc1JlZnJlc2hTdGF0ZTogdHJ1ZVxuXG5cdCAgICB9O1xuXHQgICAgLy8gZXhjbHVkZSBmcm9tIGF1dG9tYXRpYyBkcmF3aW5nXG5cdCAgICB0aGlzLl9kcmF3RXhjbHVkZSA9IHsgZWw6IDEgfTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBjYXVzZSAzZCBsYXllclxuXHQgICAgdGhpcy5fM2RQcm9wZXJ0aWVzID0gWydhbmdsZVgnLCAnYW5nbGVZJywgJ3onXTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBoYXZlIGFycmF5IHZhbHVlc1xuXHQgICAgdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCA9IHsgdHJhbnNmb3JtT3JpZ2luOiAxLCBiYWNrZ3JvdW5kUG9zaXRpb246IDEgfTtcblx0ICAgIC8vIHByb3BlcnRpZXMgdGhhdCBoYXZlIG5vIHVuaXRzXG5cdCAgICB0aGlzLl9udW1iZXJQcm9wZXJ0eU1hcCA9IHtcblx0ICAgICAgb3BhY2l0eTogMSwgc2NhbGU6IDEsIHNjYWxlWDogMSwgc2NhbGVZOiAxLFxuXHQgICAgICAvLyBhbmdsZTogMSxcblx0ICAgICAgYW5nbGVYOiAxLCBhbmdsZVk6IDEsIGFuZ2xlWjogMSxcblx0ICAgICAgc2tld1g6IDEsIHNrZXdZOiAxXG5cdCAgICB9O1xuXHQgICAgLy8gcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSBwcmVmaXhlZFxuXHQgICAgdGhpcy5fcHJlZml4UHJvcGVydHlNYXAgPSB7IHRyYW5zZm9ybTogMSwgdHJhbnNmb3JtT3JpZ2luOiAxIH07XG5cdCAgICAvLyBzYXZlIHByZWZpeFxuXHQgICAgdGhpcy5fcHJlZml4ID0gaC5wcmVmaXguY3NzO1xuXHQgIH07XG5cblx0ICBIdG1sLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICAvLyByZXR1cm4gaWYgbm90aGluZyB3YXMgcGFzc2VkXG5cdCAgICBpZiAobyA9PSBudWxsIHx8ICEoMCwgX2tleXMyLmRlZmF1bHQpKG8pLmxlbmd0aCkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH1cblxuXHQgICAgLy8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gYHRoZW5gIGNoYWluXG5cdCAgICB2YXIgcHJldk1vZHVsZSA9IGguZ2V0TGFzdEl0ZW0odGhpcy5fbW9kdWxlcyk7XG5cdCAgICAvLyBzZXQgZGVsdGFzIHRvIHRoZSBmaW5pc2ggc3RhdGVcblx0ICAgIHByZXZNb2R1bGUuZGVsdGFzLnJlZnJlc2goZmFsc2UpO1xuXHQgICAgLy8gY29weSBmaW5pc2ggc3RhdGUgdG8gdGhlIGxhc3QgaGlzdG9yeSByZWNvcmRcblx0ICAgIHRoaXMuX2hpc3RvcnlbdGhpcy5faGlzdG9yeS5sZW5ndGggLSAxXSA9IHByZXZNb2R1bGUuX287XG5cdCAgICAvLyBjYWxsIHN1cGVyXG5cdCAgICBfVGhlbmFibGUucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBvKTtcblx0ICAgIC8vIHJlc3RvcmUgdGhlIF9wcm9wc1xuXHQgICAgcHJldk1vZHVsZS5kZWx0YXMucmVzdG9yZSgpO1xuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGlwZSBzdGFydFZhbHVlIG9mIHRoZSBkZWx0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZhcnJpZGVzIEAgVGhlbmFibGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdGFydCBwcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9IFN0YXJ0IHByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gU3RhcnQgcHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2NoZWNrU3RhcnRWYWx1ZSA9IGZ1bmN0aW9uIF9jaGVja1N0YXJ0VmFsdWUoa2V5LCB2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgLy8gcmV0dXJuIGRlZmF1bHQgdmFsdWUgZm9yIHRyYW5zZm9ybXNcblx0ICAgICAgaWYgKHRoaXMuX2RlZmF1bHRzW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIHJldHVybiBkZWZhdWx0IHZhbHVlIGZyb20gX2N1c3RvbVByb3BzXG5cdCAgICAgIGlmICh0aGlzLl9jdXN0b21Qcm9wc1trZXldICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tUHJvcHNba2V5XTtcblx0ICAgICAgfVxuXHQgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBkZWZhdWx0IHZhbHVlXG5cdCAgICAgIGlmIChoLmRlZmF1bHRTdHlsZXNba2V5XSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGguZGVmYXVsdFN0eWxlc1trZXldO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGF0IHRoZSBlbmQgcmV0dXJuIDBcblx0ICAgICAgcmV0dXJuIDA7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyBfcHJvcHMgdG8gZWwuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kcmF3UHJvcHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIG5hbWUgPSB0aGlzLl9kcmF3UHJvcHNbaV07XG5cdCAgICAgIHRoaXMuX3NldFN0eWxlKG5hbWUsIHBbbmFtZV0pO1xuXHQgICAgfVxuXHQgICAgLy8gZHJhdyB0cmFuc2Zvcm1zXG5cdCAgICB0aGlzLl9kcmF3VHJhbnNmb3JtKCk7XG5cdCAgICAvLyBjYWxsIGN1c3RvbSB0cmFuc2Zvcm0gY2FsbGJhY2sgaWYgZXhpc3Rcblx0ICAgIHRoaXMuX2N1c3RvbURyYXcgJiYgdGhpcy5fY3VzdG9tRHJhdyh0aGlzLl9wcm9wcy5lbCwgdGhpcy5fcHJvcHMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgdHJhbnNmb3JtIG9uIGVsZW1lbnQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9kcmF3VHJhbnNmb3JtID0gZnVuY3Rpb24gX2RyYXdUcmFuc2Zvcm0oKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgdmFyIHN0cmluZyA9ICF0aGlzLl9pczNkID8gJ3RyYW5zbGF0ZSgnICsgcC54ICsgJywgJyArIHAueSArICcpXFxuICAgICAgICAgIHJvdGF0ZSgnICsgcC5hbmdsZVogKyAnZGVnKVxcbiAgICAgICAgICBza2V3KCcgKyBwLnNrZXdYICsgJ2RlZywgJyArIHAuc2tld1kgKyAnZGVnKVxcbiAgICAgICAgICBzY2FsZSgnICsgcC5zY2FsZVggKyAnLCAnICsgcC5zY2FsZVkgKyAnKScgOiAndHJhbnNsYXRlM2QoJyArIHAueCArICcsICcgKyBwLnkgKyAnLCAnICsgcC56ICsgJylcXG4gICAgICAgICAgcm90YXRlWCgnICsgcC5hbmdsZVggKyAnZGVnKVxcbiAgICAgICAgICByb3RhdGVZKCcgKyBwLmFuZ2xlWSArICdkZWcpXFxuICAgICAgICAgIHJvdGF0ZVooJyArIHAuYW5nbGVaICsgJ2RlZylcXG4gICAgICAgICAgc2tldygnICsgcC5za2V3WCArICdkZWcsICcgKyBwLnNrZXdZICsgJ2RlZylcXG4gICAgICAgICAgc2NhbGUoJyArIHAuc2NhbGVYICsgJywgJyArIHAuc2NhbGVZICsgJyknO1xuXG5cdCAgICB0aGlzLl9zZXRTdHlsZSgndHJhbnNmb3JtJywgc3RyaW5nKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVuZGVyIG9uIGluaXRpYWxpemF0aW9uLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBNb2R1bGVcblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSBpZiBub3QgdGhlIGZpcnN0IGluIGB0aGVuYCBjaGFpblxuXHQgICAgaWYgKHRoaXMuX28ucHJldkNoYWluTW9kdWxlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZW5kZXJQcm9wcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgbmFtZSA9IHRoaXMuX3JlbmRlclByb3BzW2ldLFxuXHQgICAgICAgICAgdmFsdWUgPSBwW25hbWVdO1xuXG5cdCAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlICsgJ3B4JyA6IHZhbHVlO1xuXHQgICAgICB0aGlzLl9zZXRTdHlsZShuYW1lLCB2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2RyYXcoKTtcblxuXHQgICAgaWYgKCFwLmlzU2hvd1N0YXJ0KSB7XG5cdCAgICAgIHRoaXMuX2hpZGUoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHN0eWxlIG9uIGVsLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdHlsZSBwcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFN0eWxlIHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIF9zZXRTdHlsZShuYW1lLCB2YWx1ZSkge1xuXHQgICAgaWYgKHRoaXMuX3N0YXRlW25hbWVdICE9PSB2YWx1ZSkge1xuXHQgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9wcm9wcy5lbC5zdHlsZTtcblx0ICAgICAgLy8gc2V0IHN0eWxlXG5cdCAgICAgIHN0eWxlW25hbWVdID0gdmFsdWU7XG5cdCAgICAgIC8vIGlmIHByZWZpeCBuZWVkZWQgLSBzZXQgaXRcblx0ICAgICAgaWYgKHRoaXMuX3ByZWZpeFByb3BlcnR5TWFwW25hbWVdKSB7XG5cdCAgICAgICAgc3R5bGVbJycgKyB0aGlzLl9wcmVmaXggKyBuYW1lXSA9IHZhbHVlO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGNhY2hlIHRoZSBsYXN0IHNldCB2YWx1ZVxuXHQgICAgICB0aGlzLl9zdGF0ZVtuYW1lXSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjb3B5IGBfb2Agb3B0aW9ucyB0byBgX3Byb3BzYCBvYmplY3QuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX3Byb3BzID0gdGhpcy5fby5wcm9wcyB8fCB7fTtcblx0ICAgIC8vIHByb3BzIGZvciBpbnRpYWwgcmVuZGVyIG9ubHlcblx0ICAgIHRoaXMuX3JlbmRlclByb3BzID0gW107XG5cdCAgICAvLyBwcm9wcyBmb3IgZHJhdyBvbiBldmVyeSBmcmFtZSB1cGRhdGVcblx0ICAgIHRoaXMuX2RyYXdQcm9wcyA9IFtdO1xuXHQgICAgLy8gc2F2ZSBjdXN0b20gcHJvcGVydGllcyBpZiBwcmVzZW50XG5cdCAgICB0aGlzLl9zYXZlQ3VzdG9tUHJvcGVydGllcyh0aGlzLl9vKTtcblx0ICAgIC8vIGNvcHkgdGhlIG9wdGlvbnNcblx0ICAgIHZhciBvID0gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSh7fSwgdGhpcy5fbyk7XG5cdCAgICAvLyBleHRlbmQgb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG5cdCAgICBvID0gdGhpcy5fYWRkRGVmYXVsdHMobyk7XG5cblx0ICAgIHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgLy8gaW5jbHVkZSB0aGUgcHJvcGVydHkgaWYgaXQgaXMgbm90IGluIGRyYXdFeGNsdWRlIG9iamVjdFxuXHQgICAgICAvLyBhbmQgbm90IGluIGRlZmF1bHRzID0gbm90IGEgdHJhbnNmb3JtXG5cdCAgICAgIHZhciBpc0luY2x1ZGUgPSAhdGhpcy5fZHJhd0V4Y2x1ZGVba2V5XSAmJiAvLyBub3QgaW4gZXhjbHVkZSBtYXBcblx0ICAgICAgdGhpcy5fZGVmYXVsdHNba2V5XSA9PSBudWxsICYmIC8vIG5vdCB0cmFuc2Zvcm0gcHJvcGVydHlcblx0ICAgICAgIVRXRUVOX1BST1BFUlRJRVNba2V5XTsgLy8gbm90IHR3ZWVuIHByb3BlcnR5XG5cblx0ICAgICAgdmFyIGlzQ3VzdG9tID0gdGhpcy5fY3VzdG9tUHJvcHNba2V5XTtcblx0ICAgICAgLy8gY29weSBhbGwgbm9uLWRlbHRhIHByb3BlcnRpZXMgdG8gdGhlIHByb3BzXG5cdCAgICAgIC8vIGlmIG5vdCBkZWx0YSB0aGVuIGFkZCB0aGUgcHJvcGVydHkgdG8gcmVuZGVyXG5cdCAgICAgIC8vIGxpc3QgdGhhdCBpcyBjYWxsZWQgb24gaW5pdGlhbGl6YXRpb25cblx0ICAgICAgLy8gb3RoZXJ3aXNlIGFkZCBpdCB0byB0aGUgZHJhdyBsaXN0IHRoYXQgd2lsbFxuXHQgICAgICAvLyBiZSBkcmF3ZWQgb24gZWFjaCBmcmFtZVxuXHQgICAgICBpZiAoIWguaXNEZWx0YShvW2tleV0pICYmICFUV0VFTl9QUk9QRVJUSUVTW2tleV0pIHtcblx0ICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbihrZXksIG9ba2V5XSk7XG5cdCAgICAgICAgaWYgKGtleSA9PT0gJ2VsJykge1xuXHQgICAgICAgICAgdGhpcy5fcHJvcHMuZWwgPSBoLnBhcnNlRWwoby5lbCk7XG5cdCAgICAgICAgICB0aGlzLmVsID0gdGhpcy5fcHJvcHMuZWw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0luY2x1ZGUgJiYgIWlzQ3VzdG9tKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZW5kZXJQcm9wcy5wdXNoKGtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGNvcHkgZGVsdGEgcHJvcCBidXQgbm90IHRyYW5zZm9ybXNcblx0ICAgICAgICAvLyBvdGhlcndpc2UgcHVzaCBpdCB0byBkcmF3IGxpc3QgdGhhdCBnZXRzIHRyYXZlcnNlZCBvbiBldmVyeSBkcmF3XG5cdCAgICAgIH0gZWxzZSBpZiAoaXNJbmNsdWRlICYmICFpc0N1c3RvbSkge1xuXHQgICAgICAgICAgdGhpcy5fZHJhd1Byb3BzLnB1c2goa2V5KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2NyZWF0ZURlbHRhcyhvKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2F2ZSBjdXN0b21Qcm9wZXJ0aWVzIHRvIF9jdXN0b21Qcm9wcy5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9mIHRoZSBtb2R1bGUuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX3NhdmVDdXN0b21Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gX3NhdmVDdXN0b21Qcm9wZXJ0aWVzKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgdGhpcy5fY3VzdG9tUHJvcHMgPSBvLmN1c3RvbVByb3BlcnRpZXMgfHwge307XG5cdCAgICB0aGlzLl9jdXN0b21Qcm9wcyA9ICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoe30sIHRoaXMuX2N1c3RvbVByb3BzKTtcblx0ICAgIHRoaXMuX2N1c3RvbURyYXcgPSB0aGlzLl9jdXN0b21Qcm9wcy5kcmF3O1xuXHQgICAgZGVsZXRlIHRoaXMuX2N1c3RvbVByb3BzLmRyYXc7XG5cdCAgICBkZWxldGUgby5jdXN0b21Qcm9wZXJ0aWVzO1xuXG5cdCAgICB0aGlzLl9jb3B5RGVmYXVsdEN1c3RvbVByb3BzKCk7XG5cblx0ICAgIC8vIGlmICggdGhpcy5fY3VzdG9tUHJvcHMgKSB7fVxuXHQgICAgLy8gdGhpcy5fY3VzdG9tUHJvcHMgPSB0aGlzLl9jdXN0b21Qcm9wcyB8fCB7fTtcblx0ICB9O1xuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2NvcHlEZWZhdWx0Q3VzdG9tUHJvcHMgPSBmdW5jdGlvbiBfY29weURlZmF1bHRDdXN0b21Qcm9wcygpIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jdXN0b21Qcm9wcykge1xuXHQgICAgICBpZiAodGhpcy5fb1trZXldID09IG51bGwpIHtcblx0ICAgICAgICB0aGlzLl9vW2tleV0gPSB0aGlzLl9jdXN0b21Qcm9wc1trZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJlc2V0IHNvbWUgZmxhZ3Mgb24gbWVyZ2VkIG9wdGlvbnMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBUaGVuYWJsZVxuXHQgICAgQHBhcmFtICAge09iamVjdH0gT3B0aW9ucyBvYmplY3QuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBIdG1sLnByb3RvdHlwZS5fcmVzZXRNZXJnZWRGbGFncyA9IGZ1bmN0aW9uIF9yZXNldE1lcmdlZEZsYWdzKG8pIHtcblx0ICAgIF9UaGVuYWJsZS5wcm90b3R5cGUuX3Jlc2V0TWVyZ2VkRmxhZ3MuY2FsbCh0aGlzLCBvKTtcblx0ICAgIG8ucHJvcHMgPSB0aGlzLl9wcm9wcztcblx0ICAgIG8uY3VzdG9tUHJvcGVydGllcyA9IHRoaXMuX2N1c3RvbVByb3BzO1xuXHQgICAgcmV0dXJuIG87XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIG9wdGlvbiB2YWx1ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gT3B0aW9uIG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gT3B0aW9uIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9wYXJzZU9wdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZU9wdGlvbihrZXksIHZhbHVlKSB7XG5cdCAgICBfVGhlbmFibGUucHJvdG90eXBlLl9wYXJzZU9wdGlvbi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgcHJvcGVydHkgaXMgcGFyc2VkXG5cdCAgICB2YXIgcGFyc2VkID0gdGhpcy5fcHJvcHNba2V5XTtcblx0ICAgIC8vIGNhc3QgaXQgdG8gc3RyaW5nIGlmIGl0IGlzIGFycmF5XG5cdCAgICBpZiAoaC5pc0FycmF5KHBhcnNlZCkpIHtcblx0ICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IHRoaXMuX2FyclRvU3RyaW5nKHBhcnNlZCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGNhc3QgYXJyYXkgdG8gc3RyaW5nIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIHBhcnNlZCBudW1iZXJzIHdpdGggdW5pdHMuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBDYXN0ZWQgYXJyYXkuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2FyclRvU3RyaW5nID0gZnVuY3Rpb24gX2FyclRvU3RyaW5nKGFycikge1xuXHQgICAgdmFyIHN0cmluZyA9ICcnO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgc3RyaW5nICs9IGFycltpXS5zdHJpbmcgKyAnICc7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gc3RyaW5nO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgZGVmYXVscyB0byBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gYWRkIGRlZmF1bHRzIHRvLlxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9hZGREZWZhdWx0cyA9IGZ1bmN0aW9uIF9hZGREZWZhdWx0cyhvYmopIHtcblx0ICAgIC8vIGZsYWcgdGhhdCBhZnRlciBhbGwgZGVmYXVsdHMgYXJlIHNldCB3aWxsIGluZGljYXRlXG5cdCAgICAvLyBpZiB1c2VyIGhhdmUgc2V0IHRoZSAzZCB0cmFuc2Zvcm1cblx0ICAgIHRoaXMuX2lzM2QgPSBmYWxzZTtcblxuXHQgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2RlZmF1bHRzKSB7XG5cdCAgICAgIC8vIHNraXAgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkIGluIF9za2lwUHJvcHNcblx0ICAgICAgLy8gaWYgKHRoaXMuX3NraXBQcm9wcyAmJiB0aGlzLl9za2lwUHJvcHNba2V5XSkgeyBjb250aW51ZTsgfVxuXG5cdCAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnRpZXMgdG8gdGhlIF9vIG9iamVjdFxuXHQgICAgICAvLyBpZiBpdCdzIG51bGwgLSBzZXQgdGhlIGRlZmF1bHQgdmFsdWVcblx0ICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAvLyBzY2FsZVggYW5kIHNjYWxlWSBzaG91bGQgZmFsbGJhY2sgdG8gc2NhbGVcblx0ICAgICAgICBpZiAoa2V5ID09PSAnc2NhbGVYJyB8fCBrZXkgPT09ICdzY2FsZVknKSB7XG5cdCAgICAgICAgICBvYmpba2V5XSA9IG9ialsnc2NhbGUnXSAhPSBudWxsID8gb2JqWydzY2FsZSddIDogdGhpcy5fZGVmYXVsdHNbJ3NjYWxlJ107XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9ialtrZXldID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gZ2V0IGlmIDNkIHByb3BlcnR5IHdhcyBzZXQuXG5cdCAgICAgICAgaWYgKHRoaXMuXzNkUHJvcGVydGllcy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG5cdCAgICAgICAgICB0aGlzLl9pczNkID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX28uaXNGb3JjZTNkKSB7XG5cdCAgICAgIHRoaXMuX2lzM2QgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIExpZmVjeWNsZSBtZXRob2QgdG8gZGVjbGFyZSB2YXJpYWJsZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICAvLyBzZXQgZGVsdGFzIHRvIHRoZSBsYXN0IHZhbHVlLCBzbyB0aGUgX3Byb3BzIHdpdGhcblx0ICAgIC8vIGVuZCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIF9oaXN0b3J5LCBpdCBpc1xuXHQgICAgLy8gY3J1Y2lhbCBmb3IgYHRoZW5gIGNoYWluaW5nXG5cdCAgICB0aGlzLmRlbHRhcy5yZWZyZXNoKGZhbHNlKTtcblx0ICAgIC8vIGNhbGwgc3VwZXIgdmFyc1xuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgICAgLy8gc3RhdGUgb2Ygc2V0IHByb3BlcnRpZXNcblx0ICAgIHRoaXMuX3N0YXRlID0ge307XG5cdCAgICAvLyByZXN0b3JlIGRlbHRhIHZhbHVlcyB0aGF0IHdlIGhhdmUgcmVmcmVzaGVkIGJlZm9yZVxuXHQgICAgdGhpcy5kZWx0YXMucmVzdG9yZShmYWxzZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBkZWx0YXMgZnJvbSBwYXNzZWQgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdCB0byBwYXNzIHRvIHRoZSBEZWx0YXMuXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2NyZWF0ZURlbHRhcyA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YXMob3B0aW9ucykge1xuXHQgICAgdGhpcy5kZWx0YXMgPSBuZXcgX2RlbHRhczIuZGVmYXVsdCh7XG5cdCAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG5cdCAgICAgIHByb3BzOiB0aGlzLl9wcm9wcyxcblx0ICAgICAgYXJyYXlQcm9wZXJ0eU1hcDogdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCxcblx0ICAgICAgbnVtYmVyUHJvcGVydHlNYXA6IHRoaXMuX251bWJlclByb3BlcnR5TWFwLFxuXHQgICAgICBjdXN0b21Qcm9wczogdGhpcy5fY3VzdG9tUHJvcHMsXG5cdCAgICAgIGNhbGxiYWNrc0NvbnRleHQ6IG9wdGlvbnMuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLFxuXHQgICAgICBpc0NoYWluZWQ6ICEhdGhpcy5fby5wcmV2Q2hhaW5Nb2R1bGVcblx0ICAgIH0pO1xuXG5cdCAgICAvLyBpZiBjaGFpbmVkIG1vZHVsZSBzZXQgdGltZWxpbmUgdG8gZGVsdGFzJyB0aW1lbGluZVxuXHQgICAgaWYgKHRoaXMuX28ucHJldkNoYWluTW9kdWxlKSB7XG5cdCAgICAgIHRoaXMudGltZWxpbmUgPSB0aGlzLmRlbHRhcy50aW1lbGluZTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qIEBvdmVycmlkZXMgQCBUd2VlbmFibGUgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX21ha2VUd2VlbiA9IGZ1bmN0aW9uIF9tYWtlVHdlZW4oKSB7fTtcblxuXHQgIEh0bWwucHJvdG90eXBlLl9tYWtlVGltZWxpbmUgPSBmdW5jdGlvbiBfbWFrZVRpbWVsaW5lKCkge1xuXHQgICAgLy8gZG8gbm90IGNyZWF0ZSB0aW1lbGluZSBpZiBtb2R1bGUgaWYgY2hhaW5lZFxuXHQgICAgaWYgKHRoaXMuX28ucHJldkNoYWluTW9kdWxlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIGFkZCBjYWxsYmFja3Mgb3ZlcnJpZGVzXG5cdCAgICB0aGlzLl9vLnRpbWVsaW5lID0gdGhpcy5fby50aW1lbGluZSB8fCB7fTtcblx0ICAgIHRoaXMuX2FkZENhbGxiYWNrT3ZlcnJpZGVzKHRoaXMuX28udGltZWxpbmUpO1xuXHQgICAgX1RoZW5hYmxlLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLmRlbHRhcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBjYWxsYmFjayBvdmVycmlkZXMgdG8gcGFzc2VkIG9iamVjdCBvYmplY3QuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGFkZCBvdmVycmlkZXMgb24uXG5cdCAgKi9cblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX2FkZENhbGxiYWNrT3ZlcnJpZGVzID0gZnVuY3Rpb24gX2FkZENhbGxiYWNrT3ZlcnJpZGVzKG8pIHtcblx0ICAgIHZhciBpdCA9IHRoaXM7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgby5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IHRoaXMuX2RyYXcsXG5cdCAgICAgIG9uUmVmcmVzaDogdGhpcy5fcHJvcHMuaXNSZWZyZXNoU3RhdGUgPyB0aGlzLl9kcmF3IDogdm9pZCAwLFxuXHQgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGlzRndkKSB7XG5cdCAgICAgICAgLy8gZG9uJ3QgdG91Y2ggbWFpbiBgZWxgIG9uU3RhcnQgaW4gY2hhaW5lZCBlbGVtZW50c1xuXHQgICAgICAgIGlmIChpdC5faXNDaGFpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBzaG93IGlmIHdhcyBoaWRkZW4gYXQgc3RhcnRcblx0ICAgICAgICBpZiAoaXNGd2QgJiYgIXAuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgICAgIGl0Ll9zaG93KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGhpZGUgaWYgc2hvdWxkIGJlIGhpZGRlbiBhdCBzdGFydFxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoIXAuaXNTaG93U3RhcnQpIHtcblx0ICAgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH0sXG5cdCAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoaXNGd2QpIHtcblx0ICAgICAgICAvLyBkb24ndCB0b3VjaCBtYWluIGBlbGAgaWYgbm90IHRoZSBsYXN0IGluIGB0aGVuYCBjaGFpblxuXHQgICAgICAgIGlmIChpdC5faXNDaGFpbmVkKSB7XG5cdCAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChpc0Z3ZCkge1xuXHQgICAgICAgICAgaWYgKCFwLmlzU2hvd0VuZCkge1xuXHQgICAgICAgICAgICBpdC5faGlkZSgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSBpZiAoIXAuaXNTaG93RW5kKSB7XG5cdCAgICAgICAgICBpdC5fc2hvdygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0aGF0IGdldHMgY2FsbGVkIG9uIGBzb2Z0YCBzaG93IG9mIHRoZSBtb2R1bGUsXG5cdCAgICBpdCBzaG91bGQgcmVzdG9yZSB0cmFuc2Zvcm0gc3R5bGVzIG9mIHRoZSBtb2R1bGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIE1vZHVsZVxuXHQgICovXG5cblxuXHQgIEh0bWwucHJvdG90eXBlLl9zaG93QnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2hvd0J5VHJhbnNmb3JtKCkge1xuXHQgICAgdGhpcy5fZHJhd1RyYW5zZm9ybSgpO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG1lcmdlIGBzdGFydGAgYW5kIGBlbmRgIGZvciBhIHByb3BlcnR5IGluIHRoZW4gcmVjb3JkLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBFbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuXHQgICovXG5cdCAgLy8gISEgQ09WRVIgISFcblxuXG5cdCAgSHRtbC5wcm90b3R5cGUuX21lcmdlVGhlblByb3BlcnR5ID0gZnVuY3Rpb24gX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcblx0ICAgIC8vIGlmIGlzbnQgdHdlZW4gcHJvcGVydHlcblx0ICAgIHZhciBpc0Jvb2xlYW4gPSB0eXBlb2YgZW5kVmFsdWUgPT09ICdib29sZWFuJyxcblx0ICAgICAgICBjdXJ2ZSxcblx0ICAgICAgICBlYXNpbmc7XG5cblx0ICAgIGlmICghaC5pc1R3ZWVuUHJvcChrZXkpICYmICF0aGlzLl9ub25NZXJnZVByb3BzW2tleV0gJiYgIWlzQm9vbGVhbikge1xuXG5cdCAgICAgIHZhciBUV0VFTl9QUk9QUyA9IHt9O1xuXHQgICAgICBpZiAoaC5pc09iamVjdChlbmRWYWx1ZSkgJiYgZW5kVmFsdWUudG8gIT0gbnVsbCkge1xuXHQgICAgICAgIGZvciAodmFyIF9rZXkgaW4gZW5kVmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChUV0VFTl9QUk9QRVJUSUVTW19rZXldIHx8IF9rZXkgPT09ICdjdXJ2ZScpIHtcblx0ICAgICAgICAgICAgVFdFRU5fUFJPUFNbX2tleV0gPSBlbmRWYWx1ZVtfa2V5XTtcblx0ICAgICAgICAgICAgZGVsZXRlIGVuZFZhbHVlW19rZXldO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBjdXJ2ZSAgICA9IGVuZFZhbHVlLmN1cnZlO1xuXHQgICAgICAgIC8vIGVhc2luZyAgID0gZW5kVmFsdWUuZWFzaW5nO1xuXHQgICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUudG87XG5cdCAgICAgIH1cblxuXHQgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgZGVsdGEgLSBqdXN0IHNhdmUgaXRcblx0ICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoZW5kVmFsdWUpKSB7XG5cblx0ICAgICAgICB2YXIgX1RXRUVOX1BST1BTID0ge307XG5cdCAgICAgICAgZm9yICh2YXIgX2tleTIgaW4gZW5kVmFsdWUpIHtcblx0ICAgICAgICAgIGlmIChUV0VFTl9QUk9QRVJUSUVTW19rZXkyXSB8fCBfa2V5MiA9PT0gJ2N1cnZlJykge1xuXHQgICAgICAgICAgICBfVFdFRU5fUFJPUFNbX2tleTJdID0gZW5kVmFsdWVbX2tleTJdO1xuXHQgICAgICAgICAgICBkZWxldGUgZW5kVmFsdWVbX2tleTJdO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fcGFyc2VEZWx0YVZhbHVlcyhrZXksIGVuZFZhbHVlKTtcblxuXHQgICAgICAgIHJldHVybiAoMCwgX2V4dGVuZHM1LmRlZmF1bHQpKHt9LCByZXN1bHQsIF9UV0VFTl9QUk9QUyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdmFyIHBhcnNlZEVuZFZhbHVlID0gdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgZW5kVmFsdWUpO1xuXHQgICAgICAgIC8vIGlmIGVuZCB2YWx1ZSBpcyBub3QgZGVsdGEgLSBtZXJnZSB3aXRoIHN0YXJ0IHZhbHVlXG5cdCAgICAgICAgaWYgKHRoaXMuX2lzRGVsdGEoc3RhcnRWYWx1ZSkpIHtcblx0ICAgICAgICAgIHZhciBfZXh0ZW5kczI7XG5cblx0ICAgICAgICAgIC8vIGlmIHN0YXJ0IHZhbHVlIGlzIGRlbHRhIC0gdGFrZSB0aGUgZW5kIHZhbHVlXG5cdCAgICAgICAgICAvLyBhcyBzdGFydCB2YWx1ZSBvZiB0aGUgbmV3IGRlbHRhXG5cdCAgICAgICAgICByZXR1cm4gKDAsIF9leHRlbmRzNS5kZWZhdWx0KSgoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltoLmdldERlbHRhRW5kKHN0YXJ0VmFsdWUpXSA9IHBhcnNlZEVuZFZhbHVlLCBfZXh0ZW5kczIpLCBUV0VFTl9QUk9QUyk7XG5cdCAgICAgICAgICAvLyBpZiBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWUgYXJlIG5vdCDiiIYgLSBtYWtlIOKIhlxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBfZXh0ZW5kczM7XG5cblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfZXh0ZW5kczUuZGVmYXVsdCkoKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNbc3RhcnRWYWx1ZV0gPSBwYXJzZWRFbmRWYWx1ZSwgX2V4dGVuZHMzKSwgVFdFRU5fUFJPUFMpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIC8vIGNvcHkgdGhlIHR3ZWVuIHZhbHVlcyB1bmF0dGVuZGVkXG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBlbmRWYWx1ZTtcblx0ICAgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gSHRtbDtcblx0fShfdGhlbmFibGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEh0bWw7XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHR2YXIgX3R1bmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuXHR2YXIgX3R1bmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHVuYWJsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgU3RhZ2dlciA9IGZ1bmN0aW9uIChfVHVuYWJsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFN0YWdnZXIsIF9UdW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIFN0YWdnZXIob3B0aW9ucywgTW9kdWxlKSB7XG5cdCAgICB2YXIgX3JldDtcblxuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgU3RhZ2dlcik7XG5cblx0ICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R1bmFibGUuY2FsbCh0aGlzKSk7XG5cblx0ICAgIHJldHVybiBfcmV0ID0gX3RoaXMuX2luaXQob3B0aW9ucywgTW9kdWxlKSwgKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KShfdGhpcywgX3JldCk7XG5cdCAgfVxuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdGhlbiBjaGFpbiBvbiBjaGlsZCBtb2R1bGVzLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGhlbiBvcHRpb25zLlxyXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IHRoaXMuXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihvKSB7XG5cdCAgICBpZiAobyA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIC8vIGdldCBjaGlsZCBtb2R1bGUncyBvcHRpb24gYW5kIHBhc3MgdG8gdGhlIGNoaWxkIGB0aGVuYFxuXHQgICAgICB0aGlzLl9tb2R1bGVzW2ldLnRoZW4odGhpcy5fZ2V0T3B0aW9uQnlJbmRleChpLCBvKSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnRpbWVsaW5lLl9yZWNhbGNUb3RhbER1cmF0aW9uKCk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byB0dW5lIGNoaWxkIG1vZHVsZXMuXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUdW5lIG9wdGlvbnMuXHJcblx0ICAgIEByZXR1cm4ge09iamVjdH0gdGhpcy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLnR1bmUgPSBmdW5jdGlvbiB0dW5lKG8pIHtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvbiBhbmQgcGFzcyB0byB0aGUgY2hpbGQgYHRoZW5gXG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0udHVuZSh0aGlzLl9nZXRPcHRpb25CeUluZGV4KGksIG8pKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdlbmVyYXRlIGNoaWxkIG1vZHVsZXMuXHJcblx0ICAgIEByZXR1cm4ge09iamVjdH0gdGhpcy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX21vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgLy8gZ2V0IGNoaWxkIG1vZHVsZSdzIG9wdGlvbiBhbmQgcGFzcyB0byB0aGUgY2hpbGQgYHRoZW5gXG5cdCAgICAgIHRoaXMuX21vZHVsZXNbaV0uZ2VuZXJhdGUoKTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3JlY2FsY1RvdGFsRHVyYXRpb24oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdldCBhbiBvcHRpb24gYnkgbW9kdWxvIGFuZCBuYW1lLlxyXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxyXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggZm9yIHRoZSBtb2R1bG8gY2FsY3VsYXRpb24uXHJcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIGhhc2ggdG8gbG9vayBpbi5cclxuXHQgICAgQHJldHVybiB7QW55fSBQcm9wZXJ0eS5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9nZXRPcHRpb25CeU1vZCA9IGZ1bmN0aW9uIF9nZXRPcHRpb25CeU1vZChuYW1lLCBpLCBzdG9yZSkge1xuXHQgICAgdmFyIHByb3BzID0gc3RvcmVbbmFtZV07XG5cdCAgICAvLyBpZiBub3QgZG9tIGxpc3QgdGhlbiBjbG9uZSBpdCB0byBhcnJheVxuXHQgICAgaWYgKHByb3BzICsgJycgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgcHJvcHMgKyAnJyA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJykgcHJvcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwcm9wcywgMCk7XG5cdCAgICAvLyBnZXQgdGhlIHZhbHVlIGluIGFycmF5IG9yIHJldHVybiB0aGUgdmFsdWUgaXRzZWxmXG5cdCAgICB2YXIgdmFsdWUgPSBfaDIuZGVmYXVsdC5pc0FycmF5KHByb3BzKSA/IHByb3BzW2kgJSBwcm9wcy5sZW5ndGhdIDogcHJvcHM7XG5cdCAgICAvLyBjaGVjayBpZiB2YWx1ZSBoYXMgdGhlIHN0YWdnZXIgZXhwcmVzc2lvbiwgaWYgc28gcGFyc2UgaXRcblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5wYXJzZUlmU3RhZ2dlcih2YWx1ZSwgaSk7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZ2V0IG9wdGlvbiBieSBtb2R1bG8gb2YgaW5kZXguXHJcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBmb3IgbW9kdWxvIGNhbGN1bGF0aW9ucy5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgaGFzaCB0byBsb29rIGluLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2dldE9wdGlvbkJ5SW5kZXggPSBmdW5jdGlvbiBfZ2V0T3B0aW9uQnlJbmRleChpLCBzdG9yZSkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAoMCwgX2tleXMyLmRlZmF1bHQpKHN0b3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSA9IF90aGlzMi5fZ2V0T3B0aW9uQnlNb2Qoa2V5LCBpLCBzdG9yZSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiBvcHRpb25zO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGdldCB0b3RhbCBjaGlsZCBtb2R1bGVzIHF1YW50aXR5LlxyXG5cdCAgICBAcGFyYW0gIHtTdHJpbmd9IE5hbWUgb2YgcXVhbnRpZmllciBpbiBvcHRpb25zIGhhc2guXHJcblx0ICAgIEBwYXJhbSAge09iamVjdH0gT3B0aW9ucyBoYXNoIG9iamVjdC5cclxuXHQgICAgQHJldHVybiB7TnVtYmVyfSBOdW1iZXIgb2YgY2hpbGQgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGRlZmluZWQuXHJcblx0ICAqL1xuXG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5fZ2V0Q2hpbGRRdWFudGl0eSA9IGZ1bmN0aW9uIF9nZXRDaGlsZFF1YW50aXR5KG5hbWUsIHN0b3JlKSB7XG5cdCAgICAvLyBpZiBudW1iZXIgd2FzIHNldFxuXHQgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gbmFtZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHF1YW50aWZpZXIgPSBzdG9yZVtuYW1lXTtcblx0ICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHF1YW50aWZpZXIpKSB7XG5cdCAgICAgIHJldHVybiBxdWFudGlmaWVyLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAocXVhbnRpZmllciArICcnID09PSAnW29iamVjdCBOb2RlTGlzdF0nKSB7XG5cdCAgICAgIHJldHVybiBxdWFudGlmaWVyLmxlbmd0aDtcblx0ICAgIH0gZWxzZSBpZiAocXVhbnRpZmllciArICcnID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKSB7XG5cdCAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChxdWFudGlmaWVyLCAwKS5sZW5ndGg7XG5cdCAgICB9IGVsc2UgaWYgKHF1YW50aWZpZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHQgICAgICByZXR1cm4gMTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHF1YW50aWZpZXIgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gbWFrZSBzdGFnZ2VyIGZvcm0gb3B0aW9uc1xyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucy5cclxuXHQgICAgQHBhcmFtIHtPYmplY3R9IENoaWxkIGNsYXNzLlxyXG5cdCAgKi9cblxuXG5cdCAgU3RhZ2dlci5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBfaW5pdChvcHRpb25zLCBNb2R1bGUpIHtcblx0ICAgIHZhciBjb3VudCA9IHRoaXMuX2dldENoaWxkUXVhbnRpdHkob3B0aW9ucy5xdWFudGlmaWVyIHx8ICdlbCcsIG9wdGlvbnMpO1xuXHQgICAgdGhpcy5fY3JlYXRlVGltZWxpbmUob3B0aW9ucyk7dGhpcy5fbW9kdWxlcyA9IFtdO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdCAgICAgIC8vIGdldCBjaGlsZCBtb2R1bGUncyBvcHRpb25cblx0ICAgICAgdmFyIG9wdGlvbiA9IHRoaXMuX2dldE9wdGlvbkJ5SW5kZXgoaSwgb3B0aW9ucyk7XG5cdCAgICAgIG9wdGlvbi5pc1J1bkxlc3MgPSB0cnVlO1xuXHQgICAgICAvLyBzZXQgaW5kZXggb2YgdGhlIG1vZHVsZVxuXHQgICAgICBvcHRpb24uaW5kZXggPSBpO1xuXHQgICAgICAvLyBjcmVhdGUgY2hpbGQgbW9kdWxlXG5cdCAgICAgIHZhciBtb2R1bGUgPSBuZXcgTW9kdWxlKG9wdGlvbik7dGhpcy5fbW9kdWxlcy5wdXNoKG1vZHVsZSk7XG5cdCAgICAgIC8vIGFkZCBjaGlsZCBtb2R1bGUncyB0aW1lbGluZSB0byB0aGUgc2VsZiB0aW1lbGluZVxuXHQgICAgICB0aGlzLnRpbWVsaW5lLmFkZChtb2R1bGUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIHRpbWVsaW5lLlxyXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVGltZWxpbmUgb3B0aW9ucy5cclxuXHQgICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9jcmVhdGVUaW1lbGluZSA9IGZ1bmN0aW9uIF9jcmVhdGVUaW1lbGluZSgpIHtcblx0ICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KG9wdGlvbnMudGltZWxpbmUpO1xuXHQgIH07XG5cblx0ICAvKiBAb3ZlcnJpZGVzIEAgVHdlZW5hYmxlICovXG5cblxuXHQgIFN0YWdnZXIucHJvdG90eXBlLl9tYWtlVHdlZW4gPSBmdW5jdGlvbiBfbWFrZVR3ZWVuKCkge307XG5cblx0ICBTdGFnZ2VyLnByb3RvdHlwZS5fbWFrZVRpbWVsaW5lID0gZnVuY3Rpb24gX21ha2VUaW1lbGluZSgpIHt9O1xuXG5cdCAgcmV0dXJuIFN0YWdnZXI7XG5cdH0oX3R1bmFibGUyLmRlZmF1bHQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1vZHVsZSkge1xuXHQgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgcmV0dXJuIG5ldyBTdGFnZ2VyKG9wdGlvbnMsIE1vZHVsZSk7XG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3R3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuXHR2YXIgX3R3ZWVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuKTtcblxuXHR2YXIgX3RpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuXHR2YXIgX3RpbWVsaW5lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbWVsaW5lKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdC8qXHJcblx0ICBDbGFzcyBmb3IgdG9nZ2xpbmcgb3BhY2l0eSBvbiBidW5jaCBvZiBlbGVtZW50c1xyXG5cdCAgQGNsYXNzIFNwcml0ZXJcclxuXHQgIEB0b2RvXHJcblx0ICAgIC0gYWRkIGlzRm9yY2UzZCBvcHRpb25cclxuXHQgICAgLSBhZGQgcnVuIG5ldyBvcHRpb24gbWVyZ2luZ1xyXG5cdCAgICAtIGFkZCB0aGVuIGNoYWluc1xyXG5cdCovXG5cblx0dmFyIFNwcml0ZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgLypcclxuXHQgICAgRGVmYXVsdHMvQVBJc1xyXG5cdCAgKi9cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBEdXJhdGlvblxyXG5cdCAgICAgICAgQHByb3BlcnR5IGR1cmF0aW9uXHJcblx0ICAgICAgICBAdHlwZSAgICAge051bWJlcn1cclxuXHQgICAgICAqL1xuXHQgICAgICBkdXJhdGlvbjogNTAwLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgRGVsYXlcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBkZWxheVxyXG5cdCAgICAgICAgQHR5cGUgICAgIHtOdW1iZXJ9XHJcblx0ICAgICAgKi9cblx0ICAgICAgZGVsYXk6IDAsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBFYXNpbmcuIFBsZWFzZSBzZWUgdGhlIFxyXG5cdCAgICAgICAgW3RpbWVsaW5lIG1vZHVsZSBwYXJzZUVhc2luZyBmdW5jdGlvbl0odGltZWxpbmUuY29mZmVlLmh0bWwjcGFyc2VFYXNpbmcpXHJcblx0ICAgICAgICBmb3IgYWxsIGF2YWxpYWJsZSBvcHRpb25zLlxyXG5cdCAgICAgICAgICBAcHJvcGVydHkgZWFzaW5nXHJcblx0ICAgICAgICBAdHlwZSAgICAge1N0cmluZywgRnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgZWFzaW5nOiAnbGluZWFyLm5vbmUnLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgUmVwZWF0IHRpbWVzIGNvdW50XHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSByZXBlYXRcclxuXHQgICAgICAgIEB0eXBlICAgICB7TnVtYmVyfVxyXG5cdCAgICAgICovXG5cdCAgICAgIHJlcGVhdDogMCxcblx0ICAgICAgLypcclxuXHQgICAgICAgIFlveW8gb3B0aW9uIGRlZmluZXMgaWYgYW5pbWF0aW9uIHNob3VsZCBiZSBhbHRlcmVkIG9uIHJlcGVhdC5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IHlveW9cclxuXHQgICAgICAgIEB0eXBlICAgICB7Qm9vbGVhbn1cclxuXHQgICAgICAqL1xuXHQgICAgICB5b3lvOiBmYWxzZSxcblx0ICAgICAgLypcclxuXHQgICAgICAgIGlzUnVuTGVzcyBvcHRpb24gcHJldmVudHMgYW5pbWF0aW9uIGZyb20gcnVubmluZyBpbW1lZGlhdGVseSBhZnRlclxyXG5cdCAgICAgICAgaW5pdGlhbGl6YXRpb24uXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBpc1J1bkxlc3NcclxuXHQgICAgICAgIEB0eXBlICAgICB7Qm9vbGVhbn1cclxuXHQgICAgICAqL1xuXHQgICAgICBpc1J1bkxlc3M6IGZhbHNlLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgaXNTaG93RW5kIG9wdGlvbiBkZWZpbmVzIGlmIHRoZSBsYXN0IGZyYW1lIHNob3VsZCBiZSBzaG93biB3aGVuXHJcblx0ICAgICAgICBhbmltYXRpb24gY29tcGxldGVkLlxyXG5cdCAgICAgICAgXHJcblx0ICAgICAgICBAcHJvcGVydHkgaXNTaG93RW5kXHJcblx0ICAgICAgICBAdHlwZSAgICAge0Jvb2xlYW59XHJcblx0ICAgICAgKi9cblx0ICAgICAgaXNTaG93RW5kOiBmYWxzZSxcblx0ICAgICAgLypcclxuXHQgICAgICAgIG9uU3RhcnQgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgb25jZSBvbiBhbmltYXRpb24gc3RhcnQuXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIEBwcm9wZXJ0eSBvblN0YXJ0XHJcblx0ICAgICAgICBAdHlwZSAgICAge0Z1bmN0aW9ufVxyXG5cdCAgICAgICovXG5cdCAgICAgIG9uU3RhcnQ6IG51bGwsXG5cdCAgICAgIC8qXHJcblx0ICAgICAgICBvblVwZGF0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbiBldmVyeSBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG5cdCAgICAgICAgVGhlIGN1cnJlbnQgcHJvZ3Jlc3MgaW4gcmFuZ2UgKipbMCwxXSoqIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IG9uVXBkYXRlXHJcblx0ICAgICAgICBAdHlwZSAgICAge0Z1bmN0aW9ufVxyXG5cdCAgICAgICovXG5cdCAgICAgIG9uVXBkYXRlOiBudWxsLFxuXHQgICAgICAvKlxyXG5cdCAgICAgICAgb25Db21wbGV0ZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbmNlIG9uIGFuaW1hdGlvbiBjb21wbGV0ZS5cclxuXHQgICAgICAgIFxyXG5cdCAgICAgICAgQHByb3BlcnR5IG9uQ29tcGxldGVcclxuXHQgICAgICAgIEB0eXBlICAgICB7RnVuY3Rpb259XHJcblx0ICAgICAgKi9cblx0ICAgICAgb25Db21wbGV0ZTogbnVsbFxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gU3ByaXRlcigpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBTcHJpdGVyKTtcblxuXHQgICAgdGhpcy5vID0gbztcblx0ICAgIGlmICghdGhpcy5vLmVsKSB7XG5cdCAgICAgIHJldHVybiBfaDIuZGVmYXVsdC5lcnJvcignTm8gXCJlbFwiIG9wdGlvbiBzcGVjaWZpZWQsIGFib3J0aW5nJyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl92YXJzKCk7dGhpcy5fZGVjbGFyZURlZmF1bHRzKCk7dGhpcy5fZXh0ZW5kRGVmYXVsdHMoKTt0aGlzLl9wYXJzZUZyYW1lcygpO1xuXHQgICAgaWYgKHRoaXMuX2ZyYW1lcy5sZW5ndGggPD0gMikgX2gyLmRlZmF1bHQud2FybignU3ByaXRlcjogb25seSAnICsgdGhpcy5fZnJhbWVzLmxlbmd0aCArICcgZnJhbWVzIGZvdW5kJyk7XG5cdCAgICBpZiAodGhpcy5fZnJhbWVzLmxlbmd0aCA8IDEpIF9oMi5kZWZhdWx0LmVycm9yKFwiU3ByaXRlcjogdGhlcmUgaXMgbm8gZnJhbWVzIHRvIGFuaW1hdGUsIGFib3J0aW5nXCIpO1xuXHQgICAgdGhpcy5fY3JlYXRlVHdlZW4oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblx0ICAvKlxyXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBzb21lIHZhcmlhYmxlcy5cclxuXHQgICAgXHJcblx0ICAgIEBtZXRob2QgcnVuXHJcblx0ICAgIEBwYXJhbSAge09iamVjdH0gTmV3IG9wdGlvbnNcclxuXHQgICAgQHRvZG8gICBJbXBsZW1lbnQgbmV3IG9iamVjdCBtZXJnaW5nXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy5fcHJvcHMgPSBfaDIuZGVmYXVsdC5jbG9uZU9iaih0aGlzLm8pO1xuXHQgICAgdGhpcy5lbCA9IHRoaXMuby5lbDtcblx0ICAgIHRoaXMuX2ZyYW1lcyA9IFtdO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIHJ1biB0aGUgc3ByaXRlciBvbiBkZW1hbmQuXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIHJ1blxyXG5cdCAgICBAcGFyYW0gIHtPYmplY3R9IE5ldyBvcHRpb25zXHJcblx0ICAgIEB0b2RvICAgSW1wbGVtZW50IG5ldyBvYmplY3QgbWVyZ2luZ1xyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuKG8pIHtcblx0ICAgIHJldHVybiB0aGlzLnRpbWVsaW5lLnBsYXkoKTtcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBleHRlbmQgX3Byb3BzIGJ5IG9wdGlvbnModGhpcy5vKVxyXG5cdCAgICBcclxuXHQgICAgQG1ldGhvZCBfZXh0ZW5kRGVmYXVsdHNcclxuXHQgICovXG5cblxuXHQgIFNwcml0ZXIucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIHJldHVybiBfaDIuZGVmYXVsdC5leHRlbmQodGhpcy5fcHJvcHMsIHRoaXMuX2RlZmF1bHRzKTtcblx0ICB9O1xuXHQgIC8qXHJcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBmcmFtZXMgYXMgY2hpbGQgbm9kZXMgb2YgZWwuXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIF9wYXJzZUZyYW1lc1xyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX3BhcnNlRnJhbWVzID0gZnVuY3Rpb24gX3BhcnNlRnJhbWVzKCkge1xuXHQgICAgdGhpcy5fZnJhbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbC5jaGlsZHJlbiwgMCk7XG5cdCAgICB0aGlzLl9mcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUsIGkpIHtcblx0ICAgICAgcmV0dXJuIGZyYW1lLnN0eWxlLm9wYWNpdHkgPSAwO1xuXHQgICAgfSk7XG5cdCAgICB0aGlzLl9mcmFtZVN0ZXAgPSAxIC8gdGhpcy5fZnJhbWVzLmxlbmd0aDtcblx0ICB9O1xuXG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0d2VlbiBhbmQgdGltZWxpbmUgYW5kIHN1cHBseSBjYWxsYmFja3MuXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIF9jcmVhdGVUd2VlblxyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX2NyZWF0ZVR3ZWVuID0gZnVuY3Rpb24gX2NyZWF0ZVR3ZWVuKCkge1xuXHQgICAgdmFyIF90aGlzID0gdGhpcztcblxuXHQgICAgdGhpcy5fdHdlZW4gPSBuZXcgX3R3ZWVuMi5kZWZhdWx0KHtcblx0ICAgICAgZHVyYXRpb246IHRoaXMuX3Byb3BzLmR1cmF0aW9uLFxuXHQgICAgICBkZWxheTogdGhpcy5fcHJvcHMuZGVsYXksXG5cdCAgICAgIHlveW86IHRoaXMuX3Byb3BzLnlveW8sXG5cdCAgICAgIHJlcGVhdDogdGhpcy5fcHJvcHMucmVwZWF0LFxuXHQgICAgICBlYXNpbmc6IHRoaXMuX3Byb3BzLmVhc2luZyxcblx0ICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMuX3Byb3BzLm9uU3RhcnQgJiYgX3RoaXMuX3Byb3BzLm9uU3RhcnQoKTtcblx0ICAgICAgfSxcblx0ICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMuX3Byb3BzLm9uQ29tcGxldGUgJiYgX3RoaXMuX3Byb3BzLm9uQ29tcGxldGUoKTtcblx0ICAgICAgfSxcblx0ICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHApIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMuX3NldFByb2dyZXNzKHApO1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KCk7dGhpcy50aW1lbGluZS5hZGQodGhpcy5fdHdlZW4pO1xuXHQgICAgaWYgKCF0aGlzLl9wcm9wcy5pc1J1bkxlc3MpIHRoaXMuX3N0YXJ0VHdlZW4oKTtcblx0ICB9O1xuXG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHR3ZWVuXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIF9zdGFydFR3ZWVuXHJcblx0ICAqL1xuXG5cblx0ICBTcHJpdGVyLnByb3RvdHlwZS5fc3RhcnRUd2VlbiA9IGZ1bmN0aW9uIF9zdGFydFR3ZWVuKCkge1xuXHQgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cblx0ICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gX3RoaXMyLnRpbWVsaW5lLnBsYXkoKTtcblx0ICAgIH0sIDEpO1xuXHQgIH07XG5cdCAgLypcclxuXHQgICAgTWV0aG9kIHRvIHNldCBwcm9ncmVzcyBvZiB0aGUgc3ByaXRlXHJcblx0ICAgIFxyXG5cdCAgICBAbWV0aG9kIF9zZXRQcm9ncmVzc1xyXG5cdCAgICBAcGFyYW0gIHtOdW1iZXJ9IFByb2dyZXNzIGluIHJhbmdlICoqWzAsMV0qKlxyXG5cdCAgKi9cblxuXG5cdCAgU3ByaXRlci5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKHApIHtcblx0ICAgIC8vIGdldCB0aGUgZnJhbWUgbnVtYmVyXG5cdCAgICB2YXIgcHJvYyA9IE1hdGguZmxvb3IocCAvIHRoaXMuX2ZyYW1lU3RlcCk7XG5cdCAgICAvLyByZWFjdCBvbmx5IGlmIGZyYW1lIGNoYW5nZXNcblx0ICAgIGlmICh0aGlzLl9wcmV2RnJhbWUgIT0gdGhpcy5fZnJhbWVzW3Byb2NdKSB7XG5cdCAgICAgIC8vIGlmIHByZXZpb3VzIGZyYW1lIGlzbnQgY3VycmVudCBvbmUsIGhpZGUgaXRcblx0ICAgICAgaWYgKHRoaXMuX3ByZXZGcmFtZSkge1xuXHQgICAgICAgIHRoaXMuX3ByZXZGcmFtZS5zdHlsZS5vcGFjaXR5ID0gMDtcblx0ICAgICAgfVxuXHQgICAgICAvLyBpZiBlbmQgb2YgYW5pbWF0aW9uIGFuZCBpc1Nob3dFbmQgZmxhZyB3YXMgc3BlY2lmaWVkXG5cdCAgICAgIC8vIHRoZW4gc2hvdyB0aGUgbGFzdCBmcmFtZSBlbHNlIHNob3cgY3VycmVudCBmcmFtZVxuXHQgICAgICB2YXIgY3VycmVudE51bSA9IHAgPT09IDEgJiYgdGhpcy5fcHJvcHMuaXNTaG93RW5kID8gcHJvYyAtIDEgOiBwcm9jO1xuXHQgICAgICAvLyBzaG93IHRoZSBjdXJyZW50IGZyYW1lXG5cdCAgICAgIGlmICh0aGlzLl9mcmFtZXNbY3VycmVudE51bV0pIHtcblx0ICAgICAgICB0aGlzLl9mcmFtZXNbY3VycmVudE51bV0uc3R5bGUub3BhY2l0eSA9IDE7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gc2V0IHByZXZpb3VzIGZyYW1lIGFzIGN1cnJlbnRcblx0ICAgICAgdGhpcy5fcHJldkZyYW1lID0gdGhpcy5fZnJhbWVzW3Byb2NdO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX3Byb3BzLm9uVXBkYXRlKSB7XG5cdCAgICAgIHRoaXMuX3Byb3BzLm9uVXBkYXRlKHApO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICByZXR1cm4gU3ByaXRlcjtcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IFNwcml0ZXI7XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0dmFyIF90d2VlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cblx0dmFyIF90d2VlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuZXIpO1xuXG5cdHZhciBfZWFzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cblx0dmFyIF9lYXNpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFzaW5nKTtcblxuXHR2YXIgX21vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXG5cdHZhciBfbW9kdWxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21vZHVsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvLyBpbXBvcnQgaCBmcm9tICcuLi9oJztcblxuXHR2YXIgVHdlZW4gPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFR3ZWVuLCBfTW9kdWxlKTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgZG8gZGVjbGFyZSBkZWZhdWx0cyB3aXRoIHRoaXMuX2RlZmF1bHRzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIC8vIERFRkFVTFRTXG5cdCAgICB0aGlzLl9kZWZhdWx0cyA9IHtcblx0ICAgICAgLyogZHVyYXRpb24gb2YgdGhlIHR3ZWVuIFswLi7iiJ5dICovXG5cdCAgICAgIGR1cmF0aW9uOiAzNTAsXG5cdCAgICAgIC8qIGRlbGF5IG9mIHRoZSB0d2VlbiBbLeKIni4u4oieXSAqL1xuXHQgICAgICBkZWxheTogMCxcblx0ICAgICAgLyogcmVwZWF0IG9mIHRoZSB0d2VlbiBbMC4u4oieXSwgbWVhbnMgaG93IG11Y2ggdG9cblx0ICAgICAgICAgcmVwZWF0IHRoZSB0d2VlbiByZWdhcmRsZXNzIGZpcnN0IHJ1bixcblx0ICAgICAgICAgZm9yIGluc3RhbmNlIHJlcGVhdDogMiB3aWxsIG1ha2UgdGhlIHR3ZWVuIHJ1biAzIHRpbWVzICovXG5cdCAgICAgIHJlcGVhdDogMCxcblx0ICAgICAgLyogc3BlZWQgb2YgcGxheWJhY2sgWzAuLuKInl0sIHNwZWVkIHRoYXQgaXMgbGVzcyB0aGVuIDFcblx0ICAgICAgICAgd2lsbCBzbG93ZG93biBwbGF5YmFjaywgZm9yIGluc3RhbmNlIC41IHdpbGwgbWFrZSB0d2VlblxuXHQgICAgICAgICBydW4gMnggc2xvd2VyLiBTcGVlZCBvZiAyIHdpbGwgc3BlZWR1cCB0aGUgdHdlZW4gdG8gMnguICovXG5cdCAgICAgIHNwZWVkOiAxLFxuXHQgICAgICAvKiAgZmxpcCBvblVwZGF0ZSdzIHByb2dyZXNzIG9uIGVhY2ggZXZlbiBwZXJpb2QuXG5cdCAgICAgICAgICBub3RlIHRoYXQgY2FsbGJhY2tzIG9yZGVyIHdvbid0IGZsaXAgYXQgbGVhc3Rcblx0ICAgICAgICAgIGZvciBub3cgKHVuZGVyIGNvbnNpZGVyYXRpb24pLiAqL1xuXHQgICAgICBpc1lveW86IGZhbHNlLFxuXHQgICAgICAvKiBlYXNpbmcgZm9yIHRoZSB0d2VlbiwgY291bGQgYmUgYW55IGVhc2luZyB0eXBlIFtsaW5rIHRvIGVhc2luZy10eXBlcy5tZF0gKi9cblx0ICAgICAgZWFzaW5nOiAnU2luLk91dCcsXG5cdCAgICAgIC8qXG5cdCAgICAgICAgRWFzaW5nIGZvciBiYWNrd2FyZCBkaXJlY3Rpb24gb2YgdGhlIHR3ZWVudGhlIHR3ZWVuLFxuXHQgICAgICAgIGlmIGBudWxsYCAtIGZhbGxiYWNrcyB0byBgZWFzaW5nYCBwcm9wZXJ0eS5cblx0ICAgICAgICBmb3J3YXJkIGRpcmVjdGlvbiBpbiBgeW95b2AgcGVyaW9kIGlzIHRyZWF0ZWQgYXMgYmFja3dhcmQgZm9yIHRoZSBlYXNpbmcuXG5cdCAgICAgICovXG5cdCAgICAgIGJhY2t3YXJkRWFzaW5nOiBudWxsLFxuXHQgICAgICAvKiBjdXN0b20gdHdlZW4ncyBuYW1lICovXG5cdCAgICAgIG5hbWU6IG51bGwsXG5cdCAgICAgIC8qIGN1c3RvbSB0d2VlbidzIGJhc2UgbmFtZSAqL1xuXHQgICAgICBuYW1lQmFzZTogJ1R3ZWVuJyxcblx0ICAgICAgLypcblx0ICAgICAgICBvblByb2dyZXNzIGNhbGxiYWNrIHJ1bnMgYmVmb3JlIGFueSBvdGhlciBjYWxsYmFjay5cblx0ICAgICAgICBAcGFyYW0ge051bWJlcn0gICBUaGUgZW50aXJlLCBub3QgZWFzZWQsIHByb2dyZXNzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHR3ZWVuIHJlZ2FyZGluZyByZXBlYXQgb3B0aW9uLlxuXHQgICAgICAgIEBwYXJhbSB7Qm9vbGVhbn0gIFRoZSBkaXJlY3Rpb24gb2YgdGhlIHR3ZWVuLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGB0cnVlYCBmb3IgZm9yd2FyZCBkaXJlY3Rpb24uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCBmb3IgYmFja3dhcmQgZGlyZWN0aW9uKHR3ZWVuIHJ1bnMgaW4gcmV2ZXJzZSkuXG5cdCAgICAgICovXG5cdCAgICAgIG9uUHJvZ3Jlc3M6IG51bGwsXG5cdCAgICAgIC8qXG5cdCAgICAgICAgb25TdGFydCBjYWxsYmFjayBydW5zIG9uIHZlcnkgc3RhcnQgb2YgdGhlIHR3ZWVuIGp1c3QgYWZ0ZXIgb25Qcm9ncmVzc1xuXHQgICAgICAgIG9uZS4gUnVucyBvbiB2ZXJ5IGVuZCBvZiB0aGUgdHdlZW4gaWYgdHdlZW4gaXMgcmV2ZXJzZWQuXG5cdCAgICAgICAgQHBhcmFtIHtCb29sZWFufSAgRGlyZWN0aW9uIG9mIHRoZSB0d2Vlbi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBgdHJ1ZWAgZm9yIGZvcndhcmQgZGlyZWN0aW9uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWAgZm9yIGJhY2t3YXJkIGRpcmVjdGlvbih0d2VlbiBydW5zIGluIHJldmVyc2UpLlxuXHQgICAgICAqL1xuXHQgICAgICBvblN0YXJ0OiBudWxsLFxuXHQgICAgICBvblJlZnJlc2g6IG51bGwsXG5cdCAgICAgIG9uQ29tcGxldGU6IG51bGwsXG5cdCAgICAgIG9uUmVwZWF0U3RhcnQ6IG51bGwsXG5cdCAgICAgIG9uUmVwZWF0Q29tcGxldGU6IG51bGwsXG5cdCAgICAgIG9uRmlyc3RVcGRhdGU6IG51bGwsXG5cdCAgICAgIG9uVXBkYXRlOiBudWxsLFxuXHQgICAgICBpc0NoYWluZWQ6IGZhbHNlLFxuXHQgICAgICAvLyBwbGF5YmFjayBjYWxsYmFja3Ncblx0ICAgICAgb25QbGF5YmFja1N0YXJ0OiBudWxsLFxuXHQgICAgICBvblBsYXliYWNrUGF1c2U6IG51bGwsXG5cdCAgICAgIG9uUGxheWJhY2tTdG9wOiBudWxsLFxuXHQgICAgICBvblBsYXliYWNrQ29tcGxldGU6IG51bGwsXG5cdCAgICAgIC8vIGNvbnRleHQgd2hpY2ggYWxsIGNhbGxiYWNrcyB3aWxsIGJlIGNhbGxlZCB3aXRoXG5cdCAgICAgIGNhbGxiYWNrc0NvbnRleHQ6IG51bGxcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBwbGF5IHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncGxheScgJiYgdGhpcy5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fcHJvcHMuaXNSZXZlcnNlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5fc3ViUGxheShzaGlmdCwgJ3BsYXknKTtcblx0ICAgIHRoaXMuX3NldFBsYXliYWNrU3RhdGUoJ3BsYXknKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcGxheSB0aGUgVHdlZW4gaW4gcmV2ZXJzZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHZhciBzaGlmdCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IDAgOiBhcmd1bWVudHNbMF07XG5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3JldmVyc2UnICYmIHRoaXMuX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblx0ICAgIHRoaXMuX3Byb3BzLmlzUmV2ZXJzZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5fc3ViUGxheShzaGlmdCwgJ3JldmVyc2UnKTtcblx0ICAgIHRoaXMuX3NldFBsYXliYWNrU3RhdGUoJ3JldmVyc2UnKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gcGF1c2UgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKCkge1xuXHQgICAgaWYgKHRoaXMuX3N0YXRlID09PSAncGF1c2UnIHx8IHRoaXMuX3N0YXRlID09PSAnc3RvcCcpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9yZW1vdmVGcm9tVHdlZW5lcigpO1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgncGF1c2UnKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gc3RvcCB0aGUgVHdlZW4uXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBQcm9ncmVzcyBbMC4uMV0gdG8gc2V0IHdoZW4gc3RvcHBlZC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKHByb2dyZXNzKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdzdG9wJykge1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gdW5kZWZpbmVkO1xuXG5cdCAgICB2YXIgc3RvcFByb2MgPSBwcm9ncmVzcyAhPSBudWxsID8gcHJvZ3Jlc3Ncblx0ICAgIC8qIGlmIG5vIHByb2dyZXNzIHBhc3NzZWQgLSBzZXQgMSBpZiB0d2VlblxuXHQgICAgICAgaXMgcGxheWluZ0JhY2t3YXJkLCBvdGhlcndpc2Ugc2V0IHRvIDAgKi9cblx0ICAgIDogdGhpcy5fc3RhdGUgPT09ICdyZXZlcnNlJyA/IDEgOiAwO1xuXG5cdCAgICB0aGlzLnNldFByb2dyZXNzKHN0b3BQcm9jKTtcblxuXHQgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byByZXBsYXkocmVzdGFydCkgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzBdO1xuXG5cdCAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICB0aGlzLnBsYXkoc2hpZnQpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byByZXBsYXkocmVzdGFydCkgYmFja3dhcmQgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICAge051bWJlcn0gU2hpZnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5yZXBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHJlcGxheUJhY2t3YXJkKCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgdGhpcy5wbGF5QmFja3dhcmQoc2hpZnQpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byByZXN1bWUgdGhlIFR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICB7TnVtYmVyfSBTaGlmdCB0aW1lIGluIG1pbGxpc2Vjb25kcy5cblx0ICAgIEByZXR1cm4ge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgaWYgKHRoaXMuX3N0YXRlICE9PSAncGF1c2UnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBzd2l0Y2ggKHRoaXMuX3ByZXZTdGF0ZSkge1xuXHQgICAgICBjYXNlICdwbGF5Jzpcblx0ICAgICAgICB0aGlzLnBsYXkoc2hpZnQpO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBjYXNlICdyZXZlcnNlJzpcblx0ICAgICAgICB0aGlzLnBsYXlCYWNrd2FyZChzaGlmdCk7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gc2V0IHByb2dyZXNzIG9uIHR3ZWVuLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnNldFByb2dyZXNzID0gZnVuY3Rpb24gc2V0UHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBzZXQgc3RhcnQgdGltZSBpZiB0aGVyZSBpcyBubyBvbmUgeWV0LlxuXHQgICAgIXAuc3RhcnRUaW1lICYmIHRoaXMuX3NldFN0YXJ0VGltZSgpO1xuXHQgICAgLy8gcmVzZXQgcGxheSB0aW1lXG5cdCAgICB0aGlzLl9wbGF5VGltZSA9IG51bGw7XG5cdCAgICAvLyBwcm9ncmVzcyBzaG91bGQgYmUgaW4gcmFuZ2Ugb2YgWzAuLjFdXG5cdCAgICBwcm9ncmVzcyA8IDAgJiYgKHByb2dyZXNzID0gMCk7XG5cdCAgICBwcm9ncmVzcyA+IDEgJiYgKHByb2dyZXNzID0gMSk7XG5cdCAgICAvLyB1cGRhdGUgc2VsZiB3aXRoIGNhbGN1bGF0ZWQgdGltZVxuXHQgICAgdGhpcy5fdXBkYXRlKHAuc3RhcnRUaW1lIC0gcC5kZWxheSArIHByb2dyZXNzICogcC5yZXBlYXRUaW1lKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgdHdlZW4ncyBzcGVlZC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBTcGVlZCB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24gc2V0U3BlZWQoc3BlZWQpIHtcblx0ICAgIHRoaXMuX3Byb3BzLnNwZWVkID0gc3BlZWQ7XG5cdCAgICAvLyBpZiBwbGF5aW5nIC0gbm9ybWFsaXplIF9zdGFydFRpbWUgYW5kIF9wcmV2VGltZSB0byB0aGUgY3VycmVudCBwb2ludC5cblx0ICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gJ3BsYXknIHx8IHRoaXMuX3N0YXRlID09PSAncmV2ZXJzZScpIHtcblx0ICAgICAgdGhpcy5fc2V0UmVzdW1lVGltZSh0aGlzLl9zdGF0ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgdHdlZW4ncyBzdGF0ZSBhbmQgcHJvcGVydGllcy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICB0aGlzLl9yZW1vdmVGcm9tVHdlZW5lcigpO1xuXHQgICAgdGhpcy5fc2V0UGxheWJhY2tTdGF0ZSgnc3RvcCcpO1xuXHQgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gMDtcblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSBmYWxzZTtcblx0ICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IHVuZGVmaW5lZDtcblx0ICAgIHRoaXMuX3ByZXZUaW1lID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fcHJldllveW8gPSB1bmRlZmluZWQ7XG5cdCAgICAvLyB0aGlzLl9wcm9wcy5zdGFydFRpbWUgID0gdW5kZWZpbmVkO1xuXHQgICAgdGhpcy5fcHJvcHMuaXNSZXZlcnNlZCA9IGZhbHNlO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsYXVuY2ggcGxheS4gVXNlZCBhcyBsYXVuY2hcblx0ICAgIG1ldGhvZCBmb3IgYm90aHBsYXkgYW5kIHJldmVyc2UgbWV0aG9kcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gIHtOdW1iZXJ9IFNoaWZ0IHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuXHQgICAgQHBhcmFtICB7U3RyaW5nfSBQbGF5IG9yIHJldmVyc2Ugc3RhdGUuXG5cdCAgICBAcmV0dXJuIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zdWJQbGF5ID0gZnVuY3Rpb24gX3N1YlBsYXkoKSB7XG5cdCAgICB2YXIgc2hpZnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAwIDogYXJndW1lbnRzWzBdO1xuXHQgICAgdmFyIHN0YXRlID0gYXJndW1lbnRzWzFdO1xuXG5cdCAgICB2YXIgcmVzdW1lVGltZSxcblx0ICAgICAgICBzdGFydFRpbWUsXG5cdCAgICAgICAgcCA9IHRoaXMuX3Byb3BzLFxuXG5cdCAgICAvLyBjaGVjayBpZiBkaXJlY3Rpb24gb2YgcGxheWJhY2sgY2hhbmdlcyxcblx0ICAgIC8vIGlmIHNvLCB0aGUgX3Byb2dyZXNzVGltZSBuZWVkcyB0byBiZSBmbGlwcGVkXG5cdCAgICBfc3RhdGUgPSB0aGlzLl9zdGF0ZSxcblx0ICAgICAgICBfcHJldlN0YXRlID0gdGhpcy5fcHJldlN0YXRlLFxuXHQgICAgICAgIGlzUGF1c2UgPSBfc3RhdGUgPT09ICdwYXVzZScsXG5cdCAgICAgICAgd2FzUGxheSA9IF9zdGF0ZSA9PT0gJ3BsYXknIHx8IGlzUGF1c2UgJiYgX3ByZXZTdGF0ZSA9PT0gJ3BsYXknLFxuXHQgICAgICAgIHdhc1JldmVyc2UgPSBfc3RhdGUgPT09ICdyZXZlcnNlJyB8fCBpc1BhdXNlICYmIF9wcmV2U3RhdGUgPT09ICdyZXZlcnNlJyxcblx0ICAgICAgICBpc0ZsaXAgPSB3YXNQbGF5ICYmIHN0YXRlID09PSAncmV2ZXJzZScgfHwgd2FzUmV2ZXJzZSAmJiBzdGF0ZSA9PT0gJ3BsYXknO1xuXG5cdCAgICAvLyBpZiB0d2VlbiB3YXMgZW5kZWQsIHNldCBwcm9ncmVzcyB0byAwIGlmIG5vdCwgc2V0IHRvIGVsYXBzZWQgcHJvZ3Jlc3Ncblx0ICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IHRoaXMuX3Byb2dyZXNzVGltZSA+PSBwLnJlcGVhdFRpbWUgPyAwIDogdGhpcy5fcHJvZ3Jlc3NUaW1lO1xuXHQgICAgLy8gZmxpcCB0aGUgX3Byb2dyZXNzVGltZSBpZiBwbGF5YmFjayBkaXJlY3Rpb24gY2hhbmdlZFxuXHQgICAgaWYgKGlzRmxpcCkge1xuXHQgICAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSBwLnJlcGVhdFRpbWUgLSB0aGlzLl9wcm9ncmVzc1RpbWU7XG5cdCAgICB9XG5cdCAgICAvLyBzZXQgcmVzdW1lIHRpbWUgYW5kIG5vcm1hbGl6ZSBwcmV2L3N0YXJ0IHRpbWVzXG5cdCAgICB0aGlzLl9zZXRSZXN1bWVUaW1lKHN0YXRlLCBzaGlmdCk7XG5cdCAgICAvLyBhZGQgc2VsZiB0byB0d2VlbmVyID0gcGxheVxuXHQgICAgX3R3ZWVuZXIyLmRlZmF1bHQuYWRkKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBfcmVzdW1lVGltZSwgX3N0YXJ0VGltZSBhbmQgX3ByZXZUaW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBDdXJyZW50IHN0YXRlLiBbcGxheSwgcmV2ZXJzZV1cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBUaW1lIHNoaWZ0LiAqRGVmYXVsdCogaXMgMC5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3NldFJlc3VtZVRpbWUgPSBmdW5jdGlvbiBfc2V0UmVzdW1lVGltZShzdGF0ZSkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1sxXTtcblxuXHQgICAgLy8gZ2V0IGN1cnJlbnQgbW9tZW50IGFzIHJlc3VtZSB0aW1lXG5cdCAgICB0aGlzLl9yZXN1bWVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdCAgICAvLyBzZXQgc3RhcnQgdGltZSByZWdhcmRpbmcgcGFzc2VkIGBzaGlmdGAgYW5kIGBwcm9jVGltZWBcblx0ICAgIHZhciBzdGFydFRpbWUgPSB0aGlzLl9yZXN1bWVUaW1lIC0gTWF0aC5hYnMoc2hpZnQpIC0gdGhpcy5fcHJvZ3Jlc3NUaW1lO1xuXHQgICAgdGhpcy5fc2V0U3RhcnRUaW1lKHN0YXJ0VGltZSwgZmFsc2UpO1xuXHQgICAgLy8gaWYgd2UgaGF2ZSBwcmV2VGltZSAtIHdlIG5lZWQgdG8gbm9ybWFsaXplXG5cdCAgICAvLyBpdCBmb3IgdGhlIGN1cnJlbnQgcmVzdW1lIHRpbWVcblx0ICAgIGlmICh0aGlzLl9wcmV2VGltZSAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuX3ByZXZUaW1lID0gc3RhdGUgPT09ICdwbGF5JyA/IHRoaXMuX25vcm1QcmV2VGltZUZvcndhcmQoKSA6IHRoaXMuX3Byb3BzLmVuZFRpbWUgLSB0aGlzLl9wcm9ncmVzc1RpbWU7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHJlY2FsY3VsYXRlIF9wcmV2VGltZSBmb3IgZm9yd2FyZCBkaXJlY3Rpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybiB7TnVtYmVyfSBOb3JtYWxpemVkIHByZXYgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX25vcm1QcmV2VGltZUZvcndhcmQgPSBmdW5jdGlvbiBfbm9ybVByZXZUaW1lRm9yd2FyZCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByZXR1cm4gcC5zdGFydFRpbWUgKyB0aGlzLl9wcm9ncmVzc1RpbWUgLSBwLmRlbGF5O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIENvbnN0cnVjdG9yIG9mIHRoZSBjbGFzcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgZnVuY3Rpb24gVHdlZW4oKSB7XG5cdCAgICB2YXIgX3JldDtcblxuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR3ZWVuKTtcblxuXHQgICAgdmFyIF90aGlzID0gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KSh0aGlzLCBfTW9kdWxlLmNhbGwodGhpcywgbykpO1xuXG5cdCAgICBfdGhpcy5fcHJvcHMubmFtZSA9PSBudWxsICYmIF90aGlzLl9zZXRTZWxmTmFtZSgpO1xuXHQgICAgcmV0dXJuIF9yZXQgPSBfdGhpcywgKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMy5kZWZhdWx0KShfdGhpcywgX3JldCk7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHNlbGYgbmFtZSB0byBnZW5lcmljIG9uZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRTZWxmTmFtZSA9IGZ1bmN0aW9uIF9zZXRTZWxmTmFtZSgpIHtcblx0ICAgIHZhciBnbG9iYWxOYW1lID0gJ18nICsgdGhpcy5fcHJvcHMubmFtZUJhc2UgKyAncyc7XG5cdCAgICAvLyB0cmFjayBhbW91bnQgb2YgdHdlZW5zIGdsb2JhbGx5XG5cdCAgICBfdHdlZW5lcjIuZGVmYXVsdFtnbG9iYWxOYW1lXSA9IF90d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdID09IG51bGwgPyAxIDogKytfdHdlZW5lcjIuZGVmYXVsdFtnbG9iYWxOYW1lXTtcblx0ICAgIC8vIGFuZCBzZXQgZ2VuZXJpYyB0d2VlbidzIG5hbWUgIHx8IFR3ZWVuICMgfHxcblx0ICAgIHRoaXMuX3Byb3BzLm5hbWUgPSB0aGlzLl9wcm9wcy5uYW1lQmFzZSArICcgJyArIF90d2VlbmVyMi5kZWZhdWx0W2dsb2JhbE5hbWVdO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzZXQgcGxheWJhY2sgc3RhdGUgc3RyaW5nLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBTdGF0ZSBuYW1lXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRQbGF5YmFja1N0YXRlID0gZnVuY3Rpb24gX3NldFBsYXliYWNrU3RhdGUoc3RhdGUpIHtcblx0ICAgIC8vIHNhdmUgcHJldmlvdXMgc3RhdGVcblx0ICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXHQgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcblxuXHQgICAgLy8gY2FsbGJhY2tzXG5cdCAgICB2YXIgd2FzUGF1c2UgPSB0aGlzLl9wcmV2U3RhdGUgPT09ICdwYXVzZScsXG5cdCAgICAgICAgd2FzU3RvcCA9IHRoaXMuX3ByZXZTdGF0ZSA9PT0gJ3N0b3AnLFxuXHQgICAgICAgIHdhc1BsYXkgPSB0aGlzLl9wcmV2U3RhdGUgPT09ICdwbGF5Jyxcblx0ICAgICAgICB3YXNSZXZlcnNlID0gdGhpcy5fcHJldlN0YXRlID09PSAncmV2ZXJzZScsXG5cdCAgICAgICAgd2FzUGxheWluZyA9IHdhc1BsYXkgfHwgd2FzUmV2ZXJzZSxcblx0ICAgICAgICB3YXNTdGlsbCA9IHdhc1N0b3AgfHwgd2FzUGF1c2U7XG5cblx0ICAgIGlmICgoc3RhdGUgPT09ICdwbGF5JyB8fCBzdGF0ZSA9PT0gJ3JldmVyc2UnKSAmJiB3YXNTdGlsbCkge1xuXHQgICAgICB0aGlzLl9wbGF5YmFja1N0YXJ0KCk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3RhdGUgPT09ICdwYXVzZScgJiYgd2FzUGxheWluZykge1xuXHQgICAgICB0aGlzLl9wbGF5YmFja1BhdXNlKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoc3RhdGUgPT09ICdzdG9wJyAmJiAod2FzUGxheWluZyB8fCB3YXNQYXVzZSkpIHtcblx0ICAgICAgdGhpcy5fcGxheWJhY2tTdG9wKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgc29tZSB2YXJzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMucHJvZ3Jlc3MgPSAwO1xuXHQgICAgdGhpcy5fcHJldlRpbWUgPSB1bmRlZmluZWQ7XG5cdCAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSAwO1xuXHQgICAgdGhpcy5fbmVnYXRpdmVTaGlmdCA9IDA7XG5cdCAgICB0aGlzLl9zdGF0ZSA9ICdzdG9wJztcblx0ICAgIC8vIGlmIG5lZ2F0aXZlIGRlbGF5IHdhcyBzcGVjaWZpZWQsXG5cdCAgICAvLyBzYXZlIGl0IHRvIF9uZWdhdGl2ZVNoaWZ0IHByb3BlcnR5IGFuZFxuXHQgICAgLy8gcmVzZXQgaXQgYmFjayB0byAwXG5cdCAgICBpZiAodGhpcy5fcHJvcHMuZGVsYXkgPCAwKSB7XG5cdCAgICAgIHRoaXMuX25lZ2F0aXZlU2hpZnQgPSB0aGlzLl9wcm9wcy5kZWxheTtcblx0ICAgICAgdGhpcy5fcHJvcHMuZGVsYXkgPSAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5fY2FsY0RpbWVudGlvbnMoKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsY3VsYXRlIHR3ZWVuJ3MgZGltZW50aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9jYWxjRGltZW50aW9ucyA9IGZ1bmN0aW9uIF9jYWxjRGltZW50aW9ucygpIHtcblx0ICAgIHRoaXMuX3Byb3BzLnRpbWUgPSB0aGlzLl9wcm9wcy5kdXJhdGlvbiArIHRoaXMuX3Byb3BzLmRlbGF5O1xuXHQgICAgdGhpcy5fcHJvcHMucmVwZWF0VGltZSA9IHRoaXMuX3Byb3BzLnRpbWUgKiAodGhpcy5fcHJvcHMucmVwZWF0ICsgMSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGV4dGVuZCBkZWZhdWx0cyBieSBvcHRpb25zIGFuZCBwdXQgdGhlbSBpbiBfcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMgPSBmdW5jdGlvbiBfZXh0ZW5kRGVmYXVsdHMoKSB7XG5cdCAgICAvLyBzYXZlIGNhbGxiYWNrIG92ZXJyaWRlcyBvYmplY3Qgd2l0aCBmYWxsYmFjayB0byBlbXB0eSBvbmVcblx0ICAgIHRoaXMuX2NhbGxiYWNrT3ZlcnJpZGVzID0gdGhpcy5fby5jYWxsYmFja092ZXJyaWRlcyB8fCB7fTtcblx0ICAgIGRlbGV0ZSB0aGlzLl9vLmNhbGxiYWNrT3ZlcnJpZGVzO1xuXHQgICAgLy8gY2FsbCB0aGUgX2V4dGVuZERlZmF1bHRzIEAgTW9kdWxlXG5cdCAgICBfTW9kdWxlLnByb3RvdHlwZS5fZXh0ZW5kRGVmYXVsdHMuY2FsbCh0aGlzKTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHAuZWFzaW5nID0gX2Vhc2luZzIuZGVmYXVsdC5wYXJzZUVhc2luZyhwLmVhc2luZyk7XG5cdCAgICBwLmVhc2luZy5fcGFyZW50ID0gdGhpcztcblxuXHQgICAgLy8gcGFyc2Ugb25seSBwcmVzZW50IGJhY2t3YXJkIGVhc2luZyB0byBwcmV2ZW50IHBhcnNpbmcgYXMgYGxpbmVhci5ub25lYFxuXHQgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGZhbGxiYWNrIHRvIGBlYXNpbmdgIGluIGBfc2V0UHJvZ3Jlc3NgIG1ldGhvZFxuXHQgICAgaWYgKHAuYmFja3dhcmRFYXNpbmcgIT0gbnVsbCkge1xuXHQgICAgICBwLmJhY2t3YXJkRWFzaW5nID0gX2Vhc2luZzIuZGVmYXVsdC5wYXJzZUVhc2luZyhwLmJhY2t3YXJkRWFzaW5nKTtcblx0ICAgICAgcC5iYWNrd2FyZEVhc2luZy5fcGFyZW50ID0gdGhpcztcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIHNldHRpbmcgc3RhcnQgYW5kIGVuZCB0aW1lIHRvIHByb3BzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyKFRpbWVzdGFtcCl9LCB7TnVsbH0gU3RhcnQgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gU2hvdWxkIHJlc2V0IGZsYWdzLlxuXHQgICAgQHJldHVybnMgdGhpc1xuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fc2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gX3NldFN0YXJ0VGltZSh0aW1lKSB7XG5cdCAgICB2YXIgaXNSZXNldEZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBzaGlmdFRpbWUgPSBwLnNoaWZ0VGltZSB8fCAwO1xuXHQgICAgLy8gcmVzZXQgZmxhZ3Ncblx0ICAgIGlmIChpc1Jlc2V0RmxhZ3MpIHtcblx0ICAgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTt0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIH1cblx0ICAgIC8vIHNldCBzdGFydCB0aW1lIHRvIHBhc3NlZCB0aW1lIG9yIHRvIHRoZSBjdXJyZW50IG1vbWVudFxuXHQgICAgdmFyIHN0YXJ0VGltZSA9IHRpbWUgPT0gbnVsbCA/IHBlcmZvcm1hbmNlLm5vdygpIDogdGltZTtcblx0ICAgIC8vIGNhbGN1bGF0ZSBib3VuZHNcblx0ICAgIC8vIC0gbmVnYXRpdmVTaGlmdCBpcyBuZWdhdGl2ZSBkZWxheSBpbiBvcHRpb25zIGhhc2hcblx0ICAgIC8vIC0gc2hpZnQgdGltZSBpcyBzaGlmdCBvZiB0aGUgcGFyZW50XG5cdCAgICBwLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSArIHAuZGVsYXkgKyB0aGlzLl9uZWdhdGl2ZVNoaWZ0ICsgc2hpZnRUaW1lO1xuXHQgICAgcC5lbmRUaW1lID0gcC5zdGFydFRpbWUgKyBwLnJlcGVhdFRpbWUgLSBwLmRlbGF5O1xuXHQgICAgLy8gc2V0IHBsYXkgdGltZSB0byB0aGUgc3RhcnRUaW1lc1xuXHQgICAgLy8gaWYgcGxheWJhY2sgY29udHJvbHMgYXJlIHVzZWQgLSB1c2UgX3Jlc3VtZVRpbWUgYXMgcGxheSB0aW1lLFxuXHQgICAgLy8gZWxzZSB1c2Ugc2hpZnRlZCBzdGFydFRpbWUgLS0gc2hpZnQgaXMgbmVlZGVkIGZvciB0aW1lbGluZXMgYXBwZW5kIGNoYWluc1xuXHQgICAgdGhpcy5fcGxheVRpbWUgPSB0aGlzLl9yZXN1bWVUaW1lICE9IG51bGwgPyB0aGlzLl9yZXN1bWVUaW1lIDogc3RhcnRUaW1lICsgc2hpZnRUaW1lO1xuXHQgICAgdGhpcy5fcmVzdW1lVGltZSA9IG51bGw7XG5cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB1cGRhdGUgdHdlZW4ncyBwcm9ncmVzcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIC0tIG5leHQgcGFyYW1zIG9ubHkgcHJlc2VudCB3aGVuIHBhcmVudCBUaW1lbGluZSBjYWxscyB0aGUgbWV0aG9kLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByZXZpb3VzIFRpbWVsaW5lJ3MgdXBkYXRlIHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IFdhcyBwYXJlbnQgaW4geW95byBwZXJpb2QuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gWy0xLCAwLCAxXSBJZiB1cGRhdGUgaXMgb24gZWRnZS5cblx0ICAgICAgICAgICAgICAgICAgIC0xID0gZWRnZSBqdW1wIGluIG5lZ2F0aXZlIGRpcmVjdGlvbi5cblx0ICAgICAgICAgICAgICAgICAgICAwID0gbm8gZWRnZSBqdW1wLlxuXHQgICAgICAgICAgICAgICAgICAgIDEgPSBlZGdlIGp1bXAgaW4gcG9zaXRpdmUgZGlyZWN0aW9uLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZSh0aW1lLCB0aW1lbGluZVByZXZUaW1lLCB3YXNZb3lvLCBvbkVkZ2UpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBpZiB3ZSBkb24ndCB0aGUgX3ByZXZUaW1lIHRodXMgdGhlIGRpcmVjdGlvbiB3ZSBhcmUgaGVhZGluZyB0byxcblx0ICAgIC8vIGJ1dCBwcmV2VGltZSB3YXMgcGFzc2VkIHRodXMgd2UgYXJlIGNoaWxkIG9mIGEgVGltZWxpbmVcblx0ICAgIC8vIHNldCBfcHJldlRpbWUgdG8gcGFzc2VkIG9uZSBhbmQgcHJldGVudCB0aGF0IHRoZXJlIHdhcyB1bmtub3duXG5cdCAgICAvLyB1cGRhdGUgdG8gbm90IHRvIGJsb2NrIHN0YXJ0L2NvbXBsZXRlIGNhbGxiYWNrc1xuXHQgICAgaWYgKHRoaXMuX3ByZXZUaW1lID09IG51bGwgJiYgdGltZWxpbmVQcmV2VGltZSAhPSBudWxsKSB7XG5cblx0ICAgICAgaWYgKHRoaXMuX3Byb3BzLnNwZWVkICYmIHRoaXMuX3BsYXlUaW1lKSB7XG5cdCAgICAgICAgLy8gcGxheSBwb2ludCArICggc3BlZWQgKiBkZWx0YSApXG5cdCAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aGlzLl9wbGF5VGltZSArIHRoaXMuX3Byb3BzLnNwZWVkICogKHRpbWVsaW5lUHJldlRpbWUgLSB0aGlzLl9wbGF5VGltZSk7XG5cdCAgICAgIH1cblx0ICAgICAgLy8gdGhpcy5fcHJldlRpbWUgPSB0aW1lbGluZVByZXZUaW1lO1xuXHQgICAgICB0aGlzLl93YXNVa25vd25VcGRhdGUgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyB2YXIgYmVmb3JlID0gdGltZTtcblx0ICAgIC8vIGNhY2hlIHZhcnNcblx0ICAgIHZhciBzdGFydFBvaW50ID0gcC5zdGFydFRpbWUgLSBwLmRlbGF5O1xuXHQgICAgLy8gaWYgc3BlZWQgcGFyYW0gd2FzIGRlZmluZWQgLSBjYWxjdWxhdGVcblx0ICAgIC8vIG5ldyB0aW1lIHJlZ2FyZGluZyBzcGVlZFxuXHQgICAgaWYgKHAuc3BlZWQgJiYgdGhpcy5fcGxheVRpbWUpIHtcblx0ICAgICAgLy8gcGxheSBwb2ludCArICggc3BlZWQgKiBkZWx0YSApXG5cdCAgICAgIHRpbWUgPSB0aGlzLl9wbGF5VGltZSArIHAuc3BlZWQgKiAodGltZSAtIHRoaXMuX3BsYXlUaW1lKTtcblx0ICAgIH1cblxuXHQgICAgLy8gZHVlIHRvIGphdmFzY3JpcHQgcHJlY2lzaW9uIGlzc3VlcywgYWZ0ZXIgc3BlZWQgbWFwcGluZ1xuXHQgICAgLy8gd2UgY2FuIGdldCB2ZXJ5IGNsb3NlIG51bWJlciB0aGF0IHdhcyBtYWRlIGZyb20gcHJvZ3Jlc3Mgb2YgMVxuXHQgICAgLy8gYW5kIGluIGZhY3QgcmVwcmVzZW50cyBgZW5kVGltZWAgaWYgc28sIHNldCB0aGUgdGltZSB0byBgZW5kVGltZWBcblx0ICAgIGlmIChNYXRoLmFicyhwLmVuZFRpbWUgLSB0aW1lKSA8IDAuMDAwMDAwMDEpIHtcblx0ICAgICAgdGltZSA9IHAuZW5kVGltZTtcblx0ICAgIH1cblxuXHQgICAgLy8gaWYgcGFyZW50IGlzIG9uRWRnZSBidXQgbm90IHZlcnkgc3RhcnQgbm9yIHZlcnkgZW5kXG5cdCAgICBpZiAob25FZGdlICYmIHdhc1lveW8gIT0gbnVsbCkge1xuXHQgICAgICB2YXIgVCA9IHRoaXMuX2dldFBlcmlvZCh0aW1lKSxcblx0ICAgICAgICAgIGlzWW95byA9ICEhKHAuaXNZb3lvICYmIHRoaXMuX3Byb3BzLnJlcGVhdCAmJiBUICUgMiA9PT0gMSk7XG5cblx0ICAgICAgLy8gZm9yIHRpbWVsaW5lXG5cdCAgICAgIC8vIG5vdGlmeSBjaGlsZHJlbiBhYm91dCBlZGdlIGp1bXBcblx0ICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lcykge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGltZWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICB0aGlzLl90aW1lbGluZXNbaV0uX3VwZGF0ZSh0aW1lLCB0aW1lbGluZVByZXZUaW1lLCB3YXNZb3lvLCBvbkVkZ2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBmb3J3YXJkIGVkZ2UgZGlyZWN0aW9uXG5cdCAgICAgIGlmIChvbkVkZ2UgPT09IDEpIHtcblx0ICAgICAgICAvLyBqdW1wZWQgZnJvbSB5b3lvIHBlcmlvZD9cblx0ICAgICAgICBpZiAod2FzWW95bykge1xuXHQgICAgICAgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lICsgMTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB0aGlzLl9wcmV2VGltZSA9IHRpbWUgLSAxO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGJhY2t3YXJkIGVkZ2UgZGlyZWN0aW9uXG5cdCAgICAgIH0gZWxzZSBpZiAob25FZGdlID09PSAtMSkge1xuXHQgICAgICAgICAgLy8ganVtcGVkIGZyb20geW95byBwZXJpb2Q/XG5cdCAgICAgICAgICBpZiAod2FzWW95bykge1xuXHQgICAgICAgICAgICB0aGlzLl9wcmV2VGltZSA9IHRpbWUgLSAxO1xuXHQgICAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gY2FsbCBfc3RhcnQgY2FsbGJhY2tzIG9ubHkgaWYgcHJldiB0aW1lIHdhcyBpbiBhY3RpdmUgYXJlYVxuXHQgICAgICAgICAgICAvLyBub3QgYWx3YXlzIHRydWUgZm9yIGFwcGVuZCBjaGFpbnNcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZUaW1lID49IHAuc3RhcnRUaW1lICYmIHRoaXMuX3ByZXZUaW1lIDw9IHAuZW5kVGltZSkge1xuXHQgICAgICAgICAgICAgIHRoaXMuX3ByZXZUaW1lID0gdGltZSArIDE7XG5cdCAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgICAgIC8vIHJlc2V0IGlzQ09tcGxldGVkIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgb25Db21wbGV0ZSBjYlxuXHQgICAgICAgICAgICAgIHRoaXMuX2lzQ29tcGxldGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgLy8gcmVzZXQgdGhlIF9wcmV2VGltZSAtIGRyb3Agb25lIGZyYW1lIHRvIHVuZGVzdGFuZFxuXHQgICAgICAvLyB3aGVyZSB3ZSBhcmUgaGVhZGluZ1xuXHQgICAgICB0aGlzLl9wcmV2VGltZSA9IHVuZGVmaW5lZDtcblx0ICAgIH1cblx0ICAgIC8vIGlmIGluIGFjdGl2ZSBhcmVhIGFuZCBub3QgZW5kZWQgLSBzYXZlIHByb2dyZXNzIHRpbWVcblx0ICAgIC8vIGZvciBwYXVzZS9wbGF5IHB1cnBvc2VzLlxuXHQgICAgaWYgKHRpbWUgPiBzdGFydFBvaW50ICYmIHRpbWUgPCBwLmVuZFRpbWUpIHtcblx0ICAgICAgdGhpcy5fcHJvZ3Jlc3NUaW1lID0gdGltZSAtIHN0YXJ0UG9pbnQ7XG5cdCAgICB9XG5cdCAgICAvLyBlbHNlIGlmIG5vdCBzdGFydGVkIG9yIGVuZGVkIHNldCBwcm9ncmVzcyB0aW1lIHRvIDBcblx0ICAgIGVsc2UgaWYgKHRpbWUgPD0gc3RhcnRQb2ludCkge1xuXHQgICAgICAgIHRoaXMuX3Byb2dyZXNzVGltZSA9IDA7XG5cdCAgICAgIH0gZWxzZSBpZiAodGltZSA+PSBwLmVuZFRpbWUpIHtcblx0ICAgICAgICAvLyBzZXQgcHJvZ3Jlc3MgdGltZSB0byByZXBlYXQgdGltZSArIHRpbnkgY29mZmljaWVudFxuXHQgICAgICAgIC8vIHRvIG1ha2UgaXQgZXh0ZW5kIGZ1cnRoZXIgdGhhbiB0aGUgZW5kIHRpbWVcblx0ICAgICAgICB0aGlzLl9wcm9ncmVzc1RpbWUgPSBwLnJlcGVhdFRpbWUgKyAuMDAwMDAwMDAwMDE7XG5cdCAgICAgIH1cblx0ICAgIC8vIHJldmVyc2UgdGltZSBpZiBfcHJvcHMuaXNSZXZlcnNlZCBpcyBzZXRcblx0ICAgIGlmIChwLmlzUmV2ZXJzZWQpIHtcblx0ICAgICAgdGltZSA9IHAuZW5kVGltZSAtIHRoaXMuX3Byb2dyZXNzVGltZTtcblx0ICAgIH1cblx0ICAgIC8vIFdlIG5lZWQgdG8ga25vdyB3aGF0IGRpcmVjdGlvbiB3ZSBhcmUgaGVhZGluZyB0byxcblx0ICAgIC8vIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhlIHByZXZpb3VzIHVwZGF0ZSB2YWx1ZSAtIHRoaXMgaXMgdmVyeSBmaXJzdFxuXHQgICAgLy8gdXBkYXRlLCAtIHNraXAgaXQgZW50aXJlbHkgYW5kIHdhaXQgZm9yIHRoZSBuZXh0IHZhbHVlXG5cdCAgICBpZiAodGhpcy5fcHJldlRpbWUgPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9wcmV2VGltZSA9IHRpbWU7XG5cdCAgICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IHRydWU7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgLy8gPT09PT09IEFGVEVSIFNLSVBQRUQgRlJBTUUgPT09PT09XG5cblx0ICAgIC8vIGhhbmRsZSBvblByb2dyZXNzIGNhbGxiYWNrXG5cdCAgICBpZiAodGltZSA+PSBzdGFydFBvaW50ICYmIHRpbWUgPD0gcC5lbmRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX3Byb2dyZXNzKCh0aW1lIC0gc3RhcnRQb2ludCkgLyBwLnJlcGVhdFRpbWUsIHRpbWUpO1xuXHQgICAgfVxuXHQgICAgLypcblx0ICAgICAgaWYgdGltZSBpcyBpbnNpZGUgdGhlIGFjdGl2ZSBhcmVhIG9mIHRoZSB0d2Vlbi5cblx0ICAgICAgYWN0aXZlIGFyZWEgaXMgdGhlIGFyZWEgZnJvbSBzdGFydCB0aW1lIHRvIGVuZCB0aW1lLFxuXHQgICAgICB3aXRoIGFsbCB0aGUgcmVwZWF0IGFuZCBkZWxheXMgaW4gaXRcblx0ICAgICovXG5cdCAgICBpZiAodGltZSA+PSBwLnN0YXJ0VGltZSAmJiB0aW1lIDw9IHAuZW5kVGltZSkge1xuXHQgICAgICB0aGlzLl91cGRhdGVJbkFjdGl2ZUFyZWEodGltZSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBpZiB3YXMgaW4gYWN0aXZlIGFyZWEgLSB1cGRhdGUgaW4gaW5hY3RpdmUgYXJlYSBidXQganVzdCBvbmNlIC1cblx0ICAgICAgLy8gcmlnaHQgYWZ0ZXIgdGhlIGFjdGl2ZSBhcmVhXG5cdCAgICAgIGlmICh0aGlzLl9pc0luQWN0aXZlQXJlYSkge1xuXHQgICAgICAgIHRoaXMuX3VwZGF0ZUluSW5hY3RpdmVBcmVhKHRpbWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1JlZnJlc2hlZCkge1xuXHQgICAgICAgIC8vIG9uUmVmcmVzaCBjYWxsYmFja1xuXHQgICAgICAgIC8vIGJlZm9yZSBzdGFydFRpbWVcblx0ICAgICAgICBpZiAodGltZSA8IHAuc3RhcnRUaW1lICYmIHRoaXMucHJvZ3Jlc3MgIT09IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlZnJlc2godHJ1ZSk7XG5cdCAgICAgICAgICB0aGlzLl9pc1JlZnJlc2hlZCA9IHRydWU7XG5cdCAgICAgICAgICAvLyBhZnRlciBlbmRUaW1lXG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGVsc2UgaWYgKCB0aW1lID4gcC5lbmRUaW1lICkgeyB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcHJldlRpbWUgPSB0aW1lO1xuXHQgICAgcmV0dXJuIHRpbWUgPj0gcC5lbmRUaW1lIHx8IHRpbWUgPD0gc3RhcnRQb2ludDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaGFuZGxlIHR3ZWVuJ3MgcHJvZ3Jlc3MgaW4gaW5hY3RpdmUgYXJlYS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3VwZGF0ZUluSW5hY3RpdmVBcmVhID0gZnVuY3Rpb24gX3VwZGF0ZUluSW5hY3RpdmVBcmVhKHRpbWUpIHtcblx0ICAgIGlmICghdGhpcy5faXNJbkFjdGl2ZUFyZWEpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIC8vIGNvbXBsZXRlIGlmIHRpbWUgaXMgbGFyZ2VyIHRoZW4gZW5kIHRpbWVcblx0ICAgIGlmICh0aW1lID4gcC5lbmRUaW1lICYmICF0aGlzLl9pc0NvbXBsZXRlZCkge1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcygxLCB0aW1lKTtcblx0ICAgICAgLy8gZ2V0IHBlcmlvZCBudW1iZXJcblx0ICAgICAgdmFyIFQgPSB0aGlzLl9nZXRQZXJpb2QocC5lbmRUaW1lKSxcblx0ICAgICAgICAgIGlzWW95byA9IHAuaXNZb3lvICYmIFQgJSAyID09PSAwO1xuXG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKGlzWW95byA/IDAgOiAxLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgLy8gaWYgd2FzIGFjdGl2ZSBhbmQgd2VudCB0byAtIGluYWN0aXZlIGFyZWEgXCItXCJcblx0ICAgIGlmICh0aW1lIDwgdGhpcy5fcHJldlRpbWUgJiYgdGltZSA8IHAuc3RhcnRUaW1lICYmICF0aGlzLl9pc1N0YXJ0ZWQgJiYgIXRoaXMuX2lzQ29tcGxldGVkKSB7XG5cdCAgICAgIC8vIGlmIHdhcyBpbiBhY3RpdmUgYXJlYSBhbmQgZGlkbid0IGZpcmUgb25TdGFydCBjYWxsYmFja1xuXHQgICAgICB0aGlzLl9wcm9ncmVzcygwLCB0aW1lLCBmYWxzZSk7XG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKDAsIHRpbWUsIGZhbHNlKTtcblx0ICAgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBmYWxzZSk7XG5cdCAgICAgIHRoaXMuX3N0YXJ0KHRpbWUsIGZhbHNlKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzSW5BY3RpdmVBcmVhID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGhhbmRsZSB0d2VlbidzIHByb2dyZXNzIGluIGFjdGl2ZSBhcmVhLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fdXBkYXRlSW5BY3RpdmVBcmVhID0gZnVuY3Rpb24gX3VwZGF0ZUluQWN0aXZlQXJlYSh0aW1lKSB7XG5cblx0ICAgIHZhciBwcm9wcyA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGRlbGF5RHVyYXRpb24gPSBwcm9wcy5kZWxheSArIHByb3BzLmR1cmF0aW9uLFxuXHQgICAgICAgIHN0YXJ0UG9pbnQgPSBwcm9wcy5zdGFydFRpbWUgLSBwcm9wcy5kZWxheSxcblx0ICAgICAgICBlbGFwc2VkID0gKHRpbWUgLSBwcm9wcy5zdGFydFRpbWUgKyBwcm9wcy5kZWxheSkgJSBkZWxheUR1cmF0aW9uLFxuXHQgICAgICAgIFRDb3VudCA9IE1hdGgucm91bmQoKHByb3BzLmVuZFRpbWUgLSBwcm9wcy5zdGFydFRpbWUgKyBwcm9wcy5kZWxheSkgLyBkZWxheUR1cmF0aW9uKSxcblx0ICAgICAgICBUID0gdGhpcy5fZ2V0UGVyaW9kKHRpbWUpLFxuXHQgICAgICAgIFRWYWx1ZSA9IHRoaXMuX2RlbGF5VCxcblx0ICAgICAgICBwcmV2VCA9IHRoaXMuX2dldFBlcmlvZCh0aGlzLl9wcmV2VGltZSksXG5cdCAgICAgICAgVFByZXZWYWx1ZSA9IHRoaXMuX2RlbGF5VDtcblxuXHQgICAgLy8gXCJ6ZXJvXCIgYW5kIFwib25lXCIgdmFsdWUgcmVnYXJkaW5nIHlveW8gYW5kIGl0J3MgcGVyaW9kXG5cdCAgICB2YXIgaXNZb3lvID0gcHJvcHMuaXNZb3lvICYmIFQgJSAyID09PSAxLFxuXHQgICAgICAgIGlzWW95b1ByZXYgPSBwcm9wcy5pc1lveW8gJiYgcHJldlQgJSAyID09PSAxLFxuXHQgICAgICAgIHlveW9aZXJvID0gaXNZb3lvID8gMSA6IDAsXG5cdCAgICAgICAgeW95b09uZSA9IDEgLSB5b3lvWmVybztcblxuXHQgICAgaWYgKHRpbWUgPT09IHByb3BzLmVuZFRpbWUpIHtcblx0ICAgICAgdGhpcy5fd2FzVWtub3duVXBkYXRlID0gZmFsc2U7XG5cdCAgICAgIC8vIGlmIGB0aW1lYCBpcyBlcXVhbCB0byBgZW5kVGltZWAsIFQgcmVwcmVzZW50cyB0aGUgbmV4dCBwZXJpb2QsXG5cdCAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZGVjcmVtZW50IFQgYW5kIGNhbGN1bGF0ZSBcIm9uZVwiIHZhbHVlIHJlZ2FyZGluZyB5b3lvXG5cdCAgICAgIHZhciBpc1lveW8gPSBwcm9wcy5pc1lveW8gJiYgKFQgLSAxKSAlIDIgPT09IDE7XG5cdCAgICAgIHRoaXMuX3NldFByb2dyZXNzKGlzWW95byA/IDAgOiAxLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICBpZiAodGltZSA+IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgdGhpcy5faXNSZXBlYXRDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblxuXHQgICAgLy8gcmVzZXQgY2FsbGJhY2sgZmxhZ3Ncblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gZmFsc2U7XG5cdCAgICB0aGlzLl9pc1JlZnJlc2hlZCA9IGZhbHNlO1xuXHQgICAgLy8gaWYgdGltZSBpcyBpbnNpZGUgdGhlIGR1cmF0aW9uIGFyZWEgb2YgdGhlIHR3ZWVuXG5cdCAgICBpZiAoc3RhcnRQb2ludCArIGVsYXBzZWQgPj0gcHJvcHMuc3RhcnRUaW1lKSB7XG5cdCAgICAgIHRoaXMuX2lzSW5BY3RpdmVBcmVhID0gdHJ1ZTt0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICB0aGlzLl9pc1JlcGVhdFN0YXJ0ID0gZmFsc2U7dGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG5cdCAgICAgIC8vIGFjdGl2ZSB6b25lIG9yIGxhcmdlciB0aGVuIGVuZFxuXHQgICAgICB2YXIgZWxhcHNlZDIgPSAodGltZSAtIHByb3BzLnN0YXJ0VGltZSkgJSBkZWxheUR1cmF0aW9uLFxuXHQgICAgICAgICAgcHJvYyA9IGVsYXBzZWQyIC8gcHJvcHMuZHVyYXRpb247XG5cdCAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPj4+XG5cdCAgICAgIC8vICAgICAgXjFeMlxuXHQgICAgICB2YXIgaXNPbkVkZ2UgPSBUID4gMCAmJiBwcmV2VCA8IFQ7XG5cdCAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPDw8XG5cdCAgICAgIC8vICAgICAgXjJeMVxuXHQgICAgICB2YXIgaXNPblJldmVyc2VFZGdlID0gcHJldlQgPiBUO1xuXG5cdCAgICAgIC8vIGZvciB1c2UgaW4gdGltZWxpbmVcblx0ICAgICAgdGhpcy5fb25FZGdlID0gMDtcblx0ICAgICAgaXNPbkVkZ2UgJiYgKHRoaXMuX29uRWRnZSA9IDEpO1xuXHQgICAgICBpc09uUmV2ZXJzZUVkZ2UgJiYgKHRoaXMuX29uRWRnZSA9IC0xKTtcblxuXHQgICAgICBpZiAodGhpcy5fd2FzVWtub3duVXBkYXRlKSB7XG5cdCAgICAgICAgaWYgKHRpbWUgPiB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBiYWNrd2FyZCBkaXJlY3Rpb24gYW5kXG5cdCAgICAgICAgLy8gaWYgKCB0aW1lIDwgdGhpcy5fcHJldlRpbWUgJiYgdGltZSAhPT0gdGhpcy5fcHJvcHMuc3RhcnRUaW1lICkge1xuXHQgICAgICAgIGlmICh0aW1lIDwgdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIC8vIHJlc2V0IGlzQ29tcGxldGVkIGltbWVkaWF0ZWx5XG5cdCAgICAgICAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpc09uRWRnZSkge1xuXHQgICAgICAgIC8vIGlmIG5vdCBqdXN0IGFmdGVyIGRlbGF5XG5cdCAgICAgICAgLy8gfC0tLT09PT09fC0tLT09PT09fC0tLT09PT09fCA+Pj5cblx0ICAgICAgICAvLyAgICAgICAgICAgIF4xIF4yXG5cdCAgICAgICAgLy8gYmVjYXVzZSB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuXHQgICAgICAgIC8vIDEgYW5kIG9uUmVwZWF0Q29tcGxldGUgaW4gZGVsYXkgZ2FwXG5cdCAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3MgIT09IDEpIHtcblx0ICAgICAgICAgIC8vIHByZXZUXG5cdCAgICAgICAgICB2YXIgaXNUaGlzWW95byA9IHByb3BzLmlzWW95byAmJiAoVCAtIDEpICUgMiA9PT0gMTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdENvbXBsZXRlKHRpbWUsIGlzVGhpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBvbiBlZGdlIGJ1dCBub3QgYXQgdmVyeSBzdGFydFxuXHQgICAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPj4+XG5cdCAgICAgICAgLy8gXiEgICAgXmhlcmUgXmhlcmVcblx0ICAgICAgICBpZiAocHJldlQgPj0gMCkge1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGltZSA+IHRoaXMuX3ByZXZUaW1lKSB7XG5cdCAgICAgICAgLy8gIHw9PT09PXw9PT09PXw9PT09PXwgPj4+XG5cdCAgICAgICAgLy8gXjEgIF4yXG5cdCAgICAgICAgaWYgKCF0aGlzLl9pc1N0YXJ0ZWQgJiYgdGhpcy5fcHJldlRpbWUgPD0gcHJvcHMuc3RhcnRUaW1lKSB7XG5cdCAgICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0U3RhcnQodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIC8vIGl0IHdhcyB6ZXJvIGFueXdheXNcblxuXHQgICAgICAgICAgLy8gcmVzdGFydCBmbGFncyBpbW1lZGlhdGVseSBpbiBjYXNlIGlmIHdlIHdpbGxcblx0ICAgICAgICAgIC8vIHJldHVybiB0byAnLScgaW5hY3RpdmUgYXJlYSBvbiB0aGUgbmV4dCBzdGVwXG5cdCAgICAgICAgICB0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgIHRoaXMuX2lzUmVwZWF0U3RhcnQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fZmlyc3RVcGRhdGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpc09uUmV2ZXJzZUVkZ2UpIHtcblx0ICAgICAgICAvLyBpZiBvbiBlZGdlIGJ1dCBub3QgYXQgdmVyeSBlbmRcblx0ICAgICAgICAvLyB8PT09PT18PT09PT18PT09PT18IDw8PFxuXHQgICAgICAgIC8vICAgICAgIF5oZXJlIF5oZXJlIF5ub3QgaGVyZVxuXHQgICAgICAgIGlmICh0aGlzLnByb2dyZXNzICE9PSAwICYmIHRoaXMucHJvZ3Jlc3MgIT09IDEgJiYgcHJldlQgIT0gVENvdW50KSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW9QcmV2KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYgb24gdmVyeSBlbmQgZWRnZVxuXHQgICAgICAgIC8vIHw9PT09PXw9PT09PXw9PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICAgICAgXiEgICAgXiEgXjIgXjFcblx0ICAgICAgICAvLyB3ZSBoYXZlIGhhbmRsZWQgdGhlIGNhc2UgaW4gdGhpcy5fd2FzVWtub3duVXBkYXRlXG5cdCAgICAgICAgLy8gYmxvY2sgc28gZmlsdGVyIHRoYXRcblx0ICAgICAgICBpZiAocHJldlQgPT09IFRDb3VudCAmJiAhdGhpcy5fd2FzVWtub3duVXBkYXRlKSB7XG5cdCAgICAgICAgICB0aGlzLl9jb21wbGV0ZSh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICAgIHRoaXMuX2ZpcnN0VXBkYXRlKHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgICAvLyByZXNldCBpc0NvbXBsZXRlIGZsYWcgY2FsbFxuXHQgICAgICAgICAgLy8gY3V6IHdlIHJldHVybmVkIHRvIGFjdGl2ZSBhcmVhXG5cdCAgICAgICAgICAvLyB0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgdGhpcy5faXNDb21wbGV0ZWQgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChwcmV2VCA9PT0gJ2RlbGF5Jykge1xuXHQgICAgICAgIC8vIGlmIGp1c3QgYmVmb3JlIGRlbGF5IGdhcFxuXHQgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPDw8XG5cdCAgICAgICAgLy8gICAgICAgICAgICAgICBeMiAgICBeMVxuXHQgICAgICAgIGlmIChUIDwgVFByZXZWYWx1ZSkge1xuXHQgICAgICAgICAgdGhpcy5fcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gaWYganVzdCBhZnRlciBkZWxheSBnYXBcblx0ICAgICAgICAvLyB8LS0tPT09PT18LS0tPT09PT18LS0tPT09PT18ID4+PlxuXHQgICAgICAgIC8vICAgICAgICAgICAgXjEgIF4yXG5cdCAgICAgICAgaWYgKFQgPT09IFRQcmV2VmFsdWUgJiYgVCA+IDApIHtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIGlzWW95byk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gc3dhcCBwcm9ncmVzcyBhbmQgcmVwZWF0U3RhcnQgYmFzZWQgb24gZGlyZWN0aW9uXG5cdCAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAvLyBpZiBwcm9ncmVzcyBpcyBlcXVhbCAwIGFuZCBwcm9ncmVzcyBncm93c1xuXHQgICAgICAgIGlmIChwcm9jID09PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodGltZSAhPT0gcHJvcHMuZW5kVGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoaXNZb3lvID8gMSAtIHByb2MgOiBwcm9jLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAodGltZSAhPT0gcHJvcHMuZW5kVGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoaXNZb3lvID8gMSAtIHByb2MgOiBwcm9jLCB0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBpZiBwcm9ncmVzcyBpcyBlcXVhbCAwIGFuZCBwcm9ncmVzcyBncm93c1xuXHQgICAgICAgIGlmIChwcm9jID09PSAwKSB7XG5cdCAgICAgICAgICB0aGlzLl9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aW1lID09PSBwcm9wcy5zdGFydFRpbWUpIHtcblx0ICAgICAgICB0aGlzLl9zdGFydCh0aW1lLCBpc1lveW8pO1xuXHQgICAgICB9XG5cdCAgICAgIC8vIGRlbGF5IGdhcCAtIHJlYWN0IG9ubHkgb25jZVxuXHQgICAgfSBlbHNlIGlmICh0aGlzLl9pc0luQWN0aXZlQXJlYSkge1xuXHQgICAgICAgIC8vIGJlY2F1c2UgVCB3aWxsIGJlIHN0cmluZyBvZiBcImRlbGF5XCIgaGVyZSxcblx0ICAgICAgICAvLyBsZXQncyBub3JtYWxpemUgaXQgYmUgc2V0dGluZyB0byBUVmFsdWVcblx0ICAgICAgICB2YXIgdCA9IFQgPT09ICdkZWxheScgPyBUVmFsdWUgOiBULFxuXHQgICAgICAgICAgICBpc0dyb3dzID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lO1xuXHQgICAgICAgIC8vIGRlY3JlbWVudCBwZXJpb2QgaWYgZm9yd2FyZCBkaXJlY3Rpb24gb2YgdXBkYXRlXG5cdCAgICAgICAgaXNHcm93cyAmJiB0LS07XG5cdCAgICAgICAgLy8gY2FsY3VsYXRlIG5vcm1hbGl6ZWQgeW95b1plcm8gdmFsdWVcblx0ICAgICAgICB5b3lvWmVybyA9IHByb3BzLmlzWW95byAmJiB0ICUgMiA9PT0gMSA/IDEgOiAwO1xuXHQgICAgICAgIC8vIGlmIHdhcyBpbiBhY3RpdmUgYXJlYSBhbmQgcHJldmlvdXMgdGltZSB3YXMgbGFyZ2VyXG5cdCAgICAgICAgLy8gfC0tLT09PT09fC0tLT09PT09fC0tLT09PT09fCA8PDxcblx0ICAgICAgICAvLyAgIF4yIF4xICAgIF4yIF4xICAgIF4yIF4xXG5cdCAgICAgICAgaWYgKHRpbWUgPCB0aGlzLl9wcmV2VGltZSkge1xuXHQgICAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoeW95b1plcm8sIHRpbWUsIHlveW9aZXJvID09PSAxKTtcblx0ICAgICAgICAgIHRoaXMuX3JlcGVhdFN0YXJ0KHRpbWUsIHlveW9aZXJvID09PSAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gc2V0IDEgb3IgMCByZWdhcmRpbmcgZGlyZWN0aW9uIGFuZCB5b3lvXG5cdCAgICAgICAgdGhpcy5fc2V0UHJvZ3Jlc3MoaXNHcm93cyA/IDEgLSB5b3lvWmVybyA6IHlveW9aZXJvLCB0aW1lLCB5b3lvWmVybyA9PT0gMSk7XG5cdCAgICAgICAgLy8gaWYgdGltZSBncm93c1xuXHQgICAgICAgIGlmICh0aW1lID4gdGhpcy5fcHJldlRpbWUpIHtcblx0ICAgICAgICAgIC8vIGlmIHJldmVyc2UgZGlyZWN0aW9uIGFuZCBpbiBkZWxheSBnYXAsIHRoZW4gcHJvZ3Jlc3Mgd2lsbCBiZSAwXG5cdCAgICAgICAgICAvLyBpZiBzbyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgdGhlIG9uUmVwZWF0Q29tcGxldGUgY2FsbGJhY2tcblx0ICAgICAgICAgIC8vIHwtLS09PT09PXwtLS09PT09PXwtLS09PT09PXwgPDw8XG5cdCAgICAgICAgICAvLyAgIF4wICAgICAgIF4wICAgICAgIF4wICBcblx0ICAgICAgICAgIC8vIE9SIHdlIGhhdmUgZmxpcHBlZCAwIHRvIDEgcmVnYXJkaW5nIHlveW8gb3B0aW9uXG5cdCAgICAgICAgICBpZiAodGhpcy5wcm9ncmVzcyAhPT0gMCB8fCB5b3lvWmVybyA9PT0gMSkge1xuXHQgICAgICAgICAgICAvLyBzaW5jZSB3ZSByZXBlYXRDb21wbGV0ZSBmb3IgcHJldmlvdXMgcGVyaW9kXG5cdCAgICAgICAgICAgIC8vIGludmVydCBpc1lveW8gb3B0aW9uXG5cdCAgICAgICAgICAgIC8vIGlzIGVsYXBzZWQgaXMgMCAtIGNvdW50IGFzIHByZXZpb3VzIHBlcmlvZFxuXHQgICAgICAgICAgICB0aGlzLl9yZXBlYXRDb21wbGV0ZSh0aW1lLCB5b3lvWmVybyA9PT0gMSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIHNldCBmbGFnIHRvIGluZGljYXRlIGluYWN0aXZlIGFyZWFcblx0ICAgICAgICB0aGlzLl9pc0luQWN0aXZlQXJlYSA9IGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAvLyB3ZSd2ZSBnb3QgdGhlIGZpcnN0IHVwZGF0ZSBub3dcblx0ICAgIHRoaXMuX3dhc1Vrbm93blVwZGF0ZSA9IGZhbHNlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW1vdmUgdGhlIFR3ZWVuIGZyb20gdGhlIHR3ZWVuZXIuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3JlbW92ZUZyb21Ud2VlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUZyb21Ud2VlbmVyKCkge1xuXHQgICAgX3R3ZWVuZXIyLmRlZmF1bHQucmVtb3ZlKHRoaXMpO3JldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgY3VycmVudCBwZXJpb2QgbnVtYmVyLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBUaW1lIHRvIGdldCB0aGUgcGVyaW9kIGZvci5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IEN1cnJlbnQgcGVyaW9kIG51bWJlci5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2dldFBlcmlvZCA9IGZ1bmN0aW9uIF9nZXRQZXJpb2QodGltZSkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBUVGltZSA9IHAuZGVsYXkgKyBwLmR1cmF0aW9uLFxuXHQgICAgICAgIGRUaW1lID0gcC5kZWxheSArIHRpbWUgLSBwLnN0YXJ0VGltZSxcblx0ICAgICAgICBUID0gZFRpbWUgLyBUVGltZSxcblxuXHQgICAgLy8gaWYgdGltZSBpZiBlcXVhbCB0byBlbmRUaW1lIHdlIG5lZWQgdG8gc2V0IHRoZSBlbGFwc2VkXG5cdCAgICAvLyB0aW1lIHRvIDAgdG8gZml4IHRoZSBvY2Nhc2lvbmFsIHByZWNpc2lvbiBqcyBidWcsIHdoaWNoXG5cdCAgICAvLyBjYXVzZXMgMCB0byBiZSBzb21ldGhpbmcgbGlrZSAxZS0xMlxuXHQgICAgZWxhcHNlZCA9IHRpbWUgPCBwLmVuZFRpbWUgPyBkVGltZSAlIFRUaW1lIDogMDtcblx0ICAgIC8vIElmIHRoZSBsYXRlc3QgcGVyaW9kLCByb3VuZCB0aGUgcmVzdWx0LCBvdGhlcndpc2UgZmxvb3IgaXQuXG5cdCAgICAvLyBCYXNpY2FsbHkgd2UgYWx3YXlzIGNhbiBmbG9vciB0aGUgcmVzdWx0LCBidXQgYmVjYXVzZSBvZiBqc1xuXHQgICAgLy8gcHJlY2lzaW9uIGlzc3Vlcywgc29tZXRpbWVzIHRoZSByZXN1bHQgaXMgMi45OTk5OTk5OCB3aGljaFxuXHQgICAgLy8gd2lsbCByZXN1bHQgaW4gMiBpbnN0ZWFkIG9mIDMgYWZ0ZXIgdGhlIGZsb29yIG9wZXJhdGlvbi5cblx0ICAgIFQgPSB0aW1lID49IHAuZW5kVGltZSA/IE1hdGgucm91bmQoVCkgOiBNYXRoLmZsb29yKFQpO1xuXHQgICAgLy8gaWYgdGltZSBpcyBsYXJnZXIgdGhlbiB0aGUgZW5kIHRpbWVcblx0ICAgIGlmICh0aW1lID4gcC5lbmRUaW1lKSB7XG5cdCAgICAgIC8vIHNldCBlcXVhbCB0byB0aGUgcGVyaW9kcyBjb3VudFxuXHQgICAgICBUID0gTWF0aC5yb3VuZCgocC5lbmRUaW1lIC0gcC5zdGFydFRpbWUgKyBwLmRlbGF5KSAvIFRUaW1lKTtcblx0ICAgICAgLy8gaWYgaW4gZGVsYXkgZ2FwLCBzZXQgX2RlbGF5VCB0byBjdXJyZW50XG5cdCAgICAgIC8vIHBlcmlvZCBudW1iZXIgYW5kIHJldHVybiBcImRlbGF5XCJcblx0ICAgIH0gZWxzZSBpZiAoZWxhcHNlZCA+IDAgJiYgZWxhcHNlZCA8IHAuZGVsYXkpIHtcblx0ICAgICAgICB0aGlzLl9kZWxheVQgPSBUO1QgPSAnZGVsYXknO1xuXHQgICAgICB9XG5cdCAgICAvLyBpZiB0aGUgZW5kIG9mIHBlcmlvZCBhbmQgdGhlcmUgaXMgYSBkZWxheVxuXHQgICAgcmV0dXJuIFQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBUd2VlbidzIHByb2dyZXNzIGFuZCBjYWxsIG9uVXBkYXRlIGNhbGxiYWNrLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZSBAIE1vZHVsZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJcyB5b3lvIHBlcmlkby4gVXNlZCBpbiBUaW1lbGluZSB0byBwYXNzIHRvIFR3ZWVuLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKHByb2MsIHRpbWUsIGlzWW95bykge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcyxcblx0ICAgICAgICBpc1lveW9DaGFuZ2VkID0gcC53YXNZb3lvICE9PSBpc1lveW8sXG5cdCAgICAgICAgaXNGb3J3YXJkID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lO1xuXG5cdCAgICB0aGlzLnByb2dyZXNzID0gcHJvYztcblx0ICAgIC8vIGdldCB0aGUgY3VycmVudCBlYXNpbmcgZm9yIGBmb3J3YXJkYCBkaXJlY3Rpb24gcmVnYXJkaW5nIGB5b3lvYFxuXHQgICAgaWYgKGlzRm9yd2FyZCAmJiAhaXNZb3lvIHx8ICFpc0ZvcndhcmQgJiYgaXNZb3lvKSB7XG5cdCAgICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IHAuZWFzaW5nKHByb2MpO1xuXHQgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgZWFzaW5nIGZvciBgYmFja3dhcmRgIGRpcmVjdGlvbiByZWdhcmRpbmcgYHlveW9gXG5cdCAgICB9IGVsc2UgaWYgKCFpc0ZvcndhcmQgJiYgIWlzWW95byB8fCBpc0ZvcndhcmQgJiYgaXNZb3lvKSB7XG5cdCAgICAgICAgdmFyIGVhc2luZyA9IHAuYmFja3dhcmRFYXNpbmcgIT0gbnVsbCA/IHAuYmFja3dhcmRFYXNpbmcgOiBwLmVhc2luZztcblxuXHQgICAgICAgIHRoaXMuZWFzZWRQcm9ncmVzcyA9IGVhc2luZyhwcm9jKTtcblx0ICAgICAgfVxuXG5cdCAgICBpZiAocC5wcmV2RWFzZWRQcm9ncmVzcyAhPT0gdGhpcy5lYXNlZFByb2dyZXNzIHx8IGlzWW95b0NoYW5nZWQpIHtcblx0ICAgICAgaWYgKHAub25VcGRhdGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHAub25VcGRhdGUuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGhpcy5lYXNlZFByb2dyZXNzLCB0aGlzLnByb2dyZXNzLCBpc0ZvcndhcmQsIGlzWW95byk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHAucHJldkVhc2VkUHJvZ3Jlc3MgPSB0aGlzLmVhc2VkUHJvZ3Jlc3M7XG5cdCAgICBwLndhc1lveW8gPSBpc1lveW87XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHR3ZWVuJ3Mgc3RhdGUgdG8gc3RhcnQgYW5kIGNhbGwgb25TdGFydCBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX3N0YXJ0XG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIF9zdGFydCh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uU3RhcnQgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25TdGFydC5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc0NvbXBsZXRlZCA9IGZhbHNlO3RoaXMuX2lzU3RhcnRlZCA9IHRydWU7XG5cdCAgICB0aGlzLl9pc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgb25QbGF5YmFja1N0YXJ0IGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tTdGFydCA9IGZ1bmN0aW9uIF9wbGF5YmFja1N0YXJ0KCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUGxheWJhY2tTdGFydCAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tTdGFydC5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBvblBsYXliYWNrUGF1c2UgY2FsbGJhY2tcblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9wbGF5YmFja1BhdXNlID0gZnVuY3Rpb24gX3BsYXliYWNrUGF1c2UoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKHAub25QbGF5YmFja1BhdXNlICE9IG51bGwgJiYgdHlwZW9mIHAub25QbGF5YmFja1BhdXNlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25QbGF5YmFja1BhdXNlLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIG9uUGxheWJhY2tTdG9wIGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tTdG9wID0gZnVuY3Rpb24gX3BsYXliYWNrU3RvcCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblBsYXliYWNrU3RvcCAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tTdG9wID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25QbGF5YmFja1N0b3AuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcyk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgb25QbGF5YmFja0NvbXBsZXRlIGNhbGxiYWNrXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcGxheWJhY2tDb21wbGV0ZSA9IGZ1bmN0aW9uIF9wbGF5YmFja0NvbXBsZXRlKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUGxheWJhY2tDb21wbGV0ZSAhPSBudWxsICYmIHR5cGVvZiBwLm9uUGxheWJhY2tDb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUGxheWJhY2tDb21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHR3ZWVuJ3Mgc3RhdGUgdG8gY29tcGxldGUuXG5cdCAgICBAbWV0aG9kIF9jb21wbGV0ZVxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiBfY29tcGxldGUodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNDb21wbGV0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uQ29tcGxldGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25Db21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lzQ29tcGxldGVkID0gdHJ1ZTt0aGlzLl9pc1N0YXJ0ZWQgPSBmYWxzZTtcblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSBmYWxzZTtcblx0ICAgIC8vIHJlc2V0IF9wcmV2WW95byBmb3IgdGltZWxpbmUgdXNhZ2Vcblx0ICAgIHRoaXMuX3ByZXZZb3lvID0gdW5kZWZpbmVkO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHJ1biBvbkZpcnN0VXBkYXRlIGNhbGxiYWNrLlxuXHQgICAgQG1ldGhvZCBfZmlyc3RVcGRhdGVcblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9maXJzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9maXJzdFVwZGF0ZSh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc0ZpcnN0VXBkYXRlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vbkZpcnN0VXBkYXRlICE9IG51bGwgJiYgdHlwZW9mIHAub25GaXJzdFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAvLyBvbkZpcnN0VXBkYXRlIHNob3VsZCBoYXZlIHR3ZWVuIHBvaW50ZXJcblx0ICAgICAgcC5vbkZpcnN0VXBkYXRlLnR3ZWVuID0gdGhpcztcblx0ICAgICAgcC5vbkZpcnN0VXBkYXRlLmNhbGwocC5jYWxsYmFja3NDb250ZXh0IHx8IHRoaXMsIHRpbWUgPiB0aGlzLl9wcmV2VGltZSwgaXNZb3lvKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzRmlyc3RVcGRhdGUgPSB0cnVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBjYWxsIG9uUmVwZWF0Q29tcGxldGUgY2FsYmFjayBhbmQgc2V0IGZsYWdzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJcyByZXBlYXQgcGVyaW9kLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcmVwZWF0Q29tcGxldGUgPSBmdW5jdGlvbiBfcmVwZWF0Q29tcGxldGUodGltZSwgaXNZb3lvKSB7XG5cdCAgICBpZiAodGhpcy5faXNSZXBlYXRDb21wbGV0ZWQpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmIChwLm9uUmVwZWF0Q29tcGxldGUgIT0gbnVsbCAmJiB0eXBlb2YgcC5vblJlcGVhdENvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHAub25SZXBlYXRDb21wbGV0ZS5jYWxsKHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLCB0aW1lID4gdGhpcy5fcHJldlRpbWUsIGlzWW95byk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9pc1JlcGVhdENvbXBsZXRlZCA9IHRydWU7XG5cdCAgICAvLyB0aGlzLl9wcmV2WW95byA9IG51bGw7XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsbCBvblJlcGVhdFN0YXJ0IGNhbGJhY2sgYW5kIHNldCBmbGFncy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gQ3VycmVudCB1cGRhdGUgdGltZS5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSXMgeW95byBwZXJpb2QuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9yZXBlYXRTdGFydCA9IGZ1bmN0aW9uIF9yZXBlYXRTdGFydCh0aW1lLCBpc1lveW8pIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlcGVhdFN0YXJ0KSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblJlcGVhdFN0YXJ0ICE9IG51bGwgJiYgdHlwZW9mIHAub25SZXBlYXRTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUmVwZWF0U3RhcnQuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgdGltZSA+IHRoaXMuX3ByZXZUaW1lLCBpc1lveW8pO1xuXHQgICAgfVxuXHQgICAgdGhpcy5faXNSZXBlYXRTdGFydCA9IHRydWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBvblByb2dyZXNzIGNhbGxiYWNrLlxuXHQgICAgQG1ldGhvZCBfcHJvZ3Jlc3Ncblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0LlxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fcHJvZ3Jlc3MgPSBmdW5jdGlvbiBfcHJvZ3Jlc3MocHJvZ3Jlc3MsIHRpbWUpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblByb2dyZXNzICE9IG51bGwgJiYgdHlwZW9mIHAub25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICBwLm9uUHJvZ3Jlc3MuY2FsbChwLmNhbGxiYWNrc0NvbnRleHQgfHwgdGhpcywgcHJvZ3Jlc3MsIHRpbWUgPiB0aGlzLl9wcmV2VGltZSk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxhdW5jaCBvblJlZnJlc2ggY2FsbGJhY2suXG5cdCAgICBAbWV0aG9kIF9yZWZyZXNoXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJZiByZWZyZXNoIGV2ZW4gYmVmb3JlIHN0YXJ0IHRpbWUuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9yZWZyZXNoID0gZnVuY3Rpb24gX3JlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICBpZiAocC5vblJlZnJlc2ggIT0gbnVsbCkge1xuXHQgICAgICB2YXIgY29udGV4dCA9IHAuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzLFxuXHQgICAgICAgICAgcHJvZ3Jlc3MgPSBpc0JlZm9yZSA/IDAgOiAxO1xuXG5cdCAgICAgIHAub25SZWZyZXNoLmNhbGwoY29udGV4dCwgaXNCZWZvcmUsIHAuZWFzaW5nKHByb2dyZXNzKSwgcHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB3aGljaCBpcyBjYWxsZWQgd2hlbiB0aGUgdHdlZW4gaXMgcmVtb3ZlZCBmcm9tIHR3ZWVuZXIuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuLnByb3RvdHlwZS5fb25Ud2VlbmVyUmVtb3ZlID0gZnVuY3Rpb24gX29uVHdlZW5lclJlbW92ZSgpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlIHR3ZWVuIGlzIHJlbW92ZWRcblx0ICAgIGZyb20gdHdlZW5lciB3aGVuIGZpbmlzaGVkLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX29uVHdlZW5lckZpbmlzaCA9IGZ1bmN0aW9uIF9vblR3ZWVuZXJGaW5pc2goKSB7XG5cdCAgICB0aGlzLl9zZXRQbGF5YmFja1N0YXRlKCdzdG9wJyk7XG5cdCAgICB0aGlzLl9wbGF5YmFja0NvbXBsZXRlKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBwcm9wZXJ0eVtzXSBvbiBUd2Vlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGUgQCBNb2R1bGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0LCBTdHJpbmd9IEhhc2ggb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycywgb3IgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7X30gUHJvcGVydHkncyB2YWx1ZSB0byBzZXQuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9zZXRQcm9wID0gZnVuY3Rpb24gX3NldFByb3Aob2JqLCB2YWx1ZSkge1xuXHQgICAgX01vZHVsZS5wcm90b3R5cGUuX3NldFByb3AuY2FsbCh0aGlzLCBvYmosIHZhbHVlKTtcblx0ICAgIHRoaXMuX2NhbGNEaW1lbnRpb25zKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBzaW5nbGUgcHJvcGVydHkuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlIEAgTW9kdWxlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBUd2Vlbi5wcm90b3R5cGUuX2Fzc2lnblByb3AgPSBmdW5jdGlvbiBfYXNzaWduUHJvcChrZXksIHZhbHVlKSB7XG5cdCAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0c1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgdmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHQgICAgfVxuXHQgICAgLy8gcGFyc2UgZWFzaW5nXG5cdCAgICBpZiAoa2V5ID09PSAnZWFzaW5nJykge1xuXHQgICAgICB2YWx1ZSA9IF9lYXNpbmcyLmRlZmF1bHQucGFyc2VFYXNpbmcodmFsdWUpO1xuXHQgICAgICB2YWx1ZS5fcGFyZW50ID0gdGhpcztcblx0ICAgIH1cblx0ICAgIC8vIGhhbmRsZSBjb250cm9sIGNhbGxiYWNrcyBvdmVycmlkZXNcblx0ICAgIHZhciBjb250cm9sID0gdGhpcy5fY2FsbGJhY2tPdmVycmlkZXNba2V5XSxcblx0ICAgICAgICBpc250T3ZlcnJpZGVuID0gIXZhbHVlIHx8ICF2YWx1ZS5pc01vanNDYWxsYmFja092ZXJyaWRlO1xuXHQgICAgaWYgKGNvbnRyb2wgJiYgaXNudE92ZXJyaWRlbikge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMuX292ZXJyaWRlQ2FsbGJhY2sodmFsdWUsIGNvbnRyb2wpO1xuXHQgICAgfVxuXHQgICAgLy8gY2FsbCBzdXBlciBvbiBNb2R1bGVcblx0ICAgIF9Nb2R1bGUucHJvdG90eXBlLl9hc3NpZ25Qcm9wLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIG92ZXJyaWRlIGNhbGxiYWNrIGZvciBjb250cm9sbCBwdXByb3Blcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gICAgQ2FsbGJhY2sgbmFtZS5cblx0ICAgIEBwYXJtYSB7RnVuY3Rpb259ICBNZXRob2QgdG8gY2FsbCAgXG5cdCAgKi9cblxuXG5cdCAgVHdlZW4ucHJvdG90eXBlLl9vdmVycmlkZUNhbGxiYWNrID0gZnVuY3Rpb24gX292ZXJyaWRlQ2FsbGJhY2soY2FsbGJhY2ssIGZ1bikge1xuXHQgICAgdmFyIGlzQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsXG5cdCAgICAgICAgb3ZlcnJpZGUgPSBmdW5jdGlvbiBjYWxsYmFja092ZXJyaWRlKCkge1xuXHQgICAgICAvLyBjYWxsIG92ZXJyaWRlbiBjYWxsYmFjayBpZiBpdCBleGlzdHNcblx0ICAgICAgaXNDYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAvLyBjYWxsIHRoZSBwYXNzZWQgY2xlYW51cCBmdW5jdGlvblxuXHQgICAgICBmdW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIH07XG5cdCAgICAvLyBhZGQgb3ZlcnJpZGRlbiBmbGFnXG5cdCAgICBvdmVycmlkZS5pc01vanNDYWxsYmFja092ZXJyaWRlID0gdHJ1ZTtcblx0ICAgIHJldHVybiBvdmVycmlkZTtcblx0ICB9O1xuXG5cdCAgLy8gX3Zpc3VhbGl6ZVByb2dyZXNzKHRpbWUpIHtcblx0ICAvLyAgIHZhciBzdHIgPSAnfCcsXG5cdCAgLy8gICAgICAgcHJvY1N0ciA9ICcgJyxcblx0ICAvLyAgICAgICBwID0gdGhpcy5fcHJvcHMsXG5cdCAgLy8gICAgICAgcHJvYyA9IHAuc3RhcnRUaW1lIC0gcC5kZWxheTtcblxuXHQgIC8vICAgd2hpbGUgKCBwcm9jIDwgcC5lbmRUaW1lICkge1xuXHQgIC8vICAgICBpZiAocC5kZWxheSA+IDAgKSB7XG5cdCAgLy8gICAgICAgdmFyIG5ld1Byb2MgPSBwcm9jICsgcC5kZWxheTtcblx0ICAvLyAgICAgICBpZiAoIHRpbWUgPiBwcm9jICYmIHRpbWUgPCBuZXdQcm9jICkge1xuXHQgIC8vICAgICAgICAgcHJvY1N0ciArPSAnIF4gJztcblx0ICAvLyAgICAgICB9IGVsc2Uge1xuXHQgIC8vICAgICAgICAgcHJvY1N0ciArPSAnICAgJztcblx0ICAvLyAgICAgICB9XG5cdCAgLy8gICAgICAgcHJvYyA9IG5ld1Byb2M7XG5cdCAgLy8gICAgICAgc3RyICArPSAnLS0tJztcblx0ICAvLyAgICAgfVxuXHQgIC8vICAgICB2YXIgbmV3UHJvYyA9IHByb2MgKyBwLmR1cmF0aW9uO1xuXHQgIC8vICAgICBpZiAoIHRpbWUgPiBwcm9jICYmIHRpbWUgPCBuZXdQcm9jICkge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJyAgXiAgICc7XG5cdCAgLy8gICAgIH0gZWxzZSBpZiAodGltZSA9PT0gcHJvYykge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJ14gICAgICc7XG5cdCAgLy8gICAgIH0gZWxzZSBpZiAodGltZSA9PT0gbmV3UHJvYykge1xuXHQgIC8vICAgICAgIHByb2NTdHIgKz0gJyAgICBeICc7XG5cdCAgLy8gICAgIH0gZWxzZSB7XG5cdCAgLy8gICAgICAgcHJvY1N0ciArPSAnICAgICAgJztcblx0ICAvLyAgICAgfVxuXHQgIC8vICAgICBwcm9jID0gbmV3UHJvYztcblx0ICAvLyAgICAgc3RyICs9ICc9PT09PXwnO1xuXHQgIC8vICAgfVxuXG5cdCAgLy8gICBjb25zb2xlLmxvZyhzdHIpO1xuXHQgIC8vICAgY29uc29sZS5sb2cocHJvY1N0cik7XG5cdCAgLy8gfVxuXG5cblx0ICByZXR1cm4gVHdlZW47XG5cdH0oX21vZHVsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVHdlZW47XG5cbi8qKiovIH0sXG4vKiA5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2dldEl0ZXJhdG9yMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG5cdHZhciBfZ2V0SXRlcmF0b3IzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0SXRlcmF0b3IyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0dmFyIF90d2VlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cblx0dmFyIF90d2VlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuZXIpO1xuXG5cdHZhciBfdHdlZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG5cdHZhciBfdHdlZW4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW4pO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0dmFyIFRpbWVsaW5lID0gZnVuY3Rpb24gKF9Ud2Vlbikge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFRpbWVsaW5lLCBfVHdlZW4pO1xuXG5cdCAgLypcblx0ICAgIEFQSSBtZXRob2QgdG8gYWRkIGNoaWxkIHR3ZWVucy90aW1lbGluZXMuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge09iamVjdCwgQXJyYXl9IFR3ZWVuL1RpbWVsaW5lIG9yIGFuIGFycmF5IG9mIHN1Y2guXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBTZWxmLlxuXHQgICovXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKCkge1xuXHQgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0ICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fcHVzaFRpbWVsaW5lQXJyYXkoYXJncyk7XG5cdCAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBhcHBlbmQgdGhlIFR3ZWVuL1RpbWVsaW5lIHRvIHRoZSBlbmQgb2YgdGhlXG5cdCAgICB0aW1lbGluZS4gRWFjaCBhcmd1bWVudCBpcyB0cmVhdGVkIGFzIGEgbmV3IGFwcGVuZC5cblx0ICAgIEFycmF5IG9mIHR3ZWVucyBpcyB0cmVhdGVkIGFzIGEgcGFyYWxsZWwgc2VxdWVuY2UuIFxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtPYmplY3QsIEFycmF5fSBUd2Vlbi9UaW1lbGluZSB0byBhcHBlbmQgb3IgYXJyYXkgb2Ygc3VjaC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNlbGYuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcblx0ICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdGltZWxpbmUgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICB0aW1lbGluZVtfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSB0aW1lbGluZSwgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5KF9pdGVyYXRvciksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgPyBfaXRlcmF0b3IgOiAoMCwgX2dldEl0ZXJhdG9yMy5kZWZhdWx0KShfaXRlcmF0b3IpOzspIHtcblx0ICAgICAgdmFyIF9yZWY7XG5cblx0ICAgICAgaWYgKF9pc0FycmF5KSB7XG5cdCAgICAgICAgaWYgKF9pID49IF9pdGVyYXRvci5sZW5ndGgpIGJyZWFrO1xuXHQgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgX2kgPSBfaXRlcmF0b3IubmV4dCgpO1xuXHQgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcblx0ICAgICAgICBfcmVmID0gX2kudmFsdWU7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdG0gPSBfcmVmO1xuXG5cdCAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRtKSkge1xuXHQgICAgICAgIHRoaXMuX2FwcGVuZFRpbWVsaW5lQXJyYXkodG0pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuX2FwcGVuZFRpbWVsaW5lKHRtLCB0aGlzLl90aW1lbGluZXMubGVuZ3RoKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgQVBJIG1ldGhvZCB0byBzdG9wIHRoZSBUd2Vlbi5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSAgIHtOdW1iZXJ9IFByb2dyZXNzIFswLi4xXSB0byBzZXQgd2hlbiBzdG9wcGVkLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gU2VsZi5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AocHJvZ3Jlc3MpIHtcblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuc3RvcC5jYWxsKHRoaXMsIHByb2dyZXNzKTtcblx0ICAgIHRoaXMuX3N0b3BDaGlsZHJlbihwcm9ncmVzcyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVzZXQgdHdlZW4ncyBzdGF0ZSBhbmQgcHJvcGVydGllcy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBvdmVycmlkZXMgQCBUd2VlblxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcblx0ICAgIHRoaXMuX3Jlc2V0Q2hpbGRyZW4oKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGByZXNldGAgbWV0aG9kIG9uIGFsbCBjaGlsZHJlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9yZXNldENoaWxkcmVuID0gZnVuY3Rpb24gX3Jlc2V0Q2hpbGRyZW4oKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl90aW1lbGluZXNbaV0ucmVzZXQoKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBgc3RvcGAgbWV0aG9kIG9uIGFsbCBjaGlsZHJlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7TnVtYmVyfSBQcm9ncmVzcyBbMC4uMV0gdG8gc2V0IHdoZW4gc3RvcHBlZC5cblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3N0b3BDaGlsZHJlbiA9IGZ1bmN0aW9uIF9zdG9wQ2hpbGRyZW4ocHJvZ3Jlc3MpIHtcblx0ICAgIGZvciAodmFyIGkgPSB0aGlzLl90aW1lbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdGhpcy5fdGltZWxpbmVzW2ldLnN0b3AocHJvZ3Jlc3MpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgdHdlZW4ncyBzdGF0ZSB0byBjb21wbGV0ZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVHdlZW5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHRpbWUuXG5cdCAgICBAcGFyYW0ge0Jvb2xlYW59IElzIHlveW8gcGVyaW9kLlxuXHQgICovXG5cdCAgLy8gX2NvbXBsZXRlICggdGltZSwgaXNZb3lvICkge1xuXHQgIC8vICAgLy8gdGhpcy5fdXBkYXRlQ2hpbGRyZW4oIDEsIHRpbWUsIGlzWW95byApO1xuXHQgIC8vICAgLy8gdGhpcy5fc2V0UHJvZ3Jlc3MoIDEsIHRpbWUsIGlzWW95byApO1xuXHQgIC8vICAgc3VwZXIuX2NvbXBsZXRlKCB0aW1lLCBpc1lveW8gKTtcblx0ICAvLyAgIC8vIHRoaXMuX3Jlc2V0Q2hpbGRyZW4oKTtcblx0ICAvLyB9XG5cblx0ICAvLyBeIFBVQkxJQyAgTUVUSE9EKFMpIF5cblx0ICAvLyB2IFBSSVZBVEUgTUVUSE9EKFMpIHZcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYXBwZW5kIFR3ZWVuL1RpbWVsaW5lIGFycmF5IG9yIG1peCBvZiBzdWNoLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIFR3ZWVucy9UaW1lbGluZXMuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9hcHBlbmRUaW1lbGluZUFycmF5ID0gZnVuY3Rpb24gX2FwcGVuZFRpbWVsaW5lQXJyYXkodGltZWxpbmVBcnJheSkge1xuXHQgICAgdmFyIGkgPSB0aW1lbGluZUFycmF5Lmxlbmd0aCxcblx0ICAgICAgICB0aW1lID0gdGhpcy5fcHJvcHMucmVwZWF0VGltZSAtIHRoaXMuX3Byb3BzLmRlbGF5LFxuXHQgICAgICAgIGxlbiA9IHRoaXMuX3RpbWVsaW5lcy5sZW5ndGg7XG5cblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdGhpcy5fYXBwZW5kVGltZWxpbmUodGltZWxpbmVBcnJheVtpXSwgbGVuLCB0aW1lKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gYXBwZW5kIGEgc2luZ2xlIHRpbWVsaW5lIHRvIHRoZSBUaW1lbGluZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4vVGltbGluZSB0byBhcHBlbmQuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIGFwcGVuZC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBTaGlmdCB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fYXBwZW5kVGltZWxpbmUgPSBmdW5jdGlvbiBfYXBwZW5kVGltZWxpbmUodGltZWxpbmUsIGluZGV4LCB0aW1lKSB7XG5cdCAgICAvLyBpZiB0aW1lbGluZSBpcyBhIG1vZHVsZSB3aXRoIHRpbWVsaW5lIHByb3BlcnR5IHRoZW4gZXh0cmFjdCBpdFxuXHQgICAgaWYgKHRpbWVsaW5lLnRpbWVsaW5lIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcblx0ICAgICAgdGltZWxpbmUgPSB0aW1lbGluZS50aW1lbGluZTtcblx0ICAgIH1cblx0ICAgIGlmICh0aW1lbGluZS50d2VlbiBpbnN0YW5jZW9mIF90d2VlbjIuZGVmYXVsdCkge1xuXHQgICAgICB0aW1lbGluZSA9IHRpbWVsaW5lLnR3ZWVuO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgc2hpZnQgPSB0aW1lICE9IG51bGwgPyB0aW1lIDogdGhpcy5fcHJvcHMuZHVyYXRpb247XG5cdCAgICBzaGlmdCArPSB0aW1lbGluZS5fcHJvcHMuc2hpZnRUaW1lIHx8IDA7XG5cdCAgICB0aW1lbGluZS5pbmRleCA9IGluZGV4O3RoaXMuX3B1c2hUaW1lbGluZSh0aW1lbGluZSwgc2hpZnQpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIFByaXZhdGVNZXRob2QgdG8gcHVzaCBUd2Vlbi9UaW1lbGluZSBhcnJheS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5fSBBcnJheSBvZiBUd2VlbnMvVGltZWxpbmVzLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcHVzaFRpbWVsaW5lQXJyYXkgPSBmdW5jdGlvbiBfcHVzaFRpbWVsaW5lQXJyYXkoYXJyYXkpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHRtID0gYXJyYXlbaV07XG5cdCAgICAgIC8vIHJlY3Vyc2l2ZSBwdXNoIHRvIGhhbmRsZSBhcnJheXMgb2YgYXJyYXlzXG5cdCAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRtKSkge1xuXHQgICAgICAgIHRoaXMuX3B1c2hUaW1lbGluZUFycmF5KHRtKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9wdXNoVGltZWxpbmUodG0pO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwdXNoIGEgc2luZ2xlIFR3ZWVuL1RpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2VlbiBvciBUaW1lbGluZSB0byBwdXNoLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gc2hpZnQgdGhlIHN0YXJ0IHRpbWVcblx0ICAgICAgICAgICAgICAgICAgICBvZiB0aGUgVHdlZW4vVGltZWxpbmUuXG5cdCAgKi9cblxuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl9wdXNoVGltZWxpbmUgPSBmdW5jdGlvbiBfcHVzaFRpbWVsaW5lKHRpbWVsaW5lLCBzaGlmdCkge1xuXHQgICAgLy8gaWYgdGltZWxpbmUgaXMgYSBtb2R1bGUgd2l0aCB0aW1lbGluZSBwcm9wZXJ0eSB0aGVuIGV4dHJhY3QgaXRcblx0ICAgIGlmICh0aW1lbGluZS50aW1lbGluZSBpbnN0YW5jZW9mIFRpbWVsaW5lKSB7XG5cdCAgICAgIHRpbWVsaW5lID0gdGltZWxpbmUudGltZWxpbmU7XG5cdCAgICB9XG5cdCAgICBpZiAodGltZWxpbmUudHdlZW4gaW5zdGFuY2VvZiBfdHdlZW4yLmRlZmF1bHQpIHtcblx0ICAgICAgdGltZWxpbmUgPSB0aW1lbGluZS50d2Vlbjtcblx0ICAgIH1cblx0ICAgIC8vIGFkZCBzZWxmIGRlbGF5IHRvIHRoZSB0aW1lbGluZVxuXHQgICAgc2hpZnQgIT0gbnVsbCAmJiB0aW1lbGluZS5fc2V0UHJvcCh7ICdzaGlmdFRpbWUnOiBzaGlmdCB9KTtcblx0ICAgIHRoaXMuX3RpbWVsaW5lcy5wdXNoKHRpbWVsaW5lKTtcblx0ICAgIHRoaXMuX3JlY2FsY0R1cmF0aW9uKHRpbWVsaW5lKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2Qgc2V0IHByb2dyZXNzIG9uIHNlbGYgYW5kIGNoaWxkIFR3ZWVucy9UaW1lbGluZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFByb2dyZXNzIHRvIHNldC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBDdXJyZW50IHVwZGF0ZSB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbiBfc2V0UHJvZ3Jlc3MocCwgdGltZSwgaXNZb3lvKSB7XG5cdCAgICAvLyB3ZSBuZWVkIHRvIHBhc3Mgc2VsZiBwcmV2aW91cyB0aW1lIHRvIGNoaWxkcmVuXG5cdCAgICAvLyB0byBwcmV2ZW50IGluaXRpYWwgX3dhc1Vua25vd25VcGRhdGUgbmVzdGVkIHdhdGVyZmFsbFxuXHQgICAgLy8gaWYgbm90IHlveW8gb3B0aW9uIHNldCwgcGFzcyB0aGUgcHJldmlvdXMgdGltZVxuXHQgICAgLy8gb3RoZXJ3aXNlLCBwYXNzIHByZXZpb3VzIG9yIG5leHQgdGltZSByZWdhcmRpbmcgeW95byBwZXJpb2QuXG5cblx0ICAgIC8vIENPVkVSIENVUlJFTlQgU1dBUFBFRCBPUkRFUlxuXHQgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4ocCwgdGltZSwgaXNZb3lvKTtcblxuXHQgICAgX3R3ZWVuMi5kZWZhdWx0LnByb3RvdHlwZS5fc2V0UHJvZ3Jlc3MuY2FsbCh0aGlzLCBwLCB0aW1lKTtcblx0ICB9O1xuXG5cdCAgVGltZWxpbmUucHJvdG90eXBlLl91cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIF91cGRhdGVDaGlsZHJlbihwLCB0aW1lLCBpc1lveW8pIHtcblx0ICAgIHZhciBjb2VmID0gdGltZSA+IHRoaXMuX3ByZXZUaW1lID8gLTEgOiAxO1xuXHQgICAgaWYgKHRoaXMuX3Byb3BzLmlzWW95byAmJiBpc1lveW8pIHtcblx0ICAgICAgY29lZiAqPSAtMTtcblx0ICAgIH1cblx0ICAgIHZhciB0aW1lVG9UaW1lbGluZXMgPSB0aGlzLl9wcm9wcy5zdGFydFRpbWUgKyBwICogdGhpcy5fcHJvcHMuZHVyYXRpb24sXG5cdCAgICAgICAgcHJldlRpbWVUb1RpbWVsaW5lcyA9IHRpbWVUb1RpbWVsaW5lcyArIGNvZWYsXG5cdCAgICAgICAgbGVuID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAvLyBzcGVjaWZ5IHRoZSBjaGlsZHJlbidzIGFycmF5IHVwZGF0ZSBsb29wIGRpcmVjdGlvblxuXHQgICAgICAvLyBpZiB0aW1lID4gcHJldlRpbWUgZ28gZnJvbSAwLT5sZW5ndGggZWxzZSBmcm9tIGxlbmd0aC0+MFxuXHQgICAgICAvLyB2YXIgaiA9ICggdGltZSA+IHRoaXMuX3ByZXZUaW1lICkgPyBpIDogKGxlbi0xKSAtIGkgO1xuXHQgICAgICB2YXIgaiA9IHRpbWVUb1RpbWVsaW5lcyA+IHByZXZUaW1lVG9UaW1lbGluZXMgPyBpIDogbGVuIC0gMSAtIGk7XG5cdCAgICAgIHRoaXMuX3RpbWVsaW5lc1tqXS5fdXBkYXRlKHRpbWVUb1RpbWVsaW5lcywgcHJldlRpbWVUb1RpbWVsaW5lcywgdGhpcy5fcHJldllveW8sIHRoaXMuX29uRWRnZSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9wcmV2WW95byA9IGlzWW95bztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsY3VsYXRlIHNlbGYgZHVyYXRpb24gYmFzZWQgb24gdGltZWxpbmUncyBkdXJhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gVHdlZW4gb3IgVGltZWxpbmUgdG8gY2FsY3VsYXRlLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcmVjYWxjRHVyYXRpb24gPSBmdW5jdGlvbiBfcmVjYWxjRHVyYXRpb24odGltZWxpbmUpIHtcblx0ICAgIHZhciBwID0gdGltZWxpbmUuX3Byb3BzLFxuXHQgICAgICAgIHRpbWVsaW5lVGltZSA9IHAucmVwZWF0VGltZSAvIHAuc3BlZWQgKyAocC5zaGlmdFRpbWUgfHwgMCkgKyB0aW1lbGluZS5fbmVnYXRpdmVTaGlmdDtcblxuXHQgICAgdGhpcy5fcHJvcHMuZHVyYXRpb24gPSBNYXRoLm1heCh0aW1lbGluZVRpbWUsIHRoaXMuX3Byb3BzLmR1cmF0aW9uKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsY3VsYXRlIHNlbGYgZHVyYXRpb24gZnJvbSBza3JldGNoLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3JlY2FsY1RvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiBfcmVjYWxjVG90YWxEdXJhdGlvbigpIHtcblx0ICAgIHZhciBpID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblx0ICAgIHRoaXMuX3Byb3BzLmR1cmF0aW9uID0gMDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAgdmFyIHRtID0gdGhpcy5fdGltZWxpbmVzW2ldO1xuXHQgICAgICAvLyByZWNhbGMgdG90YWwgZHVyYXRpb24gb24gY2hpbGQgdGltZWxpbmVzXG5cdCAgICAgIHRtLl9yZWNhbGNUb3RhbER1cmF0aW9uICYmIHRtLl9yZWNhbGNUb3RhbER1cmF0aW9uKCk7XG5cdCAgICAgIC8vIGFkZCB0aGUgdGltZWxpbmUncyBkdXJhdGlvbiB0byBzZWxmdCBkdXJhdGlvblxuXHQgICAgICB0aGlzLl9yZWNhbGNEdXJhdGlvbih0bSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9jYWxjRGltZW50aW9ucygpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCBzZXQgc3RhcnQgYW5kIGVuZCB0aW1lcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlciwgTnVsbH0gVGltZSB0byBzdGFydCB3aXRoLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc2V0U3RhcnRUaW1lID0gZnVuY3Rpb24gX3NldFN0YXJ0VGltZSh0aW1lKSB7XG5cdCAgICB2YXIgaXNSZXNldCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMV07XG5cblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuX3NldFN0YXJ0VGltZS5jYWxsKHRoaXMsIHRpbWUpO1xuXHQgICAgdGhpcy5fc3RhcnRUaW1lbGluZXModGhpcy5fcHJvcHMuc3RhcnRUaW1lLCBpc1Jlc2V0KTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgY2FsY3VsYXRlIHNlbGYgZHVyYXRpb24gYmFzZWQgb24gdGltZWxpbmUncyBkdXJhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge051bWJlciwgTnVsbH0gVGltZSB0byBzdGFydCB3aXRoLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fc3RhcnRUaW1lbGluZXMgPSBmdW5jdGlvbiBfc3RhcnRUaW1lbGluZXModGltZSkge1xuXHQgICAgdmFyIGlzUmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIGlzU3RvcCA9IHRoaXMuX3N0YXRlID09PSAnc3RvcCc7XG5cblx0ICAgIHRpbWUgPT0gbnVsbCAmJiAodGltZSA9IHRoaXMuX3Byb3BzLnN0YXJ0VGltZSk7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGltZWxpbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0bSA9IHRoaXMuX3RpbWVsaW5lc1tpXTtcblx0ICAgICAgdG0uX3NldFN0YXJ0VGltZSh0aW1lLCBpc1Jlc2V0KTtcblx0ICAgICAgLy8gaWYgZnJvbSBgX3N1YlBsYXlgIGFuZCBgX3ByZXZUaW1lYCBpcyBzZXQgYW5kIHN0YXRlIGlzIGBzdG9wYFxuXHQgICAgICAvLyBwcmV2VGltZSBub3JtYWxpemluZyBpcyBmb3IgcGxheS9wYXVzZSBmdW5jdGlvbmFsaXR5LCBzbyBub1xuXHQgICAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSBpZiB0aGUgdGltZWxpbmUgaXMgaW4gYHN0b3BgIHN0YXRlLlxuXHQgICAgICBpZiAoIWlzUmVzZXQgJiYgdG0uX3ByZXZUaW1lICE9IG51bGwgJiYgIWlzU3RvcCkge1xuXHQgICAgICAgIHRtLl9wcmV2VGltZSA9IHRtLl9ub3JtUHJldlRpbWVGb3J3YXJkKCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbGF1bmNoIG9uUmVmcmVzaCBjYWxsYmFjay5cblx0ICAgIEBtZXRob2QgX3JlZnJlc2hcblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgVHdlZW5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgcmVmcmVzaCBldmVuIGJlZm9yZSBzdGFydCB0aW1lLlxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fcmVmcmVzaCA9IGZ1bmN0aW9uIF9yZWZyZXNoKGlzQmVmb3JlKSB7XG5cdCAgICB2YXIgbGVuID0gdGhpcy5fdGltZWxpbmVzLmxlbmd0aDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgdGhpcy5fdGltZWxpbmVzW2ldLl9yZWZyZXNoKGlzQmVmb3JlKTtcblx0ICAgIH1cblx0ICAgIF9Ud2Vlbi5wcm90b3R5cGUuX3JlZnJlc2guY2FsbCh0aGlzLCBpc0JlZm9yZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIGRvIGRlY2xhcmUgZGVmYXVsdHMgYnkgdGhpcy5fZGVmYXVsdHMgb2JqZWN0XG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFRpbWVsaW5lLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24gX2RlY2xhcmVEZWZhdWx0cygpIHtcblx0ICAgIC8vIGlmIGR1cmF0aW9uIHdhcyBwYXNzZWQgb24gaW5pdGlhbGl6YXRpb24gc3RhZ2UsIHdhcm4gdXNlciBhbmQgcmVzZXQgaXQuXG5cdCAgICBpZiAodGhpcy5fby5kdXJhdGlvbiAhPSBudWxsKSB7XG5cdCAgICAgIF9oMi5kZWZhdWx0LmVycm9yKCdEdXJhdGlvbiBjYW4gbm90IGJlIGRlY2xhcmVkIG9uIFRpbWVsaW5lLCBidXQgXCInICsgdGhpcy5fby5kdXJhdGlvbiArICdcIiBpcy4gWW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIFR3ZWVuIGluc3RlYWQuJyk7XG5cdCAgICAgIHRoaXMuX28uZHVyYXRpb24gPSAwO1xuXHQgICAgfVxuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwodGhpcyk7XG5cdCAgICAvLyByZW1vdmUgZGVmYXVsdFxuXHQgICAgdGhpcy5fZGVmYXVsdHMuZHVyYXRpb24gPSAwO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMuZWFzaW5nID0gJ0xpbmVhci5Ob25lJztcblx0ICAgIHRoaXMuX2RlZmF1bHRzLmJhY2t3YXJkRWFzaW5nID0gJ0xpbmVhci5Ob25lJztcblx0ICAgIHRoaXMuX2RlZmF1bHRzLm5hbWVCYXNlID0gJ1RpbWVsaW5lJztcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gVGltZWxpbmUoKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVGltZWxpbmUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R3ZWVuLmNhbGwodGhpcywgbykpO1xuXHQgIH1cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgc29tZSB2YXJzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaW1lbGluZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3RpbWVsaW5lcyA9IFtdO1xuXHQgICAgX1R3ZWVuLnByb3RvdHlwZS5fdmFycy5jYWxsKHRoaXMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVGltZWxpbmU7XG5cdH0oX3R3ZWVuMi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBUaW1lbGluZTtcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgVHdlZW5lciA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBUd2VlbmVyKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVHdlZW5lcik7XG5cblx0ICAgIHRoaXMuX3ZhcnMoKTtcblx0ICAgIHRoaXMuX2xpc3RlblZpc2liaWxpdHlDaGFuZ2UoKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIFR3ZWVuZXIucHJvdG90eXBlLl92YXJzID0gZnVuY3Rpb24gX3ZhcnMoKSB7XG5cdCAgICB0aGlzLnR3ZWVucyA9IFtdO1xuXHQgICAgdGhpcy5fbG9vcCA9IHRoaXMuX2xvb3AuYmluZCh0aGlzKTtcblx0ICAgIHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZSA9IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZS5iaW5kKHRoaXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1haW4gYW5pbWF0aW9uIGxvb3AuIFNob3VsZCBoYXZlIG9ubHkgb25lIGNvbmN1cnJlbnQgbG9vcC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcmV0dXJucyB0aGlzXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcblx0ICAgIGlmICghdGhpcy5faXNSdW5uaW5nKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3VwZGF0ZSh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpO1xuXHQgICAgaWYgKCF0aGlzLnR3ZWVucy5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2xvb3ApO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IGFuaW1hdGlvbiBsb29wLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fc3RhcnRMb29wID0gZnVuY3Rpb24gX3N0YXJ0TG9vcCgpIHtcblx0ICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfTt0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXHQgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2xvb3ApO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzdG9wIGFuaW1hdGlvbiBsb29wLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fc3RvcExvb3AgPSBmdW5jdGlvbiBfc3RvcExvb3AoKSB7XG5cdCAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdXBkYXRlIGV2ZXJ5IHR3ZWVuL3RpbWVsaW5lIG9uIGFuaW1hdGlvbiBmcmFtZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUodGltZSkge1xuXHQgICAgdmFyIGkgPSB0aGlzLnR3ZWVucy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIC8vIGNhY2hlIHRoZSBjdXJyZW50IHR3ZWVuXG5cdCAgICAgIHZhciB0d2VlbiA9IHRoaXMudHdlZW5zW2ldO1xuXHQgICAgICBpZiAodHdlZW4gJiYgdHdlZW4uX3VwZGF0ZSh0aW1lKSA9PT0gdHJ1ZSkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlKHR3ZWVuKTtcblx0ICAgICAgICB0d2Vlbi5fb25Ud2VlbmVyRmluaXNoKCk7XG5cdCAgICAgICAgdHdlZW4uX3ByZXZUaW1lID0gdW5kZWZpbmVkO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGFkZCBhIFR3ZWVuL1RpbWVsaW5lIHRvIGxvb3AgcG9vbC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUd2Vlbi9UaW1lbGluZSB0byBhZGQuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHR3ZWVuKSB7XG5cdCAgICAvLyByZXR1cm4gaWYgdHdlZW4gaXMgYWxyZWFkeSBydW5uaW5nXG5cdCAgICBpZiAodHdlZW4uX2lzUnVubmluZykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0d2Vlbi5faXNSdW5uaW5nID0gdHJ1ZTtcblx0ICAgIHRoaXMudHdlZW5zLnB1c2godHdlZW4pO1xuXHQgICAgdGhpcy5fc3RhcnRMb29wKCk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHN0b3AgdXBkYXRpbmcgYWxsIHRoZSBjaGlsZCB0d2VlbnMvdGltZWxpbmVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG5cdCAgICB0aGlzLnR3ZWVucy5sZW5ndGggPSAwO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW1vdmUgc3BlY2lmaWMgdHdlZW4vdGltZWxpbmUgZm9ybSB1cGRhdGluZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHR3ZWVuKSB7XG5cdCAgICB2YXIgaW5kZXggPSB0eXBlb2YgdHdlZW4gPT09ICdudW1iZXInID8gdHdlZW4gOiB0aGlzLnR3ZWVucy5pbmRleE9mKHR3ZWVuKTtcblxuXHQgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICB0d2VlbiA9IHRoaXMudHdlZW5zW2luZGV4XTtcblx0ICAgICAgaWYgKHR3ZWVuKSB7XG5cdCAgICAgICAgdHdlZW4uX2lzUnVubmluZyA9IGZhbHNlO1xuXHQgICAgICAgIHRoaXMudHdlZW5zLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgdHdlZW4uX29uVHdlZW5lclJlbW92ZSgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5pdGlhbGl6ZSBldmVudCBsaXN0ZW5lcnMgdG8gdmlzaWJpbGl0eSBjaGFuZ2UgZXZlbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fbGlzdGVuVmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uIF9saXN0ZW5WaXNpYmlsaXR5Q2hhbmdlKCkge1xuXHQgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUhpZGRlbiA9IFwiaGlkZGVuXCI7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UgPSBcInZpc2liaWxpdHljaGFuZ2VcIjtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Lm1vekhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHQgICAgICB0aGlzLl92aXNpYmlsaXR5SGlkZGVuID0gXCJtb3pIaWRkZW5cIjtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZSA9IFwibW96dmlzaWJpbGl0eWNoYW5nZVwiO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUhpZGRlbiA9IFwibXNIaWRkZW5cIjtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZSA9IFwibXN2aXNpYmlsaXR5Y2hhbmdlXCI7XG5cdCAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcblx0ICAgICAgdGhpcy5fdmlzaWJpbGl0eUhpZGRlbiA9IFwid2Via2l0SGlkZGVuXCI7XG5cdCAgICAgIHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2UgPSBcIndlYmtpdHZpc2liaWxpdHljaGFuZ2VcIjtcblx0ICAgIH1cblxuXHQgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl92aXNpYmlsaXR5Q2hhbmdlLCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2UsIGZhbHNlKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdGhhdCB3aWxsIGZpcmUgb24gdmlzaWJpbGl0eSBjaGFuZ2UuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX29uVmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uIF9vblZpc2liaWxpdHlDaGFuZ2UoKSB7XG5cdCAgICBpZiAoZG9jdW1lbnRbdGhpcy5fdmlzaWJpbGl0eUhpZGRlbl0pIHtcblx0ICAgICAgdGhpcy5fc2F2ZVBsYXlpbmdUd2VlbnMoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX3Jlc3RvcmVQbGF5aW5nVHdlZW5zKCk7XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNhdmUgYWxsIHBsYXlpbmcgdHdlZW5zLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUd2VlbmVyLnByb3RvdHlwZS5fc2F2ZVBsYXlpbmdUd2VlbnMgPSBmdW5jdGlvbiBfc2F2ZVBsYXlpbmdUd2VlbnMoKSB7XG5cdCAgICB0aGlzLl9zYXZlZFR3ZWVucyA9IHRoaXMudHdlZW5zLnNsaWNlKDApO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zYXZlZFR3ZWVucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9zYXZlZFR3ZWVuc1tpXS5wYXVzZSgpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXN0b3JlIGFsbCBwbGF5aW5nIHR3ZWVucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5lci5wcm90b3R5cGUuX3Jlc3RvcmVQbGF5aW5nVHdlZW5zID0gZnVuY3Rpb24gX3Jlc3RvcmVQbGF5aW5nVHdlZW5zKCkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zYXZlZFR3ZWVucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9zYXZlZFR3ZWVuc1tpXS5yZXN1bWUoKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIFR3ZWVuZXI7XG5cdH0oKTtcblxuXHR2YXIgdCA9IG5ldyBUd2VlbmVyKCk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHQ7XG5cbi8qKiovIH0sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuXHR2YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBDbGFzcyB0byBkZWZpbmUgYSBtb2R1bGUgYW5jZXN0b3Jcblx0ICB3aXRoIHRpbWVsaW5lIGFuZCB0d2VlbiBvcHRpb25zIGFuZCBmdW5jdGlvbmFsaXR5LlxuXHQgIEFsbCBydW5hYmxlIG1vZHVsZXMgc2hvdWxkIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5cdCAgQGNsYXNzIFR3ZWVuYWJsZVxuXHQqL1xuXG5cdHZhciBUd2VlbmFibGUgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFR3ZWVuYWJsZSwgX01vZHVsZSk7XG5cblx0ICAvKlxuXHQgICAgYHBsYXlgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgc2hpZnQuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiBwbGF5KCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5wbGF5LmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcGxheUJhY2t3YXJkYCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBUaW1lIHNoaWZ0LlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBsYXlCYWNrd2FyZCA9IGZ1bmN0aW9uIHBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucGxheUJhY2t3YXJkLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcGF1c2VgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnBhdXNlLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgc3RvcGAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gWzAuLi4xXSBQcm9ncmVzcyB0byBzZXQgb24gc3RvcC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICpEZWZhdWx0KiBpcyBgMGAgaWYgYHBsYXlgXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgYDFgIGlmIGBwbGF5QkFja3dhcmRgLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5zdG9wLmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcmVzZXRgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBUd2VlbmFibGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnJlc2V0LmFwcGx5KHRoaXMudGltZWxpbmUsIGFyZ3VtZW50cyk7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBgcmVwbGF5YCBtZXRob2QgZm9yIHRoZSB0aW1lbGluZS5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5yZXBsYXkgPSBmdW5jdGlvbiByZXBsYXkoKSB7XG5cdCAgICB0aGlzLnRpbWVsaW5lLnJlcGxheS5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgYHJlcGxheWAgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucmVwbGF5QmFja3dhcmQgPSBmdW5jdGlvbiByZXBsYXlCYWNrd2FyZCgpIHtcblx0ICAgIHRoaXMudGltZWxpbmUucmVwbGF5QmFja3dhcmQuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGByZXN1bWVgIG1ldGhvZCBmb3IgdGhlIHRpbWVsaW5lLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFRpbWUgc2hpZnQuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgdGhpcy50aW1lbGluZS5yZXN1bWUuYXBwbHkodGhpcy50aW1lbGluZSwgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIGBzZXRQcm9ncmVzc2AgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcGFyYW0ge051bWJlcn0gWzAuLi4xXSBQcm9ncmVzcyB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHRoaXMuXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNldFByb2dyZXNzKCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5zZXRQcm9ncmVzcy5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgc2V0U3BlZWQgbWV0aG9kIGZvciB0aGUgdGltZWxpbmUuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gU3BlZWQgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbiBzZXRTcGVlZChzcGVlZCkge1xuXHQgICAgdGhpcy50aW1lbGluZS5zZXRTcGVlZC5hcHBseSh0aGlzLnRpbWVsaW5lLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgZnVuY3Rpb24gVHdlZW5hYmxlKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR3ZWVuYWJsZSk7XG5cblx0ICAgIC8vIHBpcGUgZnVuY3Rpb24gZm9yIF9vIG9iamVjdFxuXHQgICAgLy8gYmVmb3JlIGNyZWF0aW5nIHR3ZWVuL3RpbWVsaW5lXG5cblx0ICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX01vZHVsZS5jYWxsKHRoaXMsIG8pKTtcblx0ICAgIC8vIHN1cGVyIG9mIE1vZHVsZVxuXG5cblx0ICAgIF90aGlzLl90cmFuc2Zvcm1Ud2Vlbk9wdGlvbnMoKTtcblx0ICAgIC8vIG1ha2UgdHdlZW4gb25seSBpZiBpc1R3ZWVuTGVzcyBvcHRpb24gaXMgbm90IHNldFxuXHQgICAgIV90aGlzLl9vLmlzVHdlZW5MZXNzICYmIF90aGlzLl9tYWtlVHdlZW4oKTtcblx0ICAgIC8vIG1ha2UgdGltZWxpbmUgb25seSBpZiBpc1RpbWVsaW5lTGVzcyBvcHRpb24gaXMgbm90IHNldFxuXHQgICAgIV90aGlzLl9vLmlzVGltZWxpbmVMZXNzICYmIF90aGlzLl9tYWtlVGltZWxpbmUoKTtcblx0ICAgIHJldHVybiBfdGhpcztcblx0ICB9XG5cdCAgLypcblx0ICAgIFBsYWNlaG9sZGVyIG1ldGhvZCB0aGF0IHNob3VsZCBiZSBvdmVycmlkZWRcblx0ICAgIGFuZCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgdHdlZW4vdGltZWxpbmUgY3JlYXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuX3RyYW5zZm9ybVR3ZWVuT3B0aW9ucyA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1Ud2Vlbk9wdGlvbnMoKSB7fTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0d2Vlbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHdlZW5hYmxlLnByb3RvdHlwZS5fbWFrZVR3ZWVuID0gZnVuY3Rpb24gX21ha2VUd2VlbigpIHtcblx0ICAgIC8vIHBhc3MgY2FsbGJhY2tzIGNvbnRleHRcblx0ICAgIHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dCA9IHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzO1xuXHQgICAgdGhpcy50d2VlbiA9IG5ldyBfdHdlZW4yLmRlZmF1bHQodGhpcy5fbyk7XG5cdCAgICAvLyBtYWtlIHRpbWVsaW5lIHByb3BlcnR5IHBvaW50IHRvIHR3ZWVuIG9uZSBpcyBcIm5vIHRpbWVsaW5lXCIgbW9kZVxuXHQgICAgdGhpcy5fby5pc1RpbWVsaW5lTGVzcyAmJiAodGhpcy50aW1lbGluZSA9IHRoaXMudHdlZW4pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgdGltZWxpbmUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFRpbWVsaW5lJ3Mgb3B0aW9ucy5cblx0ICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgXCJ0aW1lbGluZVwiIHByb3BlcnR5IHdpdGhcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lbGluZSBvcHRpb25zLlxuXHQgICovXG5cblxuXHQgIFR3ZWVuYWJsZS5wcm90b3R5cGUuX21ha2VUaW1lbGluZSA9IGZ1bmN0aW9uIF9tYWtlVGltZWxpbmUoKSB7XG5cdCAgICAvLyBwYXNzIGNhbGxiYWNrcyBjb250ZXh0XG5cdCAgICB0aGlzLl9vLnRpbWVsaW5lID0gdGhpcy5fby50aW1lbGluZSB8fCB7fTtcblx0ICAgIHRoaXMuX28udGltZWxpbmUuY2FsbGJhY2tzQ29udGV4dCA9IHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzO1xuXHQgICAgdGhpcy50aW1lbGluZSA9IG5ldyBfdGltZWxpbmUyLmRlZmF1bHQodGhpcy5fby50aW1lbGluZSk7XG5cdCAgICAvLyBzZXQgdGhlIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCByZWFsIHRpbWVsaW5lIGlzIHByZXNlbnRcblx0ICAgIHRoaXMuX2lzVGltZWxpbmUgPSB0cnVlO1xuXHQgICAgLy8gaWYgdHdlZW4gZXhpc3QgLSBhZGQgaXQgdG8gdGhlIHRpbWVsaW5lIHRoZXJlIGlzIHNvbWVcblx0ICAgIC8vIG1vZHVsZXMgbGlrZSBidXJzdCBhbmQgc3RhZ2dlciB0aGF0IGhhdmUgbm8gdHdlZW5cblx0ICAgIHRoaXMudHdlZW4gJiYgdGhpcy50aW1lbGluZS5hZGQodGhpcy50d2Vlbik7XG5cdCAgfTtcblxuXHQgIHJldHVybiBUd2VlbmFibGU7XG5cdH0oX21vZHVsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVHdlZW5hYmxlO1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfa2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5cdHZhciBfa2V5czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9rZXlzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX3R3ZWVuYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cdHZhciBfdHdlZW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuYWJsZSk7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBUaGUgVGhlbmFibGUgY2xhc3MgYWRkcyAudGhlbiBwdWJsaWMgbWV0aG9kIGFuZFxuXHQgIHRoZSBhYmlsaXR5IHRvIGNoYWluIEFQSSBjYWxscy5cblx0Ki9cblxuXHR2YXIgVGhlbmFibGUgPSBmdW5jdGlvbiAoX1R3ZWVuYWJsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKFRoZW5hYmxlLCBfVHdlZW5hYmxlKTtcblxuXHQgIGZ1bmN0aW9uIFRoZW5hYmxlKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgVGhlbmFibGUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX1R3ZWVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBhIHRoZW4gcmVjb3JkIGZvciB0aGUgbW9kdWxlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtICAgIHtPYmplY3R9IE9wdGlvbnMgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbi5cblx0ICAgIEByZXR1cm5zICB7T2JqZWN0fSB0aGlzLlxuXHQgICovXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4obykge1xuXHQgICAgLy8gcmV0dXJuIGlmIG5vdGhpbmcgd2FzIHBhc3NlZFxuXHQgICAgaWYgKG8gPT0gbnVsbCB8fCAhKDAsIF9rZXlzMi5kZWZhdWx0KShvKS5sZW5ndGgpIHtcblx0ICAgICAgcmV0dXJuIDE7XG5cdCAgICB9XG5cdCAgICAvLyBtZXJnZSB0aGVuIG9wdGlvbnMgd2l0aCB0aGUgY3VycmVudCBvbmVzXG5cdCAgICB2YXIgcHJldlJlY29yZCA9IHRoaXMuX2hpc3RvcnlbdGhpcy5faGlzdG9yeS5sZW5ndGggLSAxXSxcblx0ICAgICAgICBwcmV2TW9kdWxlID0gdGhpcy5fbW9kdWxlc1t0aGlzLl9tb2R1bGVzLmxlbmd0aCAtIDFdLFxuXHQgICAgICAgIG1lcmdlZCA9IHRoaXMuX21lcmdlVGhlbk9wdGlvbnMocHJldlJlY29yZCwgbyk7XG5cblx0ICAgIHRoaXMuX3Jlc2V0TWVyZ2VkRmxhZ3MobWVyZ2VkKTtcblx0ICAgIC8vIGNyZWF0ZSBhIHN1Ym1vZHVsZSBvZiB0aGUgc2FtZSB0eXBlIGFzIHRoZSBtYXN0ZXIgbW9kdWxlXG5cdCAgICB2YXIgbW9kdWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IobWVyZ2VkKTtcblx0ICAgIC8vIHNldCBgdGhpc2AgYXMgYW1zdGVyIG1vZHVsZSBvZiBjaGlsZCBtb2R1bGVcblx0ICAgIG1vZHVsZS5fbWFzdGVyTW9kdWxlID0gdGhpcztcblx0ICAgIC8vIHNhdmUgdGhlIG1vZHVsZXMgdG8gdGhlIF9tb2R1bGVzIGFycmF5XG5cdCAgICB0aGlzLl9tb2R1bGVzLnB1c2gobW9kdWxlKTtcblx0ICAgIC8vIGFkZCBtb2R1bGUncyB0d2VlbiBpbnRvIG1hc3RlciB0aW1lbGluZVxuXHQgICAgdGhpcy50aW1lbGluZS5hcHBlbmQobW9kdWxlKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIF4gUFVCTElDICBNRVRIT0QoUykgXlxuXHQgIC8vIHYgUFJJVkFURSBNRVRIT0QoUykgdlxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCBzb21lIGZsYWdzIG9uIG1lcmdlZCBvcHRpb25zIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0gICB7T2JqZWN0fSBPcHRpb25zIG9iamVjdC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fcmVzZXRNZXJnZWRGbGFncyA9IGZ1bmN0aW9uIF9yZXNldE1lcmdlZEZsYWdzKG9iaikge1xuXHQgICAgLy8gc2V0IHRoZSBzdWJtb2R1bGUgdG8gYmUgd2l0aG91dCB0aW1lbGluZSBmb3IgcGVyZiByZWFzb25zXG5cdCAgICBvYmouaXNUaW1lbGluZUxlc3MgPSB0cnVlO1xuXHQgICAgLy8gcmVzZXQgaXNTaG93U3RhcnQgZmxhZyBmb3IgdGhlIHN1Ym1vZHVsZXNcblx0ICAgIG9iai5pc1Nob3dTdGFydCA9IGZhbHNlO1xuXHQgICAgLy8gcmVzZXQgaXNSZWZyZXNoU3RhdGUgZmxhZyBmb3IgdGhlIHN1Ym1vZHVsZXNcblx0ICAgIG9iai5pc1JlZnJlc2hTdGF0ZSA9IGZhbHNlO1xuXHQgICAgLy8gc2V0IHRoZSBzdWJtb2R1bGUgY2FsbGJhY2tzIGNvbnRleHRcblx0ICAgIG9iai5jYWxsYmFja3NDb250ZXh0ID0gdGhpcy5fcHJvcHMuY2FsbGJhY2tzQ29udGV4dCB8fCB0aGlzO1xuXHQgICAgLy8gc2V0IHByZXZpb3VzIG1vZHVsZVxuXHQgICAgb2JqLnByZXZDaGFpbk1vZHVsZSA9IF9oMi5kZWZhdWx0LmdldExhc3RJdGVtKHRoaXMuX21vZHVsZXMpO1xuXHQgICAgLy8gcGFzcyB0aGUgYHRoaXNgIGFzIG1hc3RlciBtb2R1bGVcblx0ICAgIG9iai5tYXN0ZXJNb2R1bGUgPSB0aGlzO1xuXHQgICAgcmV0dXJuIG9iajtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gaW5pdGlhbGl6ZSBwcm9wZXJ0aWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIF9Ud2VlbmFibGUucHJvdG90eXBlLl92YXJzLmNhbGwodGhpcyk7XG5cdCAgICAvLyBzYXZlIF9tYXN0ZXIgbW9kdWxlXG5cdCAgICB0aGlzLl9tYXN0ZXJNb2R1bGUgPSB0aGlzLl9vLm1hc3Rlck1vZHVsZTtcblx0ICAgIC8vIHNldCBpc0NoYWluZWQgZmxhZyBiYXNlZCBvbiBwcmV2Q2hhaW5Nb2R1bGUgb3B0aW9uXG5cdCAgICB0aGlzLl9pc0NoYWluZWQgPSAhIXRoaXMuX21hc3Rlck1vZHVsZTtcblx0ICAgIC8vIHdlIGFyZSBleHBlY3QgdGhhdCB0aGUgX28gb2JqZWN0XG5cdCAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBleHRlbmRlZCBieSBkZWZhdWx0c1xuXHQgICAgdmFyIGluaXRpYWxSZWNvcmQgPSBfaDIuZGVmYXVsdC5jbG9uZU9iaih0aGlzLl9wcm9wcyk7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCkge1xuXHQgICAgICBpZiAodGhpcy5fb1trZXldKSB7XG5cdCAgICAgICAgdmFyIHByZVBhcnNlZCA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShrZXksIHRoaXMuX29ba2V5XSk7XG5cdCAgICAgICAgaW5pdGlhbFJlY29yZFtrZXldID0gcHJlUGFyc2VkO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2hpc3RvcnkgPSBbaW5pdGlhbFJlY29yZF07XG5cdCAgICAvLyB0aGUgYXJyYXkgaG9sZHMgYWxsIG1vZHVsZXMgaW4gdGhlIHRoZW4gY2hhaW5cblx0ICAgIHRoaXMuX21vZHVsZXMgPSBbdGhpc107XG5cdCAgICAvLyB0aGUgcHJvcHMgdGhhdCB0byBleGNsdWRlIGZyb20gdGhlbiBtZXJnZVxuXHQgICAgdGhpcy5fbm9uTWVyZ2VQcm9wcyA9IHsgc2hhcGU6IDEgfTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gbWVyZ2UgdHdvIG9wdGlvbnMgaW50byBvbmUuIFVzZWQgaW4gLnRoZW4gY2hhaW5zLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIGZvciB0aGUgbWVyZ2UuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gRW5kIG9wdGlvbnMgZm9yIHRoZSBtZXJnZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE1lcmdlZCBvcHRpb25zLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fbWVyZ2VUaGVuT3B0aW9ucyA9IGZ1bmN0aW9uIF9tZXJnZVRoZW5PcHRpb25zKHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBvID0ge307XG5cdCAgICB0aGlzLl9tZXJnZVN0YXJ0TG9vcChvLCBzdGFydCk7XG5cdCAgICB0aGlzLl9tZXJnZUVuZExvb3Aobywgc3RhcnQsIGVuZCk7XG5cdCAgICB0aGlzLl9oaXN0b3J5LnB1c2gobyk7XG5cdCAgICByZXR1cm4gbztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGlwZSBzdGFydFZhbHVlIG9mIHRoZSBkZWx0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gU3RhcnQgcHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBTdGFydCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtBbnl9IFN0YXJ0IHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIFRoZW5hYmxlLnByb3RvdHlwZS5fY2hlY2tTdGFydFZhbHVlID0gZnVuY3Rpb24gX2NoZWNrU3RhcnRWYWx1ZShuYW1lLCB2YWx1ZSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE9yaWdpbmFsbHkgcGFydCBvZiB0aGUgX21lcmdlVGhlbk9wdGlvbnMuXG5cdCAgICBMb29wcyB0aHJ1IHN0YXJ0IG9iamVjdCBhbmQgY29waWVzIGFsbCB0aGUgcHJvcHMgZnJvbSBpdC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgdG8gY29weSBpbi5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIG9iamVjdC5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX21lcmdlU3RhcnRMb29wID0gZnVuY3Rpb24gX21lcmdlU3RhcnRMb29wKG8sIHN0YXJ0KSB7XG5cdCAgICAvLyBsb29wIHRocnUgc3RhcnQgb3B0aW9ucyBvYmplY3Rcblx0ICAgIGZvciAodmFyIGtleSBpbiBzdGFydCkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBzdGFydFtrZXldO1xuXHQgICAgICBpZiAoc3RhcnRba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH07XG5cdCAgICAgIC8vIGNvcHkgYWxsIHZhbHVlcyBmcm9tIHN0YXJ0IGlmIG5vdCB0d2VlbiBwcm9wIG9yIGR1cmF0aW9uXG5cdCAgICAgIGlmICghX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSB8fCBrZXkgPT09ICdkdXJhdGlvbicpIHtcblx0ICAgICAgICAvLyBpZiBkZWx0YSAtIGNvcHkgb25seSB0aGUgZW5kIHZhbHVlXG5cdCAgICAgICAgaWYgKHRoaXMuX2lzRGVsdGEodmFsdWUpKSB7XG5cdCAgICAgICAgICBvW2tleV0gPSBfaDIuZGVmYXVsdC5nZXREZWx0YUVuZCh2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE9yaWdpbmFsbHkgcGFydCBvZiB0aGUgX21lcmdlVGhlbk9wdGlvbnMuXG5cdCAgICBMb29wcyB0aHJ1IHN0YXJ0IG9iamVjdCBhbmQgbWVyZ2VzIGFsbCB0aGUgcHJvcHMgZnJvbSBpdC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgdG8gY29weSBpbi5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBTdGFydCBvcHRpb25zIG9iamVjdC5cblx0ICAgIEBwYXJtYSB7T2JqZWN0fSBFbmQgb3B0aW9ucyBvYmplY3QuXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9tZXJnZUVuZExvb3AgPSBmdW5jdGlvbiBfbWVyZ2VFbmRMb29wKG8sIHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBlbmRLZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShlbmQpO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gZW5kKSB7XG5cdCAgICAgIC8vIGp1c3QgY29weSBwYXJlbnQgb3B0aW9uXG5cdCAgICAgIGlmIChrZXkgPT0gJ3BhcmVudCcpIHtcblx0ICAgICAgICBvW2tleV0gPSBlbmRba2V5XTtjb250aW51ZTtcblx0ICAgICAgfTtcblxuXHQgICAgICAvLyBnZXQga2V5L3ZhbHVlIG9mIHRoZSBlbmQgb2JqZWN0XG5cdCAgICAgIC8vIGVuZEtleSAtIG5hbWUgb2YgdGhlIHByb3BlcnR5LCBlbmRWYWx1ZSAtIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuXHQgICAgICB2YXIgZW5kVmFsdWUgPSBlbmRba2V5XSxcblx0ICAgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydFtrZXldICE9IG51bGwgPyBzdGFydFtrZXldIDogdGhpcy5fZGVmYXVsdHNba2V5XTtcblxuXHQgICAgICBzdGFydFZhbHVlID0gdGhpcy5fY2hlY2tTdGFydFZhbHVlKGtleSwgc3RhcnRWYWx1ZSk7XG5cdCAgICAgIGlmIChlbmRWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgY29udGludWU7XG5cdCAgICAgIH07XG5cdCAgICAgIC8vIG1ha2Ug4oiGIG9mIHN0YXJ0IC0+IGVuZFxuXHQgICAgICAvLyBpZiBrZXkgbmFtZSBpcyByYWRpdXNYL3JhZGl1c1kgYW5kXG5cdCAgICAgIC8vIHRoZSBzdGFydFZhbHVlIGlzIG5vdCBzZXQgZmFsbGJhY2sgdG8gcmFkaXVzIHZhbHVlXG5cdCAgICAgIHZhciBpc1N1YlJhZGl1cyA9IGtleSA9PT0gJ3JhZGl1c1gnIHx8IGtleSA9PT0gJ3JhZGl1c1knO1xuXHQgICAgICBpZiAoaXNTdWJSYWRpdXMgJiYgc3RhcnRWYWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgc3RhcnRWYWx1ZSA9IHN0YXJ0LnJhZGl1cztcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBpc1N1YlJhZGl1cyA9IGtleSA9PT0gJ3NjYWxlWCcgfHwga2V5ID09PSAnc2NhbGVZJztcblx0ICAgICAgaWYgKGlzU3ViUmFkaXVzICYmIHN0YXJ0VmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgIHN0YXJ0VmFsdWUgPSBzdGFydC5zY2FsZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIG9ba2V5XSA9IHRoaXMuX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBtZXJnZSBgc3RhcnRgIGFuZCBgZW5kYCBmb3IgYSBwcm9wZXJ0eSBpbiB0aGVuIHJlY29yZC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSAgICBTdGFydCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgRW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX21lcmdlVGhlblByb3BlcnR5ID0gZnVuY3Rpb24gX21lcmdlVGhlblByb3BlcnR5KGtleSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUpIHtcblx0ICAgIC8vIGlmIGlzbnQgdHdlZW4gcHJvcGVydHlcblx0ICAgIHZhciBpc0Jvb2xlYW4gPSB0eXBlb2YgZW5kVmFsdWUgPT09ICdib29sZWFuJyxcblx0ICAgICAgICBjdXJ2ZSxcblx0ICAgICAgICBlYXNpbmc7XG5cblx0ICAgIGlmICghX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSAmJiAhdGhpcy5fbm9uTWVyZ2VQcm9wc1trZXldICYmICFpc0Jvb2xlYW4pIHtcblxuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuaXNPYmplY3QoZW5kVmFsdWUpICYmIGVuZFZhbHVlLnRvICE9IG51bGwpIHtcblx0ICAgICAgICBjdXJ2ZSA9IGVuZFZhbHVlLmN1cnZlO1xuXHQgICAgICAgIGVhc2luZyA9IGVuZFZhbHVlLmVhc2luZztcblx0ICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnRvO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gaWYgZW5kIHZhbHVlIGlzIGRlbHRhIC0ganVzdCBzYXZlIGl0XG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKGVuZFZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9wYXJzZURlbHRhVmFsdWVzKGtleSwgZW5kVmFsdWUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBwYXJzZWRFbmRWYWx1ZSA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShrZXksIGVuZFZhbHVlKTtcblx0ICAgICAgICAvLyBpZiBlbmQgdmFsdWUgaXMgbm90IGRlbHRhIC0gbWVyZ2Ugd2l0aCBzdGFydCB2YWx1ZVxuXHQgICAgICAgIGlmICh0aGlzLl9pc0RlbHRhKHN0YXJ0VmFsdWUpKSB7XG5cdCAgICAgICAgICB2YXIgX3JlZjtcblxuXHQgICAgICAgICAgLy8gaWYgc3RhcnQgdmFsdWUgaXMgZGVsdGEgLSB0YWtlIHRoZSBlbmQgdmFsdWVcblx0ICAgICAgICAgIC8vIGFzIHN0YXJ0IHZhbHVlIG9mIHRoZSBuZXcgZGVsdGFcblx0ICAgICAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQoc3RhcnRWYWx1ZSldID0gcGFyc2VkRW5kVmFsdWUsIF9yZWYuZWFzaW5nID0gZWFzaW5nLCBfcmVmLmN1cnZlID0gY3VydmUsIF9yZWY7XG5cdCAgICAgICAgICAvLyBpZiBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWUgYXJlIG5vdCDiiIYgLSBtYWtlIOKIhlxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBfcmVmMjtcblxuXHQgICAgICAgICAgICByZXR1cm4gX3JlZjIgPSB7fSwgX3JlZjJbc3RhcnRWYWx1ZV0gPSBwYXJzZWRFbmRWYWx1ZSwgX3JlZjIuZWFzaW5nID0gZWFzaW5nLCBfcmVmMi5jdXJ2ZSA9IGN1cnZlLCBfcmVmMjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICAvLyBjb3B5IHRoZSB0d2VlbiB2YWx1ZXMgdW5hdHRlbmRlZFxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gZW5kVmFsdWU7XG5cdCAgICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmV0cmVpdmUgYXJyYXkncyBsZW5ndGggYW5kIHJldHVybiAtMSBmb3Jcblx0ICAgIGFsbCBvdGhlciB0eXBlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FycmF5LCBBbnl9IEFycmF5IHRvIGdldCB0aGUgd2lkdGggZm9yLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gQXJyYXkgbGVuZ3RoIG9yIC0xIGlmIG5vdCBhcnJheS5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX2dldEFycmF5TGVuZ3RoID0gZnVuY3Rpb24gX2dldEFycmF5TGVuZ3RoKGFycikge1xuXHQgICAgcmV0dXJuIF9oMi5kZWZhdWx0LmlzQXJyYXkoYXJyKSA/IGFyci5sZW5ndGggOiAtMTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IGlzIGRlbHRhIHByb3BlcnR5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QW55fSBQYXJhbWV0ZXIgdmFsdWUgdG8gY2hlY2suXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX2lzRGVsdGEgPSBmdW5jdGlvbiBfaXNEZWx0YShvcHRpb25zVmFsdWUpIHtcblx0ICAgIHZhciBpc09iamVjdCA9IF9oMi5kZWZhdWx0LmlzT2JqZWN0KG9wdGlvbnNWYWx1ZSk7XG5cdCAgICBpc09iamVjdCA9IGlzT2JqZWN0ICYmICFvcHRpb25zVmFsdWUudW5pdDtcblx0ICAgIHJldHVybiAhKCFpc09iamVjdCB8fCBfaDIuZGVmYXVsdC5pc0FycmF5KG9wdGlvbnNWYWx1ZSkgfHwgX2gyLmRlZmF1bHQuaXNET00ob3B0aW9uc1ZhbHVlKSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBtb2R1bGUgaXMgZmlyc3QgaW4gYHRoZW5gIGNoYWluLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgbW9kdWxlIGlzIHRoZSBmaXJzdCBpbiBtb2R1bGUgY2hhaW4uXG5cdCAgKi9cblxuXG5cdCAgVGhlbmFibGUucHJvdG90eXBlLl9pc0ZpcnN0SW5DaGFpbiA9IGZ1bmN0aW9uIF9pc0ZpcnN0SW5DaGFpbigpIHtcblx0ICAgIHJldHVybiAhdGhpcy5fbWFzdGVyTW9kdWxlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB0aGUgbW9kdWxlIGlzIGxhc3QgaW4gYHRoZW5gIGNoYWluLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgbW9kdWxlIGlzIHRoZSBsYXN0IGluIG1vZHVsZSBjaGFpbi5cblx0ICAqL1xuXG5cblx0ICBUaGVuYWJsZS5wcm90b3R5cGUuX2lzTGFzdEluQ2hhaW4gPSBmdW5jdGlvbiBfaXNMYXN0SW5DaGFpbigpIHtcblx0ICAgIHZhciBtYXN0ZXIgPSB0aGlzLl9tYXN0ZXJNb2R1bGU7XG5cdCAgICAvLyBpZiB0aGVyZSBpcyBubyBtYXN0ZXIgZmllbGQgLSBjaGVjayB0aGUgbW9kdWxlcyBsZW5ndGhcblx0ICAgIC8vIGlmIG1vZHVsZSBsZW5ndGggaXMgMSB0aHVzIHRoZXJlIGlzIG5vIG1vZHVsZXMgY2hhaW5cblx0ICAgIC8vIGl0IGlzIHRoZSBsYXN0IG9uZSwgb3RoZXJ3aXNlIGl0IGlzbnRcblx0ICAgIGlmICghbWFzdGVyKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9tb2R1bGVzLmxlbmd0aCA9PT0gMTtcblx0ICAgIH1cblx0ICAgIC8vIGlmIHRoZXJlIGlzIG1hc3RlciAtIGNoZWNrIGlmIGl0IGlzIHRoZSBsYXN0IGl0ZW0gaW4gX21vZHVsZXMgY2hhaW5cblx0ICAgIHJldHVybiB0aGlzID09PSBfaDIuZGVmYXVsdC5nZXRMYXN0SXRlbShtYXN0ZXIuX21vZHVsZXMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gVGhlbmFibGU7XG5cdH0oX3R3ZWVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVGhlbmFibGU7XG5cbi8qKiovIH0sXG4vKiAxMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cblx0dmFyIF9rZXlzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleXMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHR2YXIgX3RoZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cblx0dmFyIF90aGVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVuYWJsZSk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgVHVuZWFibGUgPSBmdW5jdGlvbiAoX1RoZW5hYmxlKSB7XG5cdCAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoVHVuZWFibGUsIF9UaGVuYWJsZSk7XG5cblx0ICBmdW5jdGlvbiBUdW5lYWJsZSgpIHtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFR1bmVhYmxlKTtcblx0ICAgIHJldHVybiAoMCwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zLmRlZmF1bHQpKHRoaXMsIF9UaGVuYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aCBvcHRpb25hbCBuZXcgb3B0aW9ucy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byBzZXQgb24gdGhlIHJ1bi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IHRoaXMuXG5cdCAgKi9cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS50dW5lID0gZnVuY3Rpb24gdHVuZShvKSB7XG5cdCAgICAvLyBpZiBvcHRpb25zIG9iamVjdCB3YXMgcGFzc2VkXG5cdCAgICBpZiAobyAmJiAoMCwgX2tleXMyLmRlZmF1bHQpKG8pLmxlbmd0aCkge1xuXHQgICAgICB0aGlzLl90cmFuc2Zvcm1IaXN0b3J5KG8pO1xuXHQgICAgICB0aGlzLl90dW5lTmV3T3B0aW9ucyhvKTtcblx0ICAgICAgLy8gcmVzdG9yZSBhcnJheSBwcm9wIHZhbHVlcyBiZWNhdXNlIF9wcm9wc1xuXHQgICAgICAvLyBjb250YWluIHRoZW0gYXMgcGFyc2VkIGFycmF5c1xuXHQgICAgICAvLyBidXQgd2UgbmVlZCB0aGUgYXMgc3RyaW5ncyB0byBzdG9yZSBpbiBoaXN0b3J5XG5cdCAgICAgIC8vIGFuZCBtZXJnZSBpbiBoaXN0b3J5IGNoYWluc1xuXHQgICAgICB0aGlzLl9oaXN0b3J5WzBdID0gX2gyLmRlZmF1bHQuY2xvbmVPYmoodGhpcy5fcHJvcHMpO1xuXHQgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fYXJyYXlQcm9wZXJ0eU1hcCkge1xuXHQgICAgICAgIGlmIChvW2tleV0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgdGhpcy5faGlzdG9yeVswXVtrZXldID0gdGhpcy5fcHJlcGFyc2VQcm9wVmFsdWUoa2V5LCBvW2tleV0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMuX3R1bmVTdWJNb2R1bGVzKCk7XG5cdCAgICAgIHRoaXMuX3Jlc2V0VHdlZW5zKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcmVnZW5lcmF0ZSBhbGwgdGhlIHJhbmRvbSBwcm9wZXJ0aWVzIGZvcm0gaW5pdGlhbCBvYmplY3QuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKCkge1xuXHQgICAgcmV0dXJuIHRoaXMudHVuZSh0aGlzLl9vKTtcblx0ICB9O1xuXG5cdCAgLy8gXiBQVUJMSUMgIE1FVEhPRChTKSBeXG5cdCAgLy8gdiBQUklWQVRFIE1FVEhPRChTKSB2XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHByZXBhcnNlIG9wdGlvbnMgaW4gb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgdG8gcHJlcGFyc2UgcHJvcGVydGllcyBvbi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhc3NlZCBvYmplY3Qgd2l0aCBwcmVwYXJzZWQgcHJvcHMuXG5cdCAgKi9cblx0ICAvLyBfcHJlUGFyc2VPcHRpb25zICggbyApIHtcblx0ICAvLyAgIGZvciAodmFyIGtleSBpbiBvKSB7XG5cdCAgLy8gICAgIG9ba2V5XSA9IHRoaXMuX3ByZXBhcnNlUHJvcFZhbHVlKCBrZXksIG9ba2V5XSApO1xuXHQgIC8vICAgfVxuXHQgIC8vICAgcmV0dXJuIG87XG5cdCAgLy8gfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHJhbnNmb3JtIGhpc3RvcnkgcmV3cml0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY2hhaW4gb24gcnVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBOZXcgb3B0aW9ucyB0byB0dW5lIGZvci5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3RyYW5zZm9ybUhpc3RvcnkgPSBmdW5jdGlvbiBfdHJhbnNmb3JtSGlzdG9yeShvKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBvW2tleV07XG5cdCAgICAgIC8vIGRvbid0IHRyYW5zZm9ybSBmb3IgY2hpbGRPcHRpb25zXG5cdCAgICAgIC8vIGlmICgga2V5ID09PSAnY2hpbGRPcHRpb25zJyApIHsgY29udGludWU7IH1cblx0ICAgICAgdGhpcy5fdHJhbnNmb3JtSGlzdG9yeUZvcihrZXksIHRoaXMuX3ByZXBhcnNlUHJvcFZhbHVlKGtleSwgdmFsdWUpKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHJhbnNmb3JtIGhpc3RvcnkgY2hhaW4gZm9yIHNwZWNpZmljIGtleS92YWx1ZS5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byB0cmFuc2Zvcm0gaGlzdG9yeSBmb3IuXG5cdCAgICBAcGFyYW0ge0FueX0gVGhlIG5ldyBwcm9wZXJ0eSdzIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIFR1bmVhYmxlLnByb3RvdHlwZS5fdHJhbnNmb3JtSGlzdG9yeUZvciA9IGZ1bmN0aW9uIF90cmFuc2Zvcm1IaXN0b3J5Rm9yKGtleSwgdmFsdWUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faGlzdG9yeS5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodmFsdWUgPSB0aGlzLl90cmFuc2Zvcm1IaXN0b3J5UmVjb3JkKGksIGtleSwgdmFsdWUpKSB7XG5cdCAgICAgICAgLy8gYnJlYWsgaWYgbm8gZnVydGhlciBoaXN0b3J5IG1vZGlmaWNhdGlvbnMgbmVlZGVkXG5cdCAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0cmFuc2Zvcm0gaGlzdG9yeSByZWNvZCB3aXRoIGtleS92YWx1ZS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgaGlzdG9yeSByZWNvcmQgdG8gdHJhbnNmb3JtLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUgdG8gdHJhbnNmb3JtLlxuXHQgICAgQHBhcmFtIHtBbnl9IFByb3BlcnR5IHZhbHVlIHRvIHRyYW5zZm9ybSB0by5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0aGUgY3VycmVudCBoaXN0b3J5IHJlY29yZC5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25hbCB0aGUgbmV4dCBoaXN0b3J5IHJlY29yZC5cblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgbm8gZnVydGhlclxuXHQgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkgbW9kaWZpY2F0aW9ucyBpcyBuZWVkZWQuXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl90cmFuc2Zvcm1IaXN0b3J5UmVjb3JkID0gZnVuY3Rpb24gX3RyYW5zZm9ybUhpc3RvcnlSZWNvcmQoaW5kZXgsIGtleSwgbmV3VmFsLCBjdXJyUmVjb3JkLCBuZXh0UmVjb3JkKSB7XG5cdCAgICAvLyBuZXdWYWwgPSB0aGlzLl9wYXJzZVByb3BlcnR5KCBrZXksIG5ld1ZhbCApO1xuXHQgICAgaWYgKG5ld1ZhbCA9PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICAvLyBmYWxsYmFjayB0byBoaXN0b3J5IHJlY29yZHMsIGlmIHdhc24ndCBzcGVjaWZpZWRcblx0ICAgIGN1cnJSZWNvcmQgPSBjdXJyUmVjb3JkID09IG51bGwgPyB0aGlzLl9oaXN0b3J5W2luZGV4XSA6IGN1cnJSZWNvcmQ7XG5cdCAgICBuZXh0UmVjb3JkID0gbmV4dFJlY29yZCA9PSBudWxsID8gdGhpcy5faGlzdG9yeVtpbmRleCArIDFdIDogbmV4dFJlY29yZDtcblxuXHQgICAgdmFyIG9sZFZhbCA9IGN1cnJSZWNvcmRba2V5XSxcblx0ICAgICAgICBuZXh0VmFsID0gbmV4dFJlY29yZCA9PSBudWxsID8gbnVsbCA6IG5leHRSZWNvcmRba2V5XTtcblxuXHQgICAgLy8gaWYgaW5kZXggaXMgMCAtIGFsd2F5cyBzYXZlIHRoZSBuZXdWYWxcblx0ICAgIC8vIGFuZCByZXR1cm4gbm9uLWRlbHRhIGZvciBzdWJzZXF1ZW50IG1vZGlmaWNhdGlvbnNcblx0ICAgIGlmIChpbmRleCA9PT0gMCkge1xuXHQgICAgICBjdXJyUmVjb3JkW2tleV0gPSBuZXdWYWw7XG5cdCAgICAgIC8vIGFsd2F5cyByZXR1cm4gb24gdHdlZW4gcHJvcGVydGllc1xuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuaXNUd2VlblByb3Aoa2V5KSAmJiBrZXkgIT09ICdkdXJhdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgfVxuXHQgICAgICAvLyBub250d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICAgIHZhciBpc1Jld3JpdGVOZXh0ID0gdGhpcy5faXNSZXdyaXRlTmV4dChvbGRWYWwsIG5leHRWYWwpLFxuXHQgICAgICAgICAgcmV0dXJuVmFsID0gdGhpcy5faXNEZWx0YShuZXdWYWwpID8gX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQobmV3VmFsKSA6IG5ld1ZhbDtcblx0ICAgICAgcmV0dXJuIGlzUmV3cml0ZU5leHQgPyByZXR1cm5WYWwgOiBudWxsO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gaWYgd2FzIGRlbHRhIGFuZCBjYW1lIG5vbmUtZGVsdHRhIC0gcmV3cml0ZVxuXHQgICAgICAvLyB0aGUgc3RhcnQgb2YgdGhlIGRlbHRhIGFuZCBzdG9wXG5cdCAgICAgIGlmICh0aGlzLl9pc0RlbHRhKG9sZFZhbCkpIHtcblx0ICAgICAgICB2YXIgX2N1cnJSZWNvcmQka2V5O1xuXG5cdCAgICAgICAgY3VyclJlY29yZFtrZXldID0gKF9jdXJyUmVjb3JkJGtleSA9IHt9LCBfY3VyclJlY29yZCRrZXlbbmV3VmFsXSA9IF9oMi5kZWZhdWx0LmdldERlbHRhRW5kKG9sZFZhbCksIF9jdXJyUmVjb3JkJGtleSk7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gaWYgdGhlIG9sZCB2YWx1ZSBpcyBub3QgZGVsdGEgYW5kIHRoZSBuZXcgb25lIGlzXG5cdCAgICAgICAgY3VyclJlY29yZFtrZXldID0gbmV3VmFsO1xuXHQgICAgICAgIC8vIGlmIHRoZSBuZXh0IGl0ZW0gaGFzIHRoZSBzYW1lIHZhbHVlIC0gcmV0dXJuIHRoZVxuXHQgICAgICAgIC8vIGl0ZW0gZm9yIHN1YnNlcXVlbnQgbW9kaWZpY2F0aW9ucyBvciBzdG9wXG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmV3cml0ZU5leHQob2xkVmFsLCBuZXh0VmFsKSA/IG5ld1ZhbCA6IG51bGw7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2hlY2sgaWYgdGhlIG5leHQgaXRlbSBzaG91bGRcblx0ICAgIGJlIHJld3JpdGVkIGluIHRyYW5zZm9ybSBoaXN0b3J5IG9wZXJhdGlvbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gQ3VycmVudCB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7QW55fSBOZXh0IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIG5lZWQgdG8gcmV3cml0ZSB0aGUgbmV4dCB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX2lzUmV3cml0ZU5leHQgPSBmdW5jdGlvbiBfaXNSZXdyaXRlTmV4dChjdXJyVmFsLCBuZXh0VmFsKSB7XG5cdCAgICAvLyByZXR1cm4gZmFsc2UgaWYgbm90aGluZyB0byByZXdyaXRlIG5leHRcblx0ICAgIGlmIChuZXh0VmFsID09IG51bGwgJiYgY3VyclZhbCAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGlzRXF1YWwgPSBjdXJyVmFsID09PSBuZXh0VmFsLFxuXHQgICAgICAgIGlzTmV4dERlbHRhID0gdGhpcy5faXNEZWx0YShuZXh0VmFsKSxcblx0ICAgICAgICBpc0RlbHRhID0gdGhpcy5faXNEZWx0YShjdXJyVmFsKSxcblx0ICAgICAgICBpc1ZhbHVlRGVsdGFDaGFpbiA9IGZhbHNlLFxuXHQgICAgICAgIGlzRGVsdGFDaGFpbiA9IGZhbHNlO1xuXG5cdCAgICBpZiAoaXNEZWx0YSAmJiBpc05leHREZWx0YSkge1xuXHQgICAgICBpZiAoX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQoY3VyclZhbCkgPT0gX2gyLmRlZmF1bHQuZ2V0RGVsdGFTdGFydChuZXh0VmFsKSkge1xuXHQgICAgICAgIGlzRGVsdGFDaGFpbiA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoaXNOZXh0RGVsdGEpIHtcblx0ICAgICAgaXNWYWx1ZURlbHRhQ2hhaW4gPSBfaDIuZGVmYXVsdC5nZXREZWx0YVN0YXJ0KG5leHRWYWwpID09PSAnJyArIGN1cnJWYWw7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBpc0VxdWFsIHx8IGlzVmFsdWVEZWx0YUNoYWluIHx8IGlzRGVsdGFDaGFpbjtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gdHVuZSBuZXcgaGlzdG9yeSBvcHRpb25zIHRvIGFsbCB0aGUgc3VibW9kdWxlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgVHVuZWFibGUucHJvdG90eXBlLl90dW5lU3ViTW9kdWxlcyA9IGZ1bmN0aW9uIF90dW5lU3ViTW9kdWxlcygpIHtcblx0ICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLl9tb2R1bGVzW2ldLl90dW5lTmV3T3B0aW9ucyh0aGlzLl9oaXN0b3J5W2ldKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IG5ldyBvcHRpb25zIG9uIHJ1bi5cblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgZm9yZWlnbiBjb250ZXh0LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3Jlc2V0VHdlZW5zID0gZnVuY3Rpb24gX3Jlc2V0VHdlZW5zKCkge1xuXHQgICAgdmFyIGkgPSAwLFxuXHQgICAgICAgIHNoaWZ0ID0gMCxcblx0ICAgICAgICB0d2VlbnMgPSB0aGlzLnRpbWVsaW5lLl90aW1lbGluZXM7XG5cblx0ICAgIC8vIGlmIGBpc1RpbWVsaW5lTGVzc2AgcmV0dXJuXG5cdCAgICBpZiAodHdlZW5zID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR3ZWVucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgdHdlZW4gPSB0d2VlbnNbaV0sXG5cdCAgICAgICAgICBwcmV2VHdlZW4gPSB0d2VlbnNbaSAtIDFdO1xuXG5cdCAgICAgIHNoaWZ0ICs9IHByZXZUd2VlbiA/IHByZXZUd2Vlbi5fcHJvcHMucmVwZWF0VGltZSA6IDA7XG5cdCAgICAgIHRoaXMuX3Jlc2V0VHdlZW4odHdlZW4sIHRoaXMuX2hpc3RvcnlbaV0sIHNoaWZ0KTtcblx0ICAgIH1cblx0ICAgIHRoaXMudGltZWxpbmUuX3NldFByb3AodGhpcy5fcHJvcHMudGltZWxpbmUpO1xuXHQgICAgdGhpcy50aW1lbGluZS5fcmVjYWxjVG90YWxEdXJhdGlvbigpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXNldCB0d2VlbiB3aXRoIG5ldyBvcHRpb25zLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuIHRvIHJlc2V0LlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuJ3MgdG8gcmVzZXQgdHdlZW4gd2l0aC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBPcHRpb25hbCBudW1iZXIgdG8gc2hpZnQgdHdlZW4gc3RhcnQgdGltZS5cblx0ICAqL1xuXG5cblx0ICBUdW5lYWJsZS5wcm90b3R5cGUuX3Jlc2V0VHdlZW4gPSBmdW5jdGlvbiBfcmVzZXRUd2Vlbih0d2Vlbiwgbykge1xuXHQgICAgdmFyIHNoaWZ0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMCA6IGFyZ3VtZW50c1syXTtcblxuXHQgICAgby5zaGlmdFRpbWUgPSBzaGlmdDt0d2Vlbi5fc2V0UHJvcChvKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFR1bmVhYmxlO1xuXHR9KF90aGVuYWJsZTIuZGVmYXVsdCk7XG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gVHVuZWFibGU7XG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBEZWx0YSA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBEZWx0YSgpIHtcblx0ICAgIHZhciBvID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBEZWx0YSk7XG5cblx0ICAgIHRoaXMuX28gPSBvO1xuXHQgICAgdGhpcy5fY3JlYXRlVHdlZW4oby50d2Vlbk9wdGlvbnMpO1xuXHQgICAgLy8gaW5pdGlhbCBwcm9wZXJ0aWVzIHJlbmRlclxuXHQgICAgIXRoaXMuX28uaXNDaGFpbmVkICYmIHRoaXMucmVmcmVzaCh0cnVlKTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxsIGBfcmVmcmVzaGAgbWV0aG9kIG9uIGB0d2VlbmAuXG5cdCAgICBVc2Ugc3dpdGNoIGJldHdlZW4gYDBgIGFuZCBgMWAgcHJvZ3Jlc3MgZm9yIGRlbHRhIHZhbHVlLlxuXHQgICAgQHB1YmxpY1xuXHQgICAgQHBhcmFtIHtCb29sZWFufSBJZiByZWZyZXNoIGJlZm9yZSBzdGFydCB0aW1lIG9yIGFmdGVyLlxuXHQgICAgQHJldHVybnMgdGhpcy5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goaXNCZWZvcmUpIHtcblx0ICAgIHRoaXMuX3ByZXZpb3VzVmFsdWVzID0gW107XG5cblx0ICAgIHZhciBkZWx0YXMgPSB0aGlzLl9vLmRlbHRhcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuYW1lID0gZGVsdGFzW2ldLm5hbWU7XG5cdCAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWVzLnB1c2goe1xuXHQgICAgICAgIG5hbWU6IG5hbWUsIHZhbHVlOiB0aGlzLl9vLnByb3BzW25hbWVdXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnR3ZWVuLl9yZWZyZXNoKGlzQmVmb3JlKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZXN0b3JlIGFsbCBzYXZlZCBwcm9wZXJ0aWVzIGZyb20gYF9wcmV2aW91c1ZhbHVlc2AgYXJyYXkuXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB0aGlzLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZSgpIHtcblx0ICAgIHZhciBwcmV2ID0gdGhpcy5fcHJldmlvdXNWYWx1ZXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHJlY29yZCA9IHByZXZbaV07XG5cdCAgICAgIHRoaXMuX28ucHJvcHNbcmVjb3JkLm5hbWVdID0gcmVjb3JkLnZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSB0d2VlbiBvZiB0aGUgZGVsdGEuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9wdGlvbnMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY3JlYXRlVHdlZW4gPSBmdW5jdGlvbiBfY3JlYXRlVHdlZW4oKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG5cdCAgICB2YXIgaXQgPSB0aGlzO1xuXHQgICAgby5jYWxsYmFja092ZXJyaWRlcyA9IHtcblx0ICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGVwLCBwKSB7XG5cdCAgICAgICAgaXQuX2NhbGNDdXJyZW50UHJvcHMoZXAsIHApO1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvLyBpZiBub3QgY2hhaW5lZCAtIGFkZCB0aGUgb25SZWZyZXNoIGNhbGxiYWNrXG5cdCAgICAvLyB0byByZWZyZXNoIHRoZSB0d2VlbiB3aGVuIG5lZWRlZFxuXHQgICAgaWYgKCF0aGlzLl9vLmlzQ2hhaW5lZCkge1xuXHQgICAgICBvLmNhbGxiYWNrT3ZlcnJpZGVzLm9uUmVmcmVzaCA9IGZ1bmN0aW9uIChpc0JlZm9yZSwgZXAsIHApIHtcblx0ICAgICAgICBpdC5fY2FsY0N1cnJlbnRQcm9wcyhlcCwgcCk7XG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIG8uY2FsbGJhY2tzQ29udGV4dCA9IHRoaXMuX28uY2FsbGJhY2tzQ29udGV4dDtcblx0ICAgIHRoaXMudHdlZW4gPSBuZXcgX3R3ZWVuMi5kZWZhdWx0KG8pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gY2FsY3VsYXRlIC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIERlbHRhLnByb3RvdHlwZS5fY2FsY0N1cnJlbnRQcm9wcyA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHApIHtcblx0ICAgIHZhciBkZWx0YXMgPSB0aGlzLl9vLmRlbHRhcztcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB0eXBlID0gZGVsdGFzW2ldLnR5cGU7XG5cdCAgICAgIHRoaXNbJ19jYWxjQ3VycmVudF8nICsgdHlwZV0oZGVsdGFzW2ldLCBlYXNlZFByb2dyZXNzLCBwKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsYyB0aGUgY3VycmVudCBjb2xvciBkZWx0YSB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YVxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IEVhc2VkIHByb2dyZXNzIFswLi4xXS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBQbGFpbiBwcm9ncmVzcyBbMC4uMV0uXG5cdCAgKi9cblxuXG5cdCAgRGVsdGEucHJvdG90eXBlLl9jYWxjQ3VycmVudF9jb2xvciA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudF9jb2xvcihkZWx0YSwgZXAsIHApIHtcblx0ICAgIHZhciByLFxuXHQgICAgICAgIGcsXG5cdCAgICAgICAgYixcblx0ICAgICAgICBhLFxuXHQgICAgICAgIHN0YXJ0ID0gZGVsdGEuc3RhcnQsXG5cdCAgICAgICAgZCA9IGRlbHRhLmRlbHRhO1xuXHQgICAgaWYgKCFkZWx0YS5jdXJ2ZSkge1xuXHQgICAgICByID0gcGFyc2VJbnQoc3RhcnQuciArIGVwICogZC5yLCAxMCk7XG5cdCAgICAgIGcgPSBwYXJzZUludChzdGFydC5nICsgZXAgKiBkLmcsIDEwKTtcblx0ICAgICAgYiA9IHBhcnNlSW50KHN0YXJ0LmIgKyBlcCAqIGQuYiwgMTApO1xuXHQgICAgICBhID0gcGFyc2VGbG9hdChzdGFydC5hICsgZXAgKiBkLmEpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIGNwID0gZGVsdGEuY3VydmUocCk7XG5cdCAgICAgIHIgPSBwYXJzZUludChjcCAqIChzdGFydC5yICsgcCAqIGQuciksIDEwKTtcblx0ICAgICAgZyA9IHBhcnNlSW50KGNwICogKHN0YXJ0LmcgKyBwICogZC5nKSwgMTApO1xuXHQgICAgICBiID0gcGFyc2VJbnQoY3AgKiAoc3RhcnQuYiArIHAgKiBkLmIpLCAxMCk7XG5cdCAgICAgIGEgPSBwYXJzZUZsb2F0KGNwICogKHN0YXJ0LmEgKyBwICogZC5hKSk7XG5cdCAgICB9XG5cdCAgICB0aGlzLl9vLnByb3BzW2RlbHRhLm5hbWVdID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGMgdGhlIGN1cnJlbnQgbnVtYmVyIGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X251bWJlciA9IGZ1bmN0aW9uIF9jYWxjQ3VycmVudF9udW1iZXIoZGVsdGEsIGVwLCBwKSB7XG5cdCAgICB0aGlzLl9vLnByb3BzW2RlbHRhLm5hbWVdID0gIWRlbHRhLmN1cnZlID8gZGVsdGEuc3RhcnQgKyBlcCAqIGRlbHRhLmRlbHRhIDogZGVsdGEuY3VydmUocCkgKiAoZGVsdGEuc3RhcnQgKyBwICogZGVsdGEuZGVsdGEpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjIHRoZSBjdXJyZW50IG51bWJlciB3aXRoIHVuaXRzIGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X3VuaXQgPSBmdW5jdGlvbiBfY2FsY0N1cnJlbnRfdW5pdChkZWx0YSwgZXAsIHApIHtcblx0ICAgIHZhciBjdXJyZW50VmFsdWUgPSAhZGVsdGEuY3VydmUgPyBkZWx0YS5zdGFydC52YWx1ZSArIGVwICogZGVsdGEuZGVsdGEgOiBkZWx0YS5jdXJ2ZShwKSAqIChkZWx0YS5zdGFydC52YWx1ZSArIHAgKiBkZWx0YS5kZWx0YSk7XG5cblx0ICAgIHRoaXMuX28ucHJvcHNbZGVsdGEubmFtZV0gPSAnJyArIGN1cnJlbnRWYWx1ZSArIGRlbHRhLmVuZC51bml0O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjIHRoZSBjdXJyZW50IGFycmF5IGRlbHRhIHZhbHVlLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IERlbHRhXG5cdCAgICBAcGFyYW0ge051bWJlcn0gRWFzZWQgcHJvZ3Jlc3MgWzAuLjFdLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IFBsYWluIHByb2dyZXNzIFswLi4xXS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YS5wcm90b3R5cGUuX2NhbGNDdXJyZW50X2FycmF5ID0gZnVuY3Rpb24gX2NhbGNDdXJyZW50X2FycmF5KGRlbHRhLCBlcCwgcCkge1xuXHQgICAgLy8gdmFyIGFycixcblx0ICAgIHZhciBuYW1lID0gZGVsdGEubmFtZSxcblx0ICAgICAgICBwcm9wcyA9IHRoaXMuX28ucHJvcHMsXG5cdCAgICAgICAgc3RyaW5nID0gJyc7XG5cblx0ICAgIC8vIHRvIHByZXZlbnQgR0MgYm90aGVyaW5nIHdpdGggYXJyYXlzIGdhcmJhZ2Vcblx0ICAgIC8vIGlmICggaC5pc0FycmF5KCBwcm9wc1tuYW1lXSApICkge1xuXHQgICAgLy8gICBhcnIgPSBwcm9wc1tuYW1lXTtcblx0ICAgIC8vICAgYXJyLmxlbmd0aCA9IDA7XG5cdCAgICAvLyB9IGVsc2UgeyBhcnIgPSBbXTsgfVxuXG5cdCAgICAvLyBqdXN0IG9wdGltaXphdGlvbiB0byBwcmV2ZW50IGN1cnZlXG5cdCAgICAvLyBjYWxjdWxhdGlvbnMgb24gZXZlcnkgYXJyYXkgaXRlbVxuXHQgICAgdmFyIHByb2MgPSBkZWx0YS5jdXJ2ZSA/IGRlbHRhLmN1cnZlKHApIDogbnVsbDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWx0YS5kZWx0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaXRlbSA9IGRlbHRhLmRlbHRhW2ldLFxuXHQgICAgICAgICAgZGFzaCA9ICFkZWx0YS5jdXJ2ZSA/IGRlbHRhLnN0YXJ0W2ldLnZhbHVlICsgZXAgKiBpdGVtLnZhbHVlIDogcHJvYyAqIChkZWx0YS5zdGFydFtpXS52YWx1ZSArIHAgKiBpdGVtLnZhbHVlKTtcblxuXHQgICAgICBzdHJpbmcgKz0gJycgKyBkYXNoICsgaXRlbS51bml0ICsgJyAnO1xuXHQgICAgICAvLyBhcnIucHVzaCh7XG5cdCAgICAgIC8vICAgc3RyaW5nOiBgJHtkYXNofSR7aXRlbS51bml0fWAsXG5cdCAgICAgIC8vICAgdmFsdWU6ICBkYXNoLFxuXHQgICAgICAvLyAgIHVuaXQ6ICAgaXRlbS51bml0LFxuXHQgICAgICAvLyB9KTtcblx0ICAgIH1cblx0ICAgIHByb3BzW25hbWVdID0gc3RyaW5nO1xuXHQgIH07XG5cblx0ICByZXR1cm4gRGVsdGE7XG5cdH0oKTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBEZWx0YTtcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2V4dGVuZHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cblx0dmFyIF9leHRlbmRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4dGVuZHMyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX2tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcblxuXHR2YXIgX2tleXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5cyk7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF9kZWx0YSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5cdHZhciBfZGVsdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVsdGEpO1xuXG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cblx0Lypcblx0ICBUaGlzIG1vZHVsZSdzIHRhcmdldCBpcyB0byBwYXJzZSBvcHRpb25zIG9iamVjdCxcblx0ICBmaW5kIGRlbHRhcyBpbiBpdCBhbmQgc2VuZCB0aGVtIHRvIGBEZWx0YWAgY2xhc3Nlcy5cblx0ICBUaGUgYERlbHRhYCBjbGFzcyBpcyBkdWxsIC0gdGhleSBleHBlY3QgYWN0dWFsIHBhcnNlZCBkZWx0YXNcblx0ICBhbmQgc2VwYXJhdGVkIHR3ZWVuIG9wdGlvbnMsIHNvIHdlIHNob3VsZCBwYXJzZSB0aGVtIGhlcmUuXG5cdCAgVGhlIHRpbWVsaW5lIG9mIHRoZSBtb2R1bGUgY29udHJvbHMgdGhlIGBEZWx0YWAgbW9kdWxlcycgdHdlZW5zLlxuXG5cdCAgQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCB0byBzZXQgZGVsdGFzIHJlc3VsdCB0byAocGFzcyB0byB0aGUgRGVsdGEgY2xhc3NlcykuXG5cdCAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHRvIHBhcnNlIHRoZSBkZWx0YXMgZnJvbS5cblx0ICBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBvblVwZGF0ZSBjYWxsYmFjay5cblx0ICBAcGFyYW0gb3B0aW9uYWwge09iamVjdH0gYXJyYXlQcm9wZXJ0eU1hcCBMaXN0IG9mIHByb3BlcnRpZXMgd2l0aCB0cnV0aHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgd2hpY2ggZGVzY3JpYmUgcHJvcGVydGllc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCBhcyBhcnJheXMuXG5cdCAgQHBhcmFtIG9wdGlvbmFsIHtPYmplY3R9IG51bWJlclByb3BlcnR5TWFwIExpc3Qgb2YgcHJvcGVydGllcyB3aXRoIHRydXRoeVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyB3aGljaCBkZXNjcmliZSBwcm9wZXJ0aWVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCBzaG91bGQgYmUgcGFyc2VkIGFzIG51bWJlcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRob3V0IHVuaXRzLlxuXHQqL1xuXG5cdC8vIFRPRE86XG5cdC8vIC0gY29sb3JzIHdpdGggY3VydmVzIGNoYW5nZSBhbHBoYSBsZXZlbCB0b29cblx0Ly8gY29uc3QgaHRtbCA9IG5ldyBtb2pzLkh0bWwoe1xuXHQvLyAgIGVsOiAnI2pzLWVsJyxcblx0Ly8gICB4OiB7IDA6IDEwMCB9LFxuXHQvLyAgIG9uVXBkYXRlICgpIHtcblx0Ly8gICAgIGNvbnNvbGUubG9nKHRoaXMuX3Byb3BzLm9yaWdpblgpO1xuXHQvLyAgIH0sXG5cdC8vICAgb3JpZ2luWDogeyAnd2hpdGUnOiAnYmxhY2snLCBjdXJ2ZTogJ00wLDEwMCBMMTAwLCAwJyB9LFxuXHQvLyAgIGN1c3RvbVByb3BlcnRpZXM6IHtcblx0Ly8gICAgIG9yaWdpblg6IHtcblx0Ly8gICAgICAgdHlwZTogJ2NvbG9yJyxcblx0Ly8gICAgICAgZGVmYXVsdDogJ2N5YW4nXG5cdC8vICAgICB9LFxuXHQvLyAgICAgZHJhdygpIHsgY29uc29sZS5sb2coJ2RyYXcnKTsgfVxuXHQvLyAgIH1cblx0Ly8gfSk7XG5cblx0dmFyIGVhc2luZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXHR2YXIgaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cblx0Ly8gZ2V0IHR3ZWVuIHByb3BlcnRpZXNcblx0dmFyIG9iaiA9IHt9O1xuXHRfdHdlZW4yLmRlZmF1bHQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMuY2FsbChvYmopO1xuXHR2YXIga2V5cyA9ICgwLCBfa2V5czIuZGVmYXVsdCkob2JqLl9kZWZhdWx0cyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgIG9iai5fZGVmYXVsdHNba2V5c1tpXV0gPSAxO1xuXHR9XG5cdG9iai5fZGVmYXVsdHNbJ3RpbWVsaW5lJ10gPSAxO1xuXHR2YXIgVFdFRU5fUFJPUEVSVElFUyA9IG9iai5fZGVmYXVsdHM7XG5cblx0dmFyIERlbHRhcyA9IGZ1bmN0aW9uICgpIHtcblx0ICBmdW5jdGlvbiBEZWx0YXMoKSB7XG5cdCAgICB2YXIgbyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgRGVsdGFzKTtcblxuXHQgICAgdGhpcy5fbyA9IG87XG5cblx0ICAgIHRoaXMuX3Nob3J0Q29sb3JzID0ge1xuXHQgICAgICB0cmFuc3BhcmVudDogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgICBub25lOiAncmdiYSgwLDAsMCwwKScsXG5cdCAgICAgIGFxdWE6ICdyZ2IoMCwyNTUsMjU1KScsXG5cdCAgICAgIGJsYWNrOiAncmdiKDAsMCwwKScsXG5cdCAgICAgIGJsdWU6ICdyZ2IoMCwwLDI1NSknLFxuXHQgICAgICBmdWNoc2lhOiAncmdiKDI1NSwwLDI1NSknLFxuXHQgICAgICBncmF5OiAncmdiKDEyOCwxMjgsMTI4KScsXG5cdCAgICAgIGdyZWVuOiAncmdiKDAsMTI4LDApJyxcblx0ICAgICAgbGltZTogJ3JnYigwLDI1NSwwKScsXG5cdCAgICAgIG1hcm9vbjogJ3JnYigxMjgsMCwwKScsXG5cdCAgICAgIG5hdnk6ICdyZ2IoMCwwLDEyOCknLFxuXHQgICAgICBvbGl2ZTogJ3JnYigxMjgsMTI4LDApJyxcblx0ICAgICAgcHVycGxlOiAncmdiKDEyOCwwLDEyOCknLFxuXHQgICAgICByZWQ6ICdyZ2IoMjU1LDAsMCknLFxuXHQgICAgICBzaWx2ZXI6ICdyZ2IoMTkyLDE5MiwxOTIpJyxcblx0ICAgICAgdGVhbDogJ3JnYigwLDEyOCwxMjgpJyxcblx0ICAgICAgd2hpdGU6ICdyZ2IoMjU1LDI1NSwyNTUpJyxcblx0ICAgICAgeWVsbG93OiAncmdiKDI1NSwyNTUsMCknLFxuXHQgICAgICBvcmFuZ2U6ICdyZ2IoMjU1LDEyOCwwKSdcblx0ICAgIH07XG5cblx0ICAgIHRoaXMuX2lnbm9yZURlbHRhc01hcCA9IHsgcHJldkNoYWluTW9kdWxlOiAxLCBtYXN0ZXJNb2R1bGU6IDEgfTtcblxuXHQgICAgdGhpcy5fcGFyc2VEZWx0YXMoby5vcHRpb25zKTtcblx0ICAgIHRoaXMuX2NyZWF0ZURlbHRhcygpO1xuXHQgICAgdGhpcy5fY3JlYXRlVGltZWxpbmUodGhpcy5fbWFpblR3ZWVuT3B0aW9ucyk7XG5cdCAgfVxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY2FsbCBgcmVmcmVzaGAgb24gYWxsIGNoaWxkIGBkZWx0YWAgb2JqZWN0cy5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7Qm9vbGVhbn0gSWYgYmVmb3JlIHN0YXJ0IHRpbWUgKHRydWUpIG9yIGFmdGVyIGVuZCB0aW1lIChmYWxzZSkuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaChpc0JlZm9yZSkge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kZWx0YXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy5fZGVsdGFzW2ldLnJlZnJlc2goaXNCZWZvcmUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGwgYHJlc3RvcmVgIG9uIGFsbCBjaGlsZCBgZGVsdGFgIG9iamVjdHMuXG5cdCAgICBAcHVibGljXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZSgpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMuX2RlbHRhc1tpXS5yZXN0b3JlKCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY3JlYXRlIFRpbWVsaW5lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBUaW1lbGluZSBvcHRpb25zLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2NyZWF0ZVRpbWVsaW5lID0gZnVuY3Rpb24gX2NyZWF0ZVRpbWVsaW5lKCkge1xuXHQgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuXHQgICAgLy8gY29uc3QgbyA9IHRoaXMuX287XG5cdCAgICAvLyBvcHRzLnRpbWVsaW5lID0gb3B0cy50aW1lbGluZSB8fCB7fTtcblx0ICAgIC8vIG9wdHMudGltZWxpbmUuY2FsbGJhY2tPdmVycmlkZXMgPSB7XG5cdCAgICAvLyAgIG9uVXBkYXRlOiAgIG8ub25VcGRhdGUsXG5cdCAgICAvLyAgIG9uUmVmcmVzaDogIG8ub25VcGRhdGVcblx0ICAgIC8vIH1cblx0ICAgIC8vIHNlbmQgY2FsbGJhY2tzQ29udGV4dCB0byB0aW1lbGluZSBpZiBzZXRcblx0ICAgIC8vIG8uY2FsbGJhY2tzQ29udGV4dCAmJiAob3B0cy50aW1lbGluZS5jYWxsYmFja3NDb250ZXh0ID0gby5jYWxsYmFja3NDb250ZXh0KTtcblx0ICAgIC8vIG9wdHMudGltZWxpbmVcblx0ICAgIHRoaXMudGltZWxpbmUgPSBuZXcgX3RpbWVsaW5lMi5kZWZhdWx0KCk7XG5cdCAgICB0aGlzLnRpbWVsaW5lLmFkZCh0aGlzLl9kZWx0YXMpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgRGVsdGFzIGZyb20gcGFyc2VkIG9wdGlvbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX2NyZWF0ZURlbHRhcyA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YXMoKSB7XG5cdCAgICB0aGlzLl9kZWx0YXMgPSBbXTtcblxuXHQgICAgLy8gY3JlYXRlIG1haW4gZGVsdGEgb2JqZWN0XG5cdCAgICB0aGlzLl9kZWx0YXMucHVzaCh0aGlzLl9jcmVhdGVEZWx0YSh0aGlzLl9tYWluRGVsdGFzLCB0aGlzLl9tYWluVHdlZW5PcHRpb25zKSk7XG5cblx0ICAgIC8vIGNyZWF0ZSBjaGlsZCBkZWx0YSBvYmplY3Rcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGREZWx0YXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGRlbHRhID0gdGhpcy5fY2hpbGREZWx0YXNbaV07XG5cdCAgICAgIHRoaXMuX2RlbHRhcy5wdXNoKHRoaXMuX2NyZWF0ZURlbHRhKFtkZWx0YS5kZWx0YV0sIGRlbHRhLnR3ZWVuT3B0aW9ucykpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjcmVhdGUgRGVsdGEgb2JqZWN0IHdpdGggcGFzc2VkIG9wdGlvbnMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtBcnJheX0gQXJyYXkgb2YgZGVsdGFzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFR3ZWVuIHByb3BlcnRpZXMuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBEZWx0YSBvYmplY3Rcblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9jcmVhdGVEZWx0YSA9IGZ1bmN0aW9uIF9jcmVhdGVEZWx0YShkZWx0YXMsIHR3ZWVuT3B0aW9ucykge1xuXHQgICAgdmFyIG8gPSB0aGlzLl9vO1xuXHQgICAgcmV0dXJuIG5ldyBfZGVsdGEyLmRlZmF1bHQoe1xuXHQgICAgICBkZWx0YXM6IGRlbHRhcywgdHdlZW5PcHRpb25zOiB0d2Vlbk9wdGlvbnMsXG5cdCAgICAgIHByb3BzOiBvLnByb3BzLFxuXHQgICAgICBpc0NoYWluZWQ6IG8uaXNDaGFpbmVkLFxuXHQgICAgICBjYWxsYmFja3NDb250ZXh0OiBvLmNhbGxiYWNrc0NvbnRleHRcblx0ICAgIH0pO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBvYmplY3RzIGZyb20gb3B0aW9ucy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT3B0aW9ucyBvYmplY3QgdG8gcGFyc2UgdGhlIGRlbHRhcyBmcm9tLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlRGVsdGFzID0gZnVuY3Rpb24gX3BhcnNlRGVsdGFzKG9iaikge1xuXHQgICAgLy8gc3BpbHQgbWFpbiBhbmltYXRpb24gcHJvcGVydGllcyBhbmQgbWFpbiB0d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICB2YXIgbWFpblNwbGl0ID0gdGhpcy5fc3BsaXRUd2Vlbk9wdGlvbnMob2JqKTtcblx0ICAgIC8vIG1haW4gYW5pbWF0aW9uIHByb3BlcnRpZXNcblx0ICAgIHZhciBvcHRzID0gbWFpblNwbGl0LmRlbHRhO1xuXHQgICAgLy8gbWFpbiB0d2VlbiBwcm9wZXJ0aWVzXG5cdCAgICB0aGlzLl9tYWluVHdlZW5PcHRpb25zID0gbWFpblNwbGl0LnR3ZWVuT3B0aW9ucztcblxuXHQgICAgdGhpcy5fbWFpbkRlbHRhcyA9IFtdO1xuXHQgICAgdGhpcy5fY2hpbGREZWx0YXMgPSBbXTtcblx0ICAgIHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShvcHRzKTtcblx0ICAgIC8vIGxvb3AgdGhydSBhbGwgcHJvcGVydGllcyB3aXRob3V0IHR3ZWVuIG9uZXNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgLy8gaXMgcHJvcGVydHkgaXMgZGVsdGEgLSBwYXJzZSBpdFxuXHQgICAgICBpZiAodGhpcy5faXNEZWx0YShvcHRzW2tleV0pICYmICF0aGlzLl9pZ25vcmVEZWx0YXNNYXBba2V5XSkge1xuXHQgICAgICAgIHZhciBkZWx0YSA9IHRoaXMuX3NwbGl0QW5kUGFyc2VEZWx0YShrZXksIG9wdHNba2V5XSk7XG5cdCAgICAgICAgLy8gaWYgcGFyc2VkIG9iamVjdCBoYXMgbm8gdHdlZW4gdmFsdWVzIC0gaXQncyBkZWx0YSBvZiB0aGUgbWFpbiBvYmplY3Rcblx0ICAgICAgICBpZiAoIWRlbHRhLnR3ZWVuT3B0aW9ucykge1xuXHQgICAgICAgICAgdGhpcy5fbWFpbkRlbHRhcy5wdXNoKGRlbHRhLmRlbHRhKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGRpc3RpbmN0IGRlbHRhIG9iamVjdFxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0aGlzLl9jaGlsZERlbHRhcy5wdXNoKGRlbHRhKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzcGxpdCB0d2VlbiB2YWx1ZXMgYW5kIHBhcnNlIHNpbmdsZSBkZWx0YSByZWNvcmQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFNwbGl0IG9iamVjdC5cblx0ICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSB0d2Vlbk9wdGlvbnMgVHdlZW4gcHJvcGVydGllcy5cblx0ICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBkZWx0YSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fc3BsaXRBbmRQYXJzZURlbHRhID0gZnVuY3Rpb24gX3NwbGl0QW5kUGFyc2VEZWx0YShuYW1lLCBvYmplY3QpIHtcblx0ICAgIHZhciBzcGxpdCA9IHRoaXMuX3NwbGl0VHdlZW5PcHRpb25zKG9iamVjdCk7XG5cdCAgICAvLyBwYXJzZSBkZWx0YSBpbiB0aGUgb2JqZWN0XG5cdCAgICBzcGxpdC5kZWx0YSA9IHRoaXMuX3BhcnNlRGVsdGEobmFtZSwgc3BsaXQuZGVsdGEpO1xuXHQgICAgcmV0dXJuIHNwbGl0O1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBkZWx0YSBieSBkZWxlZ2F0aW5nIHRoZSB2YXJpYWJsZXMgdG8gX3BhcnNlKkRlbHRhIG1ldGhvZHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgaW5kZXguXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VEZWx0YSA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhKG5hbWUsIG9iamVjdCwgaW5kZXgpIHtcblx0ICAgIC8vIGlmIG5hbWUgaXMgaW4gX28uY3VzdG9tUHJvcHMgLSBwYXJzZSBpdCByZWdhcmRpbmcgdGhlIHR5cGVcblx0ICAgIHJldHVybiB0aGlzLl9vLmN1c3RvbVByb3BzICYmIHRoaXMuX28uY3VzdG9tUHJvcHNbbmFtZV0gIT0gbnVsbCA/IHRoaXMuX3BhcnNlRGVsdGFCeUN1c3RvbShuYW1lLCBvYmplY3QsIGluZGV4KSA6IHRoaXMuX3BhcnNlRGVsdGFCeUd1ZXNzKG5hbWUsIG9iamVjdCwgaW5kZXgpO1xuXHQgIH07XG5cdCAgLyoqXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZGVsdGEgYnkgdGFraW5nIHRoZSB0eXBlIGZyb20gdGhlIGN1c3RvbVByb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gUHJvcGVydHkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBSYXcgZGVsdGEgb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE1vZHVsZSBpbmRleC5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZURlbHRhQnlDdXN0b20gPSBmdW5jdGlvbiBfcGFyc2VEZWx0YUJ5Q3VzdG9tKG5hbWUsIG9iamVjdCwgaW5kZXgpIHtcblx0ICAgIHJldHVybiB0aGlzLl9wYXJzZU51bWJlckRlbHRhKG5hbWUsIG9iamVjdCwgaW5kZXgpO1xuXHQgICAgLy8gY29uc3QgY3VzdG9tUmVjb3JkID0gdGhpcy5fby5jdXN0b21Qcm9wc1tuYW1lXTtcblx0ICAgIC8vIHN3aXRjaCAoIGN1c3RvbVJlY29yZC50eXBlLnRvTG93ZXJDYXNlKCkgKSB7XG5cdCAgICAvLyAgIGNhc2UgJ2NvbG9yJzogIHsgcmV0dXJuIHRoaXMuX3BhcnNlQ29sb3JEZWx0YSggbmFtZSwgb2JqZWN0ICk7IH1cblx0ICAgIC8vICAgY2FzZSAnYXJyYXknOiAgeyByZXR1cm4gdGhpcy5fcGFyc2VBcnJheURlbHRhKCBuYW1lLCBvYmplY3QgKTsgfVxuXHQgICAgLy8gICBjYXNlICdudW1iZXInOiB7IHJldHVybiB0aGlzLl9wYXJzZU51bWJlckRlbHRhKCBuYW1lLCBvYmplY3QsIGluZGV4ICk7IH1cblx0ICAgIC8vICAgY2FzZSAndW5pdCc6ICAgeyByZXR1cm4gdGhpcy5fcGFyc2VVbml0RGVsdGEoIG5hbWUsIG9iamVjdCwgaW5kZXggKTsgfVxuXHQgICAgLy8gfVxuXHQgIH07XG5cdCAgLyoqXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgZGVsdGEgYnkgcmVhc29uaW5nIGFib3V0IGl0J3MgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gUmF3IGRlbHRhIG9iamVjdC5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgaW5kZXguXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VEZWx0YUJ5R3Vlc3MgPSBmdW5jdGlvbiBfcGFyc2VEZWx0YUJ5R3Vlc3MobmFtZSwgb2JqZWN0LCBpbmRleCkge1xuXHQgICAgdmFyIF9wcmVwYXJzZURlbHRhMiA9IHRoaXMuX3ByZXBhcnNlRGVsdGEob2JqZWN0KTtcblxuXHQgICAgdmFyIHN0YXJ0ID0gX3ByZXBhcnNlRGVsdGEyLnN0YXJ0O1xuXG5cdCAgICB2YXIgbyA9IHRoaXMuX287XG5cblx0ICAgIC8vIGNvbG9yIHZhbHVlc1xuXHQgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc3RhcnQpKSAmJiAhc3RhcnQubWF0Y2goL3JhbmRcXCgvKSAmJiAhc3RhcnQubWF0Y2goL3N0YWdnZXJcXCgvKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcGFyc2VDb2xvckRlbHRhKG5hbWUsIG9iamVjdCk7XG5cdCAgICAgIC8vIGFycmF5IHZhbHVlc1xuXHQgICAgfSBlbHNlIGlmIChvLmFycmF5UHJvcGVydHlNYXAgJiYgby5hcnJheVByb3BlcnR5TWFwW25hbWVdKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXJyYXlEZWx0YShuYW1lLCBvYmplY3QpO1xuXHQgICAgICAgIC8vIHVuaXQgb3IgbnVtYmVyIHZhbHVlc1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIG8ubnVtYmVyUHJvcGVydHlNYXAgJiYgby5udW1iZXJQcm9wZXJ0eU1hcFtuYW1lXSA/XG5cdCAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgaW4gdGhlIG51bWJlciBwcm9wZXJ0eSBtYXAgLSBwYXJzZSBpdCBsaWtlIG51bWJlclxuXHQgICAgICAgICAgdGhpcy5fcGFyc2VOdW1iZXJEZWx0YShuYW1lLCBvYmplY3QsIGluZGV4KVxuXHQgICAgICAgICAgLy8gb3RoZXJ3aXNlIC0gbGlrZSBudW1iZXIgd2l0aCB1bml0c1xuXHQgICAgICAgICAgOiB0aGlzLl9wYXJzZVVuaXREZWx0YShuYW1lLCBvYmplY3QsIGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNlcGFyYXRlIHR3ZWVuIG9wdGlvbnMgZnJvbSBkZWx0YSBwcm9wZXJ0aWVzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCBmb3Igc2VwYXJhdGlvbi5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCB0aGF0IGNvbnRhaW5zIDIgb2JqZWN0c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAtIG9uZSBkZWx0YSBvcHRpb25zXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC0gb25lIHR3ZWVuIG9wdGlvbnMgKCBjb3VsZCBiZSBlbXB0eSBpZiBubyB0d2VlbiBvcHRzIClcblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9zcGxpdFR3ZWVuT3B0aW9ucyA9IGZ1bmN0aW9uIF9zcGxpdFR3ZWVuT3B0aW9ucyhkZWx0YSkge1xuXHQgICAgZGVsdGEgPSAoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCBkZWx0YSk7XG5cblx0ICAgIHZhciBrZXlzID0gKDAsIF9rZXlzMi5kZWZhdWx0KShkZWx0YSksXG5cdCAgICAgICAgdHdlZW5PcHRpb25zID0ge307XG5cdCAgICB2YXIgaXNUd2VlbiA9IG51bGw7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgaWYgKFRXRUVOX1BST1BFUlRJRVNba2V5XSkge1xuXHQgICAgICAgIGlmIChkZWx0YVtrZXldICE9IG51bGwpIHtcblx0ICAgICAgICAgIHR3ZWVuT3B0aW9uc1trZXldID0gZGVsdGFba2V5XTtcblx0ICAgICAgICAgIGlzVHdlZW4gPSB0cnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBkZWxldGUgZGVsdGFba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZGVsdGE6IGRlbHRhLFxuXHQgICAgICB0d2Vlbk9wdGlvbnM6IGlzVHdlZW4gPyB0d2Vlbk9wdGlvbnMgOiB1bmRlZmluZWRcblx0ICAgIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWx0YSBwcm9wZXJ0eS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUGFyYW1ldGVyIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5faXNEZWx0YSA9IGZ1bmN0aW9uIF9pc0RlbHRhKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0ID0gaC5pc09iamVjdChvcHRpb25zVmFsdWUpO1xuXHQgICAgaXNPYmplY3QgPSBpc09iamVjdCAmJiAhb3B0aW9uc1ZhbHVlLnVuaXQ7XG5cdCAgICByZXR1cm4gISghaXNPYmplY3QgfHwgaC5pc0FycmF5KG9wdGlvbnNWYWx1ZSkgfHwgaC5pc0RPTShvcHRpb25zVmFsdWUpKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgY29sb3IgZGVsdGEgdmFsdWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZUNvbG9yRGVsdGEgPSBmdW5jdGlvbiBfcGFyc2VDb2xvckRlbHRhKGtleSwgdmFsdWUpIHtcblx0ICAgIGlmIChrZXkgPT09ICdzdHJva2VMaW5lY2FwJykge1xuXHQgICAgICBoLndhcm4oJ1NvcnJ5LCBzdHJva2UtbGluZWNhcCBwcm9wZXJ0eSBpcyBub3QgYW5pbWF0YWJsZSB5ZXQsIHVzaW5nIHRoZSBzdGFydCgje3N0YXJ0fSkgdmFsdWUgaW5zdGVhZCcsIHZhbHVlKTtcblx0ICAgICAgcmV0dXJuIHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIHByZVBhcnNlID0gdGhpcy5fcHJlcGFyc2VEZWx0YSh2YWx1ZSk7XG5cblx0ICAgIHZhciBzdGFydENvbG9yT2JqID0gdGhpcy5fbWFrZUNvbG9yT2JqKHByZVBhcnNlLnN0YXJ0KSxcblx0ICAgICAgICBlbmRDb2xvck9iaiA9IHRoaXMuX21ha2VDb2xvck9iaihwcmVQYXJzZS5lbmQpO1xuXG5cdCAgICB2YXIgZGVsdGEgPSB7XG5cdCAgICAgIHR5cGU6ICdjb2xvcicsXG5cdCAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgc3RhcnQ6IHN0YXJ0Q29sb3JPYmosXG5cdCAgICAgIGVuZDogZW5kQ29sb3JPYmosXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZSxcblx0ICAgICAgZGVsdGE6IHtcblx0ICAgICAgICByOiBlbmRDb2xvck9iai5yIC0gc3RhcnRDb2xvck9iai5yLFxuXHQgICAgICAgIGc6IGVuZENvbG9yT2JqLmcgLSBzdGFydENvbG9yT2JqLmcsXG5cdCAgICAgICAgYjogZW5kQ29sb3JPYmouYiAtIHN0YXJ0Q29sb3JPYmouYixcblx0ICAgICAgICBhOiBlbmRDb2xvck9iai5hIC0gc3RhcnRDb2xvck9iai5hXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGFycmF5IGRlbHRhIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQYXJzZWQgZGVsdGEuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fcGFyc2VBcnJheURlbHRhID0gZnVuY3Rpb24gX3BhcnNlQXJyYXlEZWx0YShrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgcHJlUGFyc2UgPSB0aGlzLl9wcmVwYXJzZURlbHRhKHZhbHVlKTtcblxuXHQgICAgdmFyIHN0YXJ0QXJyID0gdGhpcy5fc3RyVG9BcnIocHJlUGFyc2Uuc3RhcnQpLFxuXHQgICAgICAgIGVuZEFyciA9IHRoaXMuX3N0clRvQXJyKHByZVBhcnNlLmVuZCk7XG5cblx0ICAgIGgubm9ybURhc2hBcnJheXMoc3RhcnRBcnIsIGVuZEFycik7XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRBcnIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGVuZCA9IGVuZEFycltpXTtcblx0ICAgICAgaC5tZXJnZVVuaXRzKHN0YXJ0QXJyW2ldLCBlbmQsIGtleSk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkZWx0YSA9IHtcblx0ICAgICAgdHlwZTogJ2FycmF5Jyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnRBcnIsXG5cdCAgICAgIGVuZDogZW5kQXJyLFxuXHQgICAgICBkZWx0YTogaC5jYWxjQXJyRGVsdGEoc3RhcnRBcnIsIGVuZEFyciksXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBudW1lcmljIGRlbHRhIHZhbHVlcyB3aXRoIHVuaXRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cblx0ICAgIEBwYXJhbSB7QW55fSBQcm9wZXJ0eSB2YWx1ZS5cblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBJbmRleCBvZiB0aGUgbW9kdWxlLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUGFyc2VkIGRlbHRhLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX3BhcnNlVW5pdERlbHRhID0gZnVuY3Rpb24gX3BhcnNlVW5pdERlbHRhKGtleSwgdmFsdWUsIGluZGV4KSB7XG5cdCAgICB2YXIgcHJlUGFyc2UgPSB0aGlzLl9wcmVwYXJzZURlbHRhKHZhbHVlKTtcblxuXHQgICAgdmFyIGVuZCA9IGgucGFyc2VVbml0KGgucGFyc2VTdHJpbmdPcHRpb24ocHJlUGFyc2UuZW5kLCBpbmRleCkpLFxuXHQgICAgICAgIHN0YXJ0ID0gaC5wYXJzZVVuaXQoaC5wYXJzZVN0cmluZ09wdGlvbihwcmVQYXJzZS5zdGFydCwgaW5kZXgpKTtcblxuXHQgICAgaC5tZXJnZVVuaXRzKHN0YXJ0LCBlbmQsIGtleSk7XG5cdCAgICB2YXIgZGVsdGEgPSB7XG5cdCAgICAgIHR5cGU6ICd1bml0Jyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kLFxuXHQgICAgICBkZWx0YTogZW5kLnZhbHVlIC0gc3RhcnQudmFsdWUsXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2UgbnVtZXJpYyBkZWx0YSB2YWx1ZXMgd2l0aG91dCB1bml0cy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gTmFtZSBvZiB0aGUgcHJvcGVydHkuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcGFyYW0ge051bWJlcn0gSW5kZXggb2YgdGhlIG1vZHVsZS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IFBhcnNlZCBkZWx0YS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wYXJzZU51bWJlckRlbHRhID0gZnVuY3Rpb24gX3BhcnNlTnVtYmVyRGVsdGEoa2V5LCB2YWx1ZSwgaW5kZXgpIHtcblx0ICAgIHZhciBwcmVQYXJzZSA9IHRoaXMuX3ByZXBhcnNlRGVsdGEodmFsdWUpO1xuXG5cdCAgICB2YXIgZW5kID0gcGFyc2VGbG9hdChoLnBhcnNlU3RyaW5nT3B0aW9uKHByZVBhcnNlLmVuZCwgaW5kZXgpKSxcblx0ICAgICAgICBzdGFydCA9IHBhcnNlRmxvYXQoaC5wYXJzZVN0cmluZ09wdGlvbihwcmVQYXJzZS5zdGFydCwgaW5kZXgpKTtcblxuXHQgICAgdmFyIGRlbHRhID0ge1xuXHQgICAgICB0eXBlOiAnbnVtYmVyJyxcblx0ICAgICAgbmFtZToga2V5LFxuXHQgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgIGVuZDogZW5kLFxuXHQgICAgICBkZWx0YTogZW5kIC0gc3RhcnQsXG5cdCAgICAgIGN1cnZlOiBwcmVQYXJzZS5jdXJ2ZVxuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIGRlbHRhO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBleHRyYWN0IGBjdXJ2ZWAgYW5kIGBzdGFydGAvYGVuZGAgdmFsdWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YSBvYmplY3QuXG5cdCAgICBAcmV0dXJucyB7T2JqZWN0fSBQcmVwYXJzZWQgZGVsdGEuXG5cdCAgICAgICAgICAgICAgQHByb3BlcnR5IHtTdHJpbmd9IFN0YXJ0IHZhbHVlLlxuXHQgICAgICAgICAgICAgIEBwcm9wZXJ0eSB7U3RyaW5nLCBOdW1iZXJ9IEVuZCB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBEZWx0YXMucHJvdG90eXBlLl9wcmVwYXJzZURlbHRhID0gZnVuY3Rpb24gX3ByZXBhcnNlRGVsdGEodmFsdWUpIHtcblx0ICAgIC8vIGNsb25lIHZhbHVlIG9iamVjdFxuXHQgICAgdmFsdWUgPSAoMCwgX2V4dGVuZHMzLmRlZmF1bHQpKHt9LCB2YWx1ZSk7XG5cdCAgICAvLyBwYXJzZSBjdXJ2ZSBpZiBleGlzdFxuXHQgICAgdmFyIGN1cnZlID0gdmFsdWUuY3VydmU7XG5cdCAgICBpZiAoY3VydmUgIT0gbnVsbCkge1xuXHQgICAgICBjdXJ2ZSA9IGVhc2luZy5wYXJzZUVhc2luZyhjdXJ2ZSk7XG5cdCAgICAgIGN1cnZlLl9wYXJlbnQgPSB0aGlzO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHZhbHVlLmN1cnZlO1xuXHQgICAgLy8gcGFyc2Ugc3RhcnQgYW5kIGVuZCB2YWx1ZXNcblx0ICAgIHZhciBzdGFydCA9ICgwLCBfa2V5czIuZGVmYXVsdCkodmFsdWUpWzBdLFxuXHQgICAgICAgIGVuZCA9IHZhbHVlW3N0YXJ0XTtcblxuXHQgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgY3VydmU6IGN1cnZlIH07XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGNvbG9yIGludG8gdXNhYmxlIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gQ29sb3Igc3RyaW5nLlxuXHQgICAgQHJldHVybnMge09iamVjdH0gUGFyc2VkIGNvbG9yIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIERlbHRhcy5wcm90b3R5cGUuX21ha2VDb2xvck9iaiA9IGZ1bmN0aW9uIF9tYWtlQ29sb3JPYmooY29sb3IpIHtcblx0ICAgIC8vIEhFWFxuXHQgICAgdmFyIGNvbG9yT2JqID0ge307XG5cdCAgICBpZiAoY29sb3JbMF0gPT09ICcjJykge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gL14jPyhbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KShbYS1mXFxkXXsxLDJ9KSQvaS5leGVjKGNvbG9yKTtcblx0ICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgIHZhciByID0gcmVzdWx0WzFdLmxlbmd0aCA9PT0gMiA/IHJlc3VsdFsxXSA6IHJlc3VsdFsxXSArIHJlc3VsdFsxXSxcblx0ICAgICAgICAgICAgZyA9IHJlc3VsdFsyXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMl0gOiByZXN1bHRbMl0gKyByZXN1bHRbMl0sXG5cdCAgICAgICAgICAgIGIgPSByZXN1bHRbM10ubGVuZ3RoID09PSAyID8gcmVzdWx0WzNdIDogcmVzdWx0WzNdICsgcmVzdWx0WzNdO1xuXG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChyLCAxNiksIGc6IHBhcnNlSW50KGcsIDE2KSwgYjogcGFyc2VJbnQoYiwgMTYpLCBhOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBub3QgSEVYXG5cdCAgICAvLyBzaG9ydGhhbmQgY29sb3IgYW5kIHJnYigpXG5cdCAgICBpZiAoY29sb3JbMF0gIT09ICcjJykge1xuXHQgICAgICB2YXIgaXNSZ2IgPSBjb2xvclswXSA9PT0gJ3InICYmIGNvbG9yWzFdID09PSAnZycgJiYgY29sb3JbMl0gPT09ICdiJztcblx0ICAgICAgdmFyIHJnYkNvbG9yID0gdW5kZWZpbmVkO1xuXHQgICAgICAvLyByZ2IgY29sb3Jcblx0ICAgICAgaWYgKGlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSBjb2xvcjtcblx0ICAgICAgfTtcblx0ICAgICAgLy8gc2hvcnRoYW5kIGNvbG9yIG5hbWVcblx0ICAgICAgaWYgKCFpc1JnYikge1xuXHQgICAgICAgIGlmICghdGhpcy5fc2hvcnRDb2xvcnNbY29sb3JdKSB7XG5cdCAgICAgICAgICBoLmRpdi5zdHlsZS5jb2xvciA9IGNvbG9yO1xuXHQgICAgICAgICAgcmdiQ29sb3IgPSBoLmNvbXB1dGVkU3R5bGUoaC5kaXYpLmNvbG9yO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICByZ2JDb2xvciA9IHRoaXMuX3Nob3J0Q29sb3JzW2NvbG9yXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcmVnZXhTdHJpbmcxID0gJ15yZ2JhP1xcXFwoKFxcXFxkezEsM30pLFxcXFxzPyhcXFxcZHsxLDN9KSwnLFxuXHQgICAgICAgICAgcmVnZXhTdHJpbmcyID0gJ1xcXFxzPyhcXFxcZHsxLDN9KSw/XFxcXHM/KFxcXFxkezF9fDA/XFxcXC5cXFxcZHsxLH0pP1xcXFwpJCcsXG5cdCAgICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nMSArIHJlZ2V4U3RyaW5nMiwgJ2dpJykuZXhlYyhyZ2JDb2xvciksXG5cdCAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQocmVzdWx0WzRdIHx8IDEpO1xuXG5cdCAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICBjb2xvck9iaiA9IHtcblx0ICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTApLFxuXHQgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcblx0ICAgICAgICAgIGE6IGFscGhhICE9IG51bGwgJiYgIWlzTmFOKGFscGhhKSA/IGFscGhhIDogMVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNvbG9yT2JqO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBzdHJpbmcgaW50byBhcnJheS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZywgTnVtYmVyfSBTdHJpbmcgb3IgbnVtYmVyIHRvIHBhcnNlLlxuXHQgICAgQHJldHVybnMge0FycmF5fSBQYXJzZWQgYXJyYXkuXG5cdCAgKi9cblxuXG5cdCAgRGVsdGFzLnByb3RvdHlwZS5fc3RyVG9BcnIgPSBmdW5jdGlvbiBfc3RyVG9BcnIoc3RyaW5nKSB7XG5cdCAgICB2YXIgYXJyID0gW107XG5cdCAgICAvLyBwbGFpbiBudW1iZXJcblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3RyaW5nKSkge1xuXHQgICAgICBhcnIucHVzaChoLnBhcnNlVW5pdChzdHJpbmcpKTtcblx0ICAgICAgcmV0dXJuIGFycjtcblx0ICAgIH1cblx0ICAgIC8vIHN0cmluZyBhcnJheVxuXHQgICAgc3RyaW5nLnRyaW0oKS5zcGxpdCgvXFxzKy9naW0pLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xuXHQgICAgICBhcnIucHVzaChoLnBhcnNlVW5pdChoLnBhcnNlSWZSYW5kKHN0cikpKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIGFycjtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIERlbHRhcztcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IERlbHRhcztcblxuLyoqKi8gfSxcbi8qIDE2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxuXHQgIEJhc2UgY2xhc3MgZm9yIG1vZHVsZS4gRXh0ZW5kcyBhbmQgcGFyc2VzIGRlZmF1bHRzLlxuXHQqL1xuXG5cdHZhciBNb2R1bGUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgZnVuY3Rpb24gTW9kdWxlKCkge1xuXHQgICAgdmFyIG8gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblx0ICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE1vZHVsZSk7XG5cblx0ICAgIC8vIHRoaXMuX2lzSXQgPSBvLmlzSXQ7XG5cdCAgICAvLyBkZWxldGUgby5pc0l0O1xuXHQgICAgdGhpcy5fbyA9IG87XG5cdCAgICB0aGlzLl9pbmRleCA9IHRoaXMuX28uaW5kZXggfHwgMDtcblx0ICAgIC8vIG1hcCBvZiBwcm9wcyB0aGF0IHNob3VsZCBiZVxuXHQgICAgLy8gcGFyc2VkIHRvIGFycmF5cyBvZiB2YWx1ZXNcblx0ICAgIHRoaXMuX2FycmF5UHJvcGVydHlNYXAgPSB7XG5cdCAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG5cdCAgICAgIHN0cm9rZURhc2hhcnJheTogMSxcblx0ICAgICAgb3JpZ2luOiAxXG5cdCAgICB9O1xuXG5cdCAgICB0aGlzLl9za2lwUHJvcHNEZWx0YSA9IHtcblx0ICAgICAgdGltZWxpbmU6IDEsXG5cdCAgICAgIHByZXZDaGFpbk1vZHVsZTogMSxcblx0ICAgICAgY2FsbGJhY2tzQ29udGV4dDogMVxuXHQgICAgfTtcblxuXHQgICAgdGhpcy5fZGVjbGFyZURlZmF1bHRzKCk7XG5cdCAgICB0aGlzLl9leHRlbmREZWZhdWx0cygpO1xuXG5cdCAgICB0aGlzLl92YXJzKCk7XG5cdCAgICB0aGlzLl9yZW5kZXIoKTtcblx0ICB9XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBkZWNsYXJlIGRlZmF1bHRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7fTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBtb2R1bGUncyB2YXJpYWJsZXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3ZhcnMgPSBmdW5jdGlvbiBfdmFycygpIHtcblx0ICAgIHRoaXMuX3Byb2dyZXNzID0gMDtcblx0ICAgIHRoaXMuX3N0cm9rZURhc2hhcnJheUJ1ZmZlciA9IFtdO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byByZW5kZXIgb24gaW5pdGlhbGl6YXRpb24uXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uIF9yZW5kZXIoKSB7fTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBwcm9wZXJ0eSBvbiB0aGUgbW9kdWxlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nLCBPYmplY3R9IE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Igb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBzZXQuXG5cdCAgICBAcGFyYW0ge0FueX0gVmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSB0byBzZXQuIENvdWxkIGJlXG5cdCAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCBpZiB0aGUgZmlyc3QgcGFyYW0gaXMgb2JqZWN0LlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3NldFByb3AgPSBmdW5jdGlvbiBfc2V0UHJvcChhdHRyLCB2YWx1ZSkge1xuXHQgICAgaWYgKCh0eXBlb2YgYXR0ciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShhdHRyKSkgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG5cdCAgICAgICAgdGhpcy5fYXNzaWduUHJvcChrZXksIGF0dHJba2V5XSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRoaXMuX2Fzc2lnblByb3AoYXR0ciwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhc3NpZ24gc2luZ2xlIHByb3BlcnR5J3MgdmFsdWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fYXNzaWduUHJvcCA9IGZ1bmN0aW9uIF9hc3NpZ25Qcm9wKGtleSwgdmFsdWUpIHtcblx0ICAgIHRoaXMuX3Byb3BzW2tleV0gPSB2YWx1ZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2hvdyBlbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9zaG93ID0gZnVuY3Rpb24gX3Nob3coKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKCF0aGlzLmVsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHAuaXNTb2Z0SGlkZSkge1xuXHQgICAgICAvLyB0aGlzLmVsLnN0eWxlLm9wYWNpdHkgPSBwLm9wYWNpdHk7XG5cdCAgICAgIHRoaXMuX3Nob3dCeVRyYW5zZm9ybSgpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGhpZGUgZWxlbWVudC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5faGlkZSA9IGZ1bmN0aW9uIF9oaWRlKCkge1xuXHQgICAgaWYgKCF0aGlzLmVsKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMuX3Byb3BzLmlzU29mdEhpZGUpIHtcblx0ICAgICAgLy8gdGhpcy5lbC5zdHlsZS5vcGFjaXR5ID0gMDtcblx0ICAgICAgX2gyLmRlZmF1bHQuc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmVsLCAndHJhbnNmb3JtJywgJ3NjYWxlKDApJyk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2hvdyBlbGVtZW50IGJ5IGFwcGx5aW5nIHRyYW5zZm9ybSBiYWNrIHRvIG5vcm1hbC5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fc2hvd0J5VHJhbnNmb3JtID0gZnVuY3Rpb24gX3Nob3dCeVRyYW5zZm9ybSgpIHt9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugb3B0aW9uIHN0cmluZy5cblx0ICAgIFNlYXJjaGVzIGZvciBzdGFnZ2VyIGFuZCByYW5kIHZhbHVlcyBhbmQgcGFyc2VzIHRoZW0uXG5cdCAgICBMZWF2ZXMgdGhlIHZhbHVlIHVuYXR0ZW5kZWQgb3RoZXJ3aXNlLlxuXHQgICAgQHBhcmFtIHtBbnl9IE9wdGlvbiB2YWx1ZSB0byBwYXJzZS5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IFBhcnNlZCBvcHRpb25zIHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlT3B0aW9uU3RyaW5nID0gZnVuY3Rpb24gX3BhcnNlT3B0aW9uU3RyaW5nKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICBpZiAodmFsdWUubWF0Y2goL3N0YWdnZXIvKSkge1xuXHQgICAgICAgIHZhbHVlID0gX2gyLmRlZmF1bHQucGFyc2VTdGFnZ2VyKHZhbHVlLCB0aGlzLl9pbmRleCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmICh2YWx1ZS5tYXRjaCgvcmFuZC8pKSB7XG5cdCAgICAgICAgdmFsdWUgPSBfaDIuZGVmYXVsdC5wYXJzZVJhbmQodmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHBvc3Rpb24gb3B0aW9uLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgVmFsdWUuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBQYXJzZWQgb3B0aW9ucyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVBvc2l0aW9uT3B0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb25PcHRpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgaWYgKF9oMi5kZWZhdWx0LnVuaXRPcHRpb25NYXBba2V5XSkge1xuXHQgICAgICB2YWx1ZSA9IF9oMi5kZWZhdWx0LnBhcnNlVW5pdCh2YWx1ZSkuc3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBzdHJva2VEYXNoLi4gb3B0aW9uLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBQYXJzZWQgb3B0aW9ucyB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVN0cm9rZURhc2hPcHRpb24gPSBmdW5jdGlvbiBfcGFyc2VTdHJva2VEYXNoT3B0aW9uKGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciByZXN1bHQgPSB2YWx1ZTtcblx0ICAgIC8vIHBhcnNlIG51bWVyaWMvcGVyY2VudCB2YWx1ZXMgZm9yIHN0cm9rZURhc2guLiBwcm9wZXJ0aWVzXG5cdCAgICBpZiAodGhpcy5fYXJyYXlQcm9wZXJ0eU1hcFtrZXldKSB7XG5cdCAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkodmFsdWUpKSB7XG5cdCAgICAgICAgY2FzZSAnbnVtYmVyJzpcblx0ICAgICAgICAgIHJlc3VsdC5wdXNoKF9oMi5kZWZhdWx0LnBhcnNlVW5pdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgY2FzZSAnc3RyaW5nJzpcblx0ICAgICAgICAgIHZhciBhcnJheSA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9oMi5kZWZhdWx0LnBhcnNlVW5pdChhcnJheVtpXSkpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWx0YSBwcm9wZXJ0eS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUGFyYW1ldGVyIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59XG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5faXNEZWx0YSA9IGZ1bmN0aW9uIF9pc0RlbHRhKG9wdGlvbnNWYWx1ZSkge1xuXHQgICAgdmFyIGlzT2JqZWN0ID0gX2gyLmRlZmF1bHQuaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IF9oMi5kZWZhdWx0LmlzQXJyYXkob3B0aW9uc1ZhbHVlKSB8fCBfaDIuZGVmYXVsdC5pc0RPTShvcHRpb25zVmFsdWUpKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZ2V0IGRlbHRhIGZyb20gcHJvcGVydHkgYW5kIHNldFxuXHQgICAgdGhlIHByb3BlcnR5J3Mgc3RhcnQgdmFsdWUgdG8gdGhlIHByb3BzIG9iamVjdC5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge1N0cmluZ30gS2V5IG5hbWUgdG8gZ2V0IGRlbHRhIGZvci5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb24gdmFsdWUgdG8gZ2V0IHRoZSBkZWx0YSBmb3IuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fZ2V0RGVsdGEgPSBmdW5jdGlvbiBfZ2V0RGVsdGEoa2V5LCBvcHRpb25zVmFsdWUpIHtcblx0ICAgIHZhciBkZWx0YTtcblx0ICAgIGlmICgoa2V5ID09PSAnbGVmdCcgfHwga2V5ID09PSAndG9wJykgJiYgIXRoaXMuX28uY3R4KSB7XG5cdCAgICAgIF9oMi5kZWZhdWx0Lndhcm4oJ0NvbnNpZGVyIHRvIGFuaW1hdGUgeC95IHByb3BlcnRpZXMgaW5zdGVhZCBvZiBsZWZ0L3RvcCxcXG4gICAgICAgIGFzIGl0IHdvdWxkIGJlIG11Y2ggbW9yZSBwZXJmb3JtYW50Jywgb3B0aW9uc1ZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIHNraXAgZGVsdGEgY2FsY3VsYXRpb24gZm9yIGEgcHJvcGVydHkgaWYgaXQgaXMgbGlzdGVkXG5cdCAgICAvLyBpbiBza2lwUHJvcHNEZWx0YSBvYmplY3Rcblx0ICAgIGlmICh0aGlzLl9za2lwUHJvcHNEZWx0YSAmJiB0aGlzLl9za2lwUHJvcHNEZWx0YVtrZXldKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIGdldCBkZWx0YVxuXHQgICAgZGVsdGEgPSBfaDIuZGVmYXVsdC5wYXJzZURlbHRhKGtleSwgb3B0aW9uc1ZhbHVlLCB0aGlzLl9pbmRleCk7XG5cdCAgICAvLyBpZiBzdWNjZXNzZnVsbHkgcGFyc2VkIC0gc2F2ZSBpdFxuXHQgICAgaWYgKGRlbHRhLnR5cGUgIT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9kZWx0YXNba2V5XSA9IGRlbHRhO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZGVsdGFFbmQgPSAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoZGVsdGEuZW5kKSA9PT0gJ29iamVjdCcgPyBkZWx0YS5lbmQudmFsdWUgPT09IDAgPyAwIDogZGVsdGEuZW5kLnN0cmluZyA6IGRlbHRhLmVuZDtcblx0ICAgIC8vIHNldCBwcm9wcyB0byBlbmQgdmFsdWUgb2YgdGhlIGRlbHRhXG5cdCAgICAvLyAwIHNob3VsZCBiZSAwIHJlZ2FyZGxlc3MgdW5pdHNcblx0ICAgIHRoaXMuX3Byb3BzW2tleV0gPSBkZWx0YUVuZDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gY29weSBgX29gIG9wdGlvbnMgdG8gYF9wcm9wc2Agb2JqZWN0XG5cdCAgICB3aXRoIGZhbGxiYWNrIHRvIGBfZGVmYXVsdHNgLlxuXHQgICAgQHByaXZhdGVcblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9leHRlbmREZWZhdWx0cyA9IGZ1bmN0aW9uIF9leHRlbmREZWZhdWx0cygpIHtcblx0ICAgIHRoaXMuX3Byb3BzID0ge307XG5cdCAgICB0aGlzLl9kZWx0YXMgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHQgICAgICAvLyBza2lwIHByb3BlcnR5IGlmIGl0IGlzIGxpc3RlZCBpbiBfc2tpcFByb3BzXG5cdCAgICAgIC8vIGlmICh0aGlzLl9za2lwUHJvcHMgJiYgdGhpcy5fc2tpcFByb3BzW2tleV0pIHsgY29udGludWU7IH1cblx0ICAgICAgLy8gY29weSB0aGUgcHJvcGVydGllcyB0byB0aGUgX28gb2JqZWN0XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX29ba2V5XSAhPSBudWxsID8gdGhpcy5fb1trZXldIDogdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0ICAgICAgLy8gcGFyc2Ugb3B0aW9uXG5cdCAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGtleSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byB0dW5lIG5ldyBvcHJpb25zIHRvIF9vIGFuZCBfcHJvcHMgb2JqZWN0LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBPcHRpb25zIG9iamVjdCB0byB0dW5lIHRvLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3R1bmVOZXdPcHRpb25zID0gZnVuY3Rpb24gX3R1bmVOZXdPcHRpb25zKG8pIHtcblx0ICAgIC8vIGhpZGUgdGhlIG1vZHVsZSBiZWZvcmUgdHVuaW5nIGl0J3Mgb3B0aW9uc1xuXHQgICAgLy8gY3V6IHRoZSB1c2VyIGNvdWxkIHNlZSB0aGUgY2hhbmdlXG5cdCAgICB0aGlzLl9oaWRlKCk7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gbykge1xuXHQgICAgICAvLyBza2lwIHByb3BlcnR5IGlmIGl0IGlzIGxpc3RlZCBpbiBfc2tpcFByb3BzXG5cdCAgICAgIC8vIGlmICh0aGlzLl9za2lwUHJvcHMgJiYgdGhpcy5fc2tpcFByb3BzW2tleV0pIHsgY29udGludWU7IH1cblx0ICAgICAgLy8gY29weSB0aGUgcHJvcGVydGllcyB0byB0aGUgX28gb2JqZWN0XG5cdCAgICAgIC8vIGRlbGV0ZSB0aGUga2V5IGZyb20gZGVsdGFzXG5cdCAgICAgIG8gJiYgZGVsZXRlIHRoaXMuX2RlbHRhc1trZXldO1xuXHQgICAgICAvLyByZXdyaXRlIF9vIHJlY29yZFxuXHQgICAgICB0aGlzLl9vW2tleV0gPSBvW2tleV07XG5cdCAgICAgIC8vIHNhdmUgdGhlIG9wdGlvbnMgdG8gX3Byb3BzXG5cdCAgICAgIHRoaXMuX3BhcnNlT3B0aW9uKGtleSwgb1trZXldKTtcblx0ICAgIH1cblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gcGFyc2Ugb3B0aW9uIHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBPcHRpb24gbmFtZS5cblx0ICAgIEBwYXJhbSB7QW55fSBPcHRpb24gdmFsdWUuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VPcHRpb24gPSBmdW5jdGlvbiBfcGFyc2VPcHRpb24obmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIGlmIGRlbHRhIHByb3BlcnR5XG5cdCAgICBpZiAodGhpcy5faXNEZWx0YSh2YWx1ZSkgJiYgIXRoaXMuX3NraXBQcm9wc0RlbHRhW25hbWVdKSB7XG5cdCAgICAgIHRoaXMuX2dldERlbHRhKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgdmFyIGRlbHRhRW5kID0gX2gyLmRlZmF1bHQuZ2V0RGVsdGFFbmQodmFsdWUpO1xuXHQgICAgICByZXR1cm4gdGhpcy5fYXNzaWduUHJvcChuYW1lLCB0aGlzLl9wYXJzZVByb3BlcnR5KG5hbWUsIGRlbHRhRW5kKSk7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX2Fzc2lnblByb3AobmFtZSwgdGhpcy5fcGFyc2VQcm9wZXJ0eShuYW1lLCB2YWx1ZSkpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBwYXJzZSBwb3N0aW9uIGFuZCBzdHJpbmcgcHJvcHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUuXG5cdCAgICBAcGFyYW0ge0FueX0gICAgUHJvcGVydHkgdmFsdWUuXG5cdCAgICBAcmV0dXJucyB7QW55fSAgUGFyc2VkIHByb3BlcnR5IHZhbHVlLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9wYXJzZVByZUFycmF5UHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIHBhcnNlIHN0YWdnZXIgYW5kIHJhbmQgdmFsdWVzXG5cdCAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlT3B0aW9uU3RyaW5nKHZhbHVlKTtcblx0ICAgIC8vIHBhcnNlIHVuaXRzIGZvciBwb3NpdGlvbiBwcm9wZXJ0aWVzXG5cdCAgICByZXR1cm4gdGhpcy5fcGFyc2VQb3NpdGlvbk9wdGlvbihuYW1lLCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gIFBhcnNlZCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wYXJzZVByb3BlcnR5ID0gZnVuY3Rpb24gX3BhcnNlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblx0ICAgIC8vIHBhcnNlIGBIVE1MYCBlbGVtZW50IGluIGBwYXJlbnRgIG9wdGlvblxuXHQgICAgaWYgKG5hbWUgPT09ICdwYXJlbnQnKSB7XG5cdCAgICAgIHJldHVybiBfaDIuZGVmYXVsdC5wYXJzZUVsKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIHBhcnNlIGBzdGFnZ2VyYCwgYHJhbmRgIGFuZCBgcG9zaXRpb25gXG5cdCAgICB2YWx1ZSA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cdCAgICAvLyBwYXJzZSBudW1lcmljL3BlcmNlbnQgdmFsdWVzIGZvciBzdHJva2VEYXNoLi4gcHJvcGVydGllc1xuXHQgICAgcmV0dXJuIHRoaXMuX3BhcnNlU3Ryb2tlRGFzaE9wdGlvbihuYW1lLCB2YWx1ZSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHZhbHVlcyBpbnNpZGUg4oiGLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBLZXkgbmFtZS5cblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBEZWx0YS5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IERlbHRhIHdpdGggcGFyc2VkIHBhcmFtZXRlcnMuXG5cdCAgKi9cblxuXG5cdCAgTW9kdWxlLnByb3RvdHlwZS5fcGFyc2VEZWx0YVZhbHVlcyA9IGZ1bmN0aW9uIF9wYXJzZURlbHRhVmFsdWVzKG5hbWUsIGRlbHRhKSB7XG5cdCAgICAvLyByZXR1cm4gaC5wYXJzZURlbHRhKCBuYW1lLCBkZWx0YSwgdGhpcy5faW5kZXggKTtcblxuXHQgICAgdmFyIGQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBkZWx0YSkge1xuXHQgICAgICB2YXIgdmFsdWUgPSBkZWx0YVtrZXldO1xuXG5cdCAgICAgIC8vIGRlbGV0ZSBkZWx0YVtrZXldO1xuXHQgICAgICAvLyBhZGQgcGFyc2VkIHByb3BlcnRpZXNcblx0ICAgICAgdmFyIG5ld0VuZCA9IHRoaXMuX3BhcnNlUHJlQXJyYXlQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG5cdCAgICAgIGRbdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KG5hbWUsIGtleSldID0gbmV3RW5kO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGQ7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIGRlbHRhIGFuZCBub25kZWx0YSBwcm9wZXJ0aWVzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lLlxuXHQgICAgQHBhcmFtIHtBbnl9ICAgIFByb3BlcnR5IHZhbHVlLlxuXHQgICAgQHJldHVybnMge0FueX0gIFBhcnNlZCBwcm9wZXJ0eSB2YWx1ZS5cblx0ICAqL1xuXG5cblx0ICBNb2R1bGUucHJvdG90eXBlLl9wcmVwYXJzZVByb3BWYWx1ZSA9IGZ1bmN0aW9uIF9wcmVwYXJzZVByb3BWYWx1ZShrZXksIHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdGhpcy5faXNEZWx0YSh2YWx1ZSkgPyB0aGlzLl9wYXJzZURlbHRhVmFsdWVzKGtleSwgdmFsdWUpIDogdGhpcy5fcGFyc2VQcmVBcnJheVByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgZGVsdGFzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBjYWxjdWxhdGUgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gY2FsY3VsYXRlIC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX2NhbGNDdXJyZW50UHJvcHMgPSBmdW5jdGlvbiBfY2FsY0N1cnJlbnRQcm9wcyhlYXNlZFByb2dyZXNzLCBwKSB7XG5cblx0ICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9kZWx0YXMpIHtcblxuXHQgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9kZWx0YXNba2V5XTtcblxuXHQgICAgICAvLyBnZXQgZWFzZWQgcHJvZ3Jlc3MgZnJvbSBkZWx0YSBlYXNpbmcgaWYgZGVmaW5lZCBhbmQgbm90IGN1cnZlXG5cdCAgICAgIHZhciBpc0N1cnZlID0gISF2YWx1ZS5jdXJ2ZTtcblx0ICAgICAgdmFyIGVwID0gdmFsdWUuZWFzaW5nICE9IG51bGwgJiYgIWlzQ3VydmUgPyB2YWx1ZS5lYXNpbmcocCkgOiBlYXNlZFByb2dyZXNzO1xuXG5cdCAgICAgIGlmICh2YWx1ZS50eXBlID09PSAnYXJyYXknKSB7XG5cdCAgICAgICAgdmFyIGFycjtcblx0ICAgICAgICAvLyBpZiBwcm9wIHByb3BlcnR5IGlzIGFycmF5IC0gcmV1c2UgaXQgZWxzZSAtIGNyZWF0ZSBhbiBhcnJheVxuXHQgICAgICAgIGlmIChfaDIuZGVmYXVsdC5pc0FycmF5KHRoaXMuX3Byb3BzW2tleV0pKSB7XG5cdCAgICAgICAgICBhcnIgPSB0aGlzLl9wcm9wc1trZXldO1xuXHQgICAgICAgICAgYXJyLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGFyciA9IFtdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGp1c3Qgb3B0aW1pemF0aW9uIHRvIHByZXZlbnQgY3VydmVcblx0ICAgICAgICAvLyBjYWxjdWxhdGlvbnMgb24gZXZlcnkgYXJyYXkgaXRlbVxuXHQgICAgICAgIHZhciBwcm9jID0gaXNDdXJ2ZSA/IHZhbHVlLmN1cnZlKHApIDogbnVsbDtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUuZGVsdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIHZhciBpdGVtID0gdmFsdWUuZGVsdGFbaV0sXG5cdCAgICAgICAgICAgICAgZGFzaCA9ICFpc0N1cnZlID8gdmFsdWUuc3RhcnRbaV0udmFsdWUgKyBlcCAqIGl0ZW0udmFsdWUgOiBwcm9jICogKHZhbHVlLnN0YXJ0W2ldLnZhbHVlICsgcCAqIGl0ZW0udmFsdWUpO1xuXHQgICAgICAgICAgYXJyLnB1c2goe1xuXHQgICAgICAgICAgICBzdHJpbmc6ICcnICsgZGFzaCArIGl0ZW0udW5pdCxcblx0ICAgICAgICAgICAgdmFsdWU6IGRhc2gsXG5cdCAgICAgICAgICAgIHVuaXQ6IGl0ZW0udW5pdFxuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9IGFycjtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIHRoaXMuX3Byb3BzW2tleV0gPSAhaXNDdXJ2ZSA/IHZhbHVlLnN0YXJ0ICsgZXAgKiB2YWx1ZS5kZWx0YSA6IHZhbHVlLmN1cnZlKHApICogKHZhbHVlLnN0YXJ0ICsgcCAqIHZhbHVlLmRlbHRhKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAndW5pdCcpIHtcblx0ICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gIWlzQ3VydmUgPyB2YWx1ZS5zdGFydC52YWx1ZSArIGVwICogdmFsdWUuZGVsdGEgOiB2YWx1ZS5jdXJ2ZShwKSAqICh2YWx1ZS5zdGFydC52YWx1ZSArIHAgKiB2YWx1ZS5kZWx0YSk7XG5cblx0ICAgICAgICB0aGlzLl9wcm9wc1trZXldID0gJycgKyBjdXJyZW50VmFsdWUgKyB2YWx1ZS5lbmQudW5pdDtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZS50eXBlID09PSAnY29sb3InKSB7XG5cdCAgICAgICAgdmFyIHIsIGcsIGIsIGE7XG5cdCAgICAgICAgaWYgKCFpc0N1cnZlKSB7XG5cdCAgICAgICAgICByID0gcGFyc2VJbnQodmFsdWUuc3RhcnQuciArIGVwICogdmFsdWUuZGVsdGEuciwgMTApO1xuXHQgICAgICAgICAgZyA9IHBhcnNlSW50KHZhbHVlLnN0YXJ0LmcgKyBlcCAqIHZhbHVlLmRlbHRhLmcsIDEwKTtcblx0ICAgICAgICAgIGIgPSBwYXJzZUludCh2YWx1ZS5zdGFydC5iICsgZXAgKiB2YWx1ZS5kZWx0YS5iLCAxMCk7XG5cdCAgICAgICAgICBhID0gcGFyc2VGbG9hdCh2YWx1ZS5zdGFydC5hICsgZXAgKiB2YWx1ZS5kZWx0YS5hKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIGNwID0gdmFsdWUuY3VydmUocCk7XG5cdCAgICAgICAgICByID0gcGFyc2VJbnQoY3AgKiAodmFsdWUuc3RhcnQuciArIHAgKiB2YWx1ZS5kZWx0YS5yKSwgMTApO1xuXHQgICAgICAgICAgZyA9IHBhcnNlSW50KGNwICogKHZhbHVlLnN0YXJ0LmcgKyBwICogdmFsdWUuZGVsdGEuZyksIDEwKTtcblx0ICAgICAgICAgIGIgPSBwYXJzZUludChjcCAqICh2YWx1ZS5zdGFydC5iICsgcCAqIHZhbHVlLmRlbHRhLmIpLCAxMCk7XG5cdCAgICAgICAgICBhID0gcGFyc2VGbG9hdChjcCAqICh2YWx1ZS5zdGFydC5hICsgcCAqIHZhbHVlLmRlbHRhLmEpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5fcHJvcHNba2V5XSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNhbGN1bGF0ZSBjdXJyZW50IHByb2dyZXNzIGFuZCBwcm9iYWJseSBkcmF3IGl0IGluIGNoaWxkcmVuLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBFYXNlZCBwcm9ncmVzcyB0byBzZXQgLSBbMC4uMV0uXG5cdCAgICBAcGFyYW0ge051bWJlcn0gUHJvZ3Jlc3MgdG8gc2V0IC0gWzAuLjFdLlxuXHQgICovXG5cblxuXHQgIE1vZHVsZS5wcm90b3R5cGUuX3NldFByb2dyZXNzID0gZnVuY3Rpb24gX3NldFByb2dyZXNzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKSB7XG5cdCAgICB0aGlzLl9wcm9ncmVzcyA9IGVhc2VkUHJvZ3Jlc3M7XG5cdCAgICB0aGlzLl9jYWxjQ3VycmVudFByb3BzKGVhc2VkUHJvZ3Jlc3MsIHByb2dyZXNzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIE1vZHVsZTtcblx0fSgpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsZTtcblxuLyoqKi8gfSxcbi8qIDE3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdFx0bW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1vZHVsZTtcclxuXHR9XHJcblxuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX1N5bWJvbCRpdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9TeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9TeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfaXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuXHR2YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxuXHR2YXIgX3N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG5cdHZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcblx0ICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG5cdH0gOiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgSGVscGVycywgaDtcblxuXHRIZWxwZXJzID0gKGZ1bmN0aW9uKCkge1xuXHQgIEhlbHBlcnMucHJvdG90eXBlLk5TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmxvZ0JhZGdlQ3NzID0gJ2JhY2tncm91bmQ6IzNBMDgzOTtjb2xvcjojRkY1MTJGO2JvcmRlci1yYWRpdXM6NXB4OyBwYWRkaW5nOiAxcHggNXB4IDJweDsgYm9yZGVyOiAxcHggc29saWQgI0ZGNTEyRjsnO1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuc2hvcnRDb2xvcnMgPSB7XG5cdCAgICB0cmFuc3BhcmVudDogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgbm9uZTogJ3JnYmEoMCwwLDAsMCknLFxuXHQgICAgYXF1YTogJ3JnYigwLDI1NSwyNTUpJyxcblx0ICAgIGJsYWNrOiAncmdiKDAsMCwwKScsXG5cdCAgICBibHVlOiAncmdiKDAsMCwyNTUpJyxcblx0ICAgIGZ1Y2hzaWE6ICdyZ2IoMjU1LDAsMjU1KScsXG5cdCAgICBncmF5OiAncmdiKDEyOCwxMjgsMTI4KScsXG5cdCAgICBncmVlbjogJ3JnYigwLDEyOCwwKScsXG5cdCAgICBsaW1lOiAncmdiKDAsMjU1LDApJyxcblx0ICAgIG1hcm9vbjogJ3JnYigxMjgsMCwwKScsXG5cdCAgICBuYXZ5OiAncmdiKDAsMCwxMjgpJyxcblx0ICAgIG9saXZlOiAncmdiKDEyOCwxMjgsMCknLFxuXHQgICAgcHVycGxlOiAncmdiKDEyOCwwLDEyOCknLFxuXHQgICAgcmVkOiAncmdiKDI1NSwwLDApJyxcblx0ICAgIHNpbHZlcjogJ3JnYigxOTIsMTkyLDE5MiknLFxuXHQgICAgdGVhbDogJ3JnYigwLDEyOCwxMjgpJyxcblx0ICAgIHdoaXRlOiAncmdiKDI1NSwyNTUsMjU1KScsXG5cdCAgICB5ZWxsb3c6ICdyZ2IoMjU1LDI1NSwwKScsXG5cdCAgICBvcmFuZ2U6ICdyZ2IoMjU1LDEyOCwwKSdcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2hhaW5PcHRpb25NYXAgPSB7fTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNhbGxiYWNrc01hcCA9IHtcblx0ICAgIG9uUmVmcmVzaDogMSxcblx0ICAgIG9uU3RhcnQ6IDEsXG5cdCAgICBvbkNvbXBsZXRlOiAxLFxuXHQgICAgb25GaXJzdFVwZGF0ZTogMSxcblx0ICAgIG9uVXBkYXRlOiAxLFxuXHQgICAgb25Qcm9ncmVzczogMSxcblx0ICAgIG9uUmVwZWF0U3RhcnQ6IDEsXG5cdCAgICBvblJlcGVhdENvbXBsZXRlOiAxLFxuXHQgICAgb25QbGF5YmFja1N0YXJ0OiAxLFxuXHQgICAgb25QbGF5YmFja1BhdXNlOiAxLFxuXHQgICAgb25QbGF5YmFja1N0b3A6IDEsXG5cdCAgICBvblBsYXliYWNrQ29tcGxldGU6IDFcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUudHdlZW5PcHRpb25NYXAgPSB7XG5cdCAgICBkdXJhdGlvbjogMSxcblx0ICAgIGRlbGF5OiAxLFxuXHQgICAgc3BlZWQ6IDEsXG5cdCAgICByZXBlYXQ6IDEsXG5cdCAgICBlYXNpbmc6IDEsXG5cdCAgICBiYWNrd2FyZEVhc2luZzogMSxcblx0ICAgIGlzWW95bzogMSxcblx0ICAgIHNoaWZ0VGltZTogMSxcblx0ICAgIGlzUmV2ZXJzZWQ6IDEsXG5cdCAgICBjYWxsYmFja3NDb250ZXh0OiAxXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnVuaXRPcHRpb25NYXAgPSB7XG5cdCAgICBsZWZ0OiAxLFxuXHQgICAgdG9wOiAxLFxuXHQgICAgeDogMSxcblx0ICAgIHk6IDEsXG5cdCAgICByeDogMSxcblx0ICAgIHJ5OiAxXG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuXG5cdCAgZnVuY3Rpb24gSGVscGVycygpIHtcblx0ICAgIHRoaXMudmFycygpO1xuXHQgIH1cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciB1YTtcblx0ICAgIHRoaXMucHJlZml4ID0gdGhpcy5nZXRQcmVmaXgoKTtcblx0ICAgIHRoaXMuZ2V0UmVtQmFzZSgpO1xuXHQgICAgdGhpcy5pc0ZGID0gdGhpcy5wcmVmaXgubG93ZXJjYXNlID09PSAnbW96Jztcblx0ICAgIHRoaXMuaXNJRSA9IHRoaXMucHJlZml4Lmxvd2VyY2FzZSA9PT0gJ21zJztcblx0ICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblx0ICAgIHRoaXMuaXNPbGRPcGVyYSA9IHVhLm1hdGNoKC9wcmVzdG8vZ2ltKTtcblx0ICAgIHRoaXMuaXNTYWZhcmkgPSB1YS5pbmRleE9mKCdTYWZhcmknKSA+IC0xO1xuXHQgICAgdGhpcy5pc0Nocm9tZSA9IHVhLmluZGV4T2YoJ0Nocm9tZScpID4gLTE7XG5cdCAgICB0aGlzLmlzT3BlcmEgPSB1YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJvcFwiKSA+IC0xO1xuXHQgICAgdGhpcy5pc0Nocm9tZSAmJiB0aGlzLmlzU2FmYXJpICYmICh0aGlzLmlzU2FmYXJpID0gZmFsc2UpO1xuXHQgICAgKHVhLm1hdGNoKC9QaGFudG9tSlMvZ2ltKSkgJiYgKHRoaXMuaXNTYWZhcmkgPSBmYWxzZSk7XG5cdCAgICB0aGlzLmlzQ2hyb21lICYmIHRoaXMuaXNPcGVyYSAmJiAodGhpcy5pc0Nocm9tZSA9IGZhbHNlKTtcblx0ICAgIHRoaXMuaXMzZCA9IHRoaXMuY2hlY2tJZjNkKCk7XG5cdCAgICB0aGlzLnVuaXFJRHMgPSAtMTtcblx0ICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdCAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcblx0ICAgIHJldHVybiB0aGlzLmRlZmF1bHRTdHlsZXMgPSB0aGlzLmNvbXB1dGVkU3R5bGUodGhpcy5kaXYpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jbG9uZU9iaiA9IGZ1bmN0aW9uKG9iaiwgZXhjbHVkZSkge1xuXHQgICAgdmFyIGksIGtleSwga2V5cywgbmV3T2JqO1xuXHQgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdCAgICBuZXdPYmogPSB7fTtcblx0ICAgIGkgPSBrZXlzLmxlbmd0aDtcblx0ICAgIHdoaWxlIChpLS0pIHtcblx0ICAgICAga2V5ID0ga2V5c1tpXTtcblx0ICAgICAgaWYgKGV4Y2x1ZGUgIT0gbnVsbCkge1xuXHQgICAgICAgIGlmICghZXhjbHVkZVtrZXldKSB7XG5cdCAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmV3T2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihvYmpUbywgb2JqRnJvbSkge1xuXHQgICAgdmFyIGtleSwgdmFsdWU7XG5cdCAgICBmb3IgKGtleSBpbiBvYmpGcm9tKSB7XG5cdCAgICAgIHZhbHVlID0gb2JqRnJvbVtrZXldO1xuXHQgICAgICBpZiAob2JqVG9ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgb2JqVG9ba2V5XSA9IG9iakZyb21ba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9ialRvO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRSZW1CYXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgaHRtbCwgc3R5bGU7XG5cdCAgICBodG1sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpO1xuXHQgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVtQmFzZSA9IHBhcnNlRmxvYXQoc3R5bGUuZm9udFNpemUpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jbGFtcCA9IGZ1bmN0aW9uKHZhbHVlLCBtaW4sIG1heCkge1xuXHQgICAgaWYgKHZhbHVlIDwgbWluKSB7XG5cdCAgICAgIHJldHVybiBtaW47XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4KSB7XG5cdCAgICAgIHJldHVybiBtYXg7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnNldFByZWZpeGVkU3R5bGUgPSBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIChuYW1lID09PSAndHJhbnNmb3JtJykgJiYgKGVsLnN0eWxlW1wiXCIgKyB0aGlzLnByZWZpeC5jc3MgKyBuYW1lXSA9IHZhbHVlKTtcblx0ICAgIHJldHVybiBlbC5zdHlsZVtuYW1lXSA9IHZhbHVlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHQgICAgdmFyIGtleSwga2V5cywgbGVuLCByZXN1bHRzO1xuXHQgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuXHQgICAgICBrZXlzID0gT2JqZWN0LmtleXMobmFtZSk7XG5cdCAgICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgICAgIGtleSA9IGtleXNbbGVuXTtcblx0ICAgICAgICB2YWx1ZSA9IG5hbWVba2V5XTtcblx0ICAgICAgICByZXN1bHRzLnB1c2godGhpcy5zZXRQcmVmaXhlZFN0eWxlKGVsLCBrZXksIHZhbHVlKSk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5zZXRQcmVmaXhlZFN0eWxlKGVsLCBuYW1lLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnByZXBhcmVGb3JMb2cgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3MpO1xuXHQgICAgYXJncy51bnNoaWZ0KCc6OicpO1xuXHQgICAgYXJncy51bnNoaWZ0KHRoaXMubG9nQmFkZ2VDc3MpO1xuXHQgICAgYXJncy51bnNoaWZ0KCclY21vwrdqcyVjJyk7XG5cdCAgICByZXR1cm4gYXJncztcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAobW9qcy5pc0RlYnVnID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgdGhpcy5wcmVwYXJlRm9yTG9nKGFyZ3VtZW50cykpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24oKSB7XG5cdCAgICBpZiAobW9qcy5pc0RlYnVnID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIHRoaXMucHJlcGFyZUZvckxvZyhhcmd1bWVudHMpKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbigpIHtcblx0ICAgIGlmIChtb2pzLmlzRGVidWcgPT09IGZhbHNlKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIHRoaXMucHJlcGFyZUZvckxvZyhhcmd1bWVudHMpKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VVbml0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgIHZhciBhbW91bnQsIGlzU3RyaWN0LCByZWYsIHJlZ2V4LCByZXR1cm5WYWwsIHVuaXQ7XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gcmV0dXJuVmFsID0ge1xuXHQgICAgICAgIHVuaXQ6ICdweCcsXG5cdCAgICAgICAgaXNTdHJpY3Q6IGZhbHNlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICBzdHJpbmc6IHZhbHVlID09PSAwID8gXCJcIiArIHZhbHVlIDogdmFsdWUgKyBcInB4XCJcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICByZWdleCA9IC9weHwlfHJlbXxlbXxleHxjbXxjaHxtbXxpbnxwdHxwY3x2aHx2d3x2bWlufGRlZy9naW07XG5cdCAgICAgIHVuaXQgPSAocmVmID0gdmFsdWUubWF0Y2gocmVnZXgpKSAhPSBudWxsID8gcmVmWzBdIDogdm9pZCAwO1xuXHQgICAgICBpc1N0cmljdCA9IHRydWU7XG5cdCAgICAgIGlmICghdW5pdCkge1xuXHQgICAgICAgIHVuaXQgPSAncHgnO1xuXHQgICAgICAgIGlzU3RyaWN0ID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdCAgICAgIHJldHVybiByZXR1cm5WYWwgPSB7XG5cdCAgICAgICAgdW5pdDogdW5pdCxcblx0ICAgICAgICBpc1N0cmljdDogaXNTdHJpY3QsXG5cdCAgICAgICAgdmFsdWU6IGFtb3VudCxcblx0ICAgICAgICBzdHJpbmc6IGFtb3VudCA9PT0gMCA/IFwiXCIgKyBhbW91bnQgOiBcIlwiICsgYW1vdW50ICsgdW5pdFxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuXHQgICAgdmFyIGJpbmRBcmdzLCB3cmFwcGVyO1xuXHQgICAgd3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgYXJncywgdW5zaGlmdEFyZ3M7XG5cdCAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICB1bnNoaWZ0QXJncyA9IGJpbmRBcmdzLmNvbmNhdChhcmdzKTtcblx0ICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgdW5zaGlmdEFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIGJpbmRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0ICAgIHJldHVybiB3cmFwcGVyO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRSYWRpYWxQb2ludCA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBwb2ludCwgcmFkQW5nbGUsIHJhZGl1c1gsIHJhZGl1c1k7XG5cdCAgICBpZiAobyA9PSBudWxsKSB7XG5cdCAgICAgIG8gPSB7fTtcblx0ICAgIH1cblx0ICAgIHJhZEFuZ2xlID0gKG8uYW5nbGUgLSA5MCkgKiAwLjAxNzQ1MzI5MjUxOTk0MzI5NTtcblx0ICAgIHJhZGl1c1ggPSBvLnJhZGl1c1ggIT0gbnVsbCA/IG8ucmFkaXVzWCA6IG8ucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IG8ucmFkaXVzWSAhPSBudWxsID8gby5yYWRpdXNZIDogby5yYWRpdXM7XG5cdCAgICByZXR1cm4gcG9pbnQgPSB7XG5cdCAgICAgIHg6IG8uY2VudGVyLnggKyAoTWF0aC5jb3MocmFkQW5nbGUpICogcmFkaXVzWCksXG5cdCAgICAgIHk6IG8uY2VudGVyLnkgKyAoTWF0aC5zaW4ocmFkQW5nbGUpICogcmFkaXVzWSlcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldFByZWZpeCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGRvbSwgcHJlLCBzdHlsZXMsIHY7XG5cdCAgICBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIFwiXCIpO1xuXHQgICAgdiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHN0eWxlcykuam9pbihcIlwiKS5tYXRjaCgvLShtb3p8d2Via2l0fG1zKS0vKTtcblx0ICAgIHByZSA9ICh2IHx8IChzdHlsZXMuT0xpbmsgPT09IFwiXCIgJiYgW1wiXCIsIFwib1wiXSkpWzFdO1xuXHQgICAgZG9tID0gXCJXZWJLaXR8TW96fE1TfE9cIi5tYXRjaChuZXcgUmVnRXhwKFwiKFwiICsgcHJlICsgXCIpXCIsIFwiaVwiKSlbMV07XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBkb206IGRvbSxcblx0ICAgICAgbG93ZXJjYXNlOiBwcmUsXG5cdCAgICAgIGNzczogXCItXCIgKyBwcmUgKyBcIi1cIixcblx0ICAgICAganM6IHByZVswXS50b1VwcGVyQ2FzZSgpICsgcHJlLnN1YnN0cigxKVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuc3RyVG9BcnIgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciBhcnI7XG5cdCAgICBhcnIgPSBbXTtcblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3RyaW5nKSkge1xuXHQgICAgICBhcnIucHVzaCh0aGlzLnBhcnNlVW5pdChzdHJpbmcpKTtcblx0ICAgICAgcmV0dXJuIGFycjtcblx0ICAgIH1cblx0ICAgIHN0cmluZy50cmltKCkuc3BsaXQoL1xccysvZ2ltKS5mb3JFYWNoKChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgcmV0dXJuIGFyci5wdXNoKF90aGlzLnBhcnNlVW5pdChfdGhpcy5wYXJzZUlmUmFuZChzdHIpKSk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKSk7XG5cdCAgICByZXR1cm4gYXJyO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jYWxjQXJyRGVsdGEgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdCAgICB2YXIgZGVsdGEsIGksIGosIGxlbjEsIG51bTtcblx0ICAgIGRlbHRhID0gW107XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IGFycjEubGVuZ3RoOyBqIDwgbGVuMTsgaSA9ICsraikge1xuXHQgICAgICBudW0gPSBhcnIxW2ldO1xuXHQgICAgICBkZWx0YVtpXSA9IHRoaXMucGFyc2VVbml0KFwiXCIgKyAoYXJyMltpXS52YWx1ZSAtIGFycjFbaV0udmFsdWUpICsgYXJyMltpXS51bml0KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkZWx0YTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICByZXR1cm4gdmFyaWFibGUgaW5zdGFuY2VvZiBBcnJheTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUubm9ybURhc2hBcnJheXMgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdCAgICB2YXIgYXJyMUxlbiwgYXJyMkxlbiwgY3Vyckl0ZW0sIGksIGosIGssIGxlbkRpZmYsIHJlZiwgcmVmMSwgc3RhcnRJO1xuXHQgICAgYXJyMUxlbiA9IGFycjEubGVuZ3RoO1xuXHQgICAgYXJyMkxlbiA9IGFycjIubGVuZ3RoO1xuXHQgICAgaWYgKGFycjFMZW4gPiBhcnIyTGVuKSB7XG5cdCAgICAgIGxlbkRpZmYgPSBhcnIxTGVuIC0gYXJyMkxlbjtcblx0ICAgICAgc3RhcnRJID0gYXJyMi5sZW5ndGg7XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCByZWYgPSBsZW5EaWZmOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgICBjdXJySXRlbSA9IGkgKyBzdGFydEk7XG5cdCAgICAgICAgYXJyMi5wdXNoKHRoaXMucGFyc2VVbml0KFwiMFwiICsgYXJyMVtjdXJySXRlbV0udW5pdCkpO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGFycjJMZW4gPiBhcnIxTGVuKSB7XG5cdCAgICAgIGxlbkRpZmYgPSBhcnIyTGVuIC0gYXJyMUxlbjtcblx0ICAgICAgc3RhcnRJID0gYXJyMS5sZW5ndGg7XG5cdCAgICAgIGZvciAoaSA9IGsgPSAwLCByZWYxID0gbGVuRGlmZjsgMCA8PSByZWYxID8gayA8IHJlZjEgOiBrID4gcmVmMTsgaSA9IDAgPD0gcmVmMSA/ICsrayA6IC0taykge1xuXHQgICAgICAgIGN1cnJJdGVtID0gaSArIHN0YXJ0STtcblx0ICAgICAgICBhcnIxLnB1c2godGhpcy5wYXJzZVVuaXQoXCIwXCIgKyBhcnIyW2N1cnJJdGVtXS51bml0KSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBbYXJyMSwgYXJyMl07XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLm1ha2VDb2xvck9iaiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdCAgICB2YXIgYWxwaGEsIGIsIGNvbG9yT2JqLCBnLCBpc1JnYiwgciwgcmVnZXhTdHJpbmcxLCByZWdleFN0cmluZzIsIHJlc3VsdCwgcmdiQ29sb3I7XG5cdCAgICBpZiAoY29sb3JbMF0gPT09ICcjJykge1xuXHQgICAgICByZXN1bHQgPSAvXiM/KFthLWZcXGRdezEsMn0pKFthLWZcXGRdezEsMn0pKFthLWZcXGRdezEsMn0pJC9pLmV4ZWMoY29sb3IpO1xuXHQgICAgICBjb2xvck9iaiA9IHt9O1xuXHQgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgciA9IHJlc3VsdFsxXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMV0gOiByZXN1bHRbMV0gKyByZXN1bHRbMV07XG5cdCAgICAgICAgZyA9IHJlc3VsdFsyXS5sZW5ndGggPT09IDIgPyByZXN1bHRbMl0gOiByZXN1bHRbMl0gKyByZXN1bHRbMl07XG5cdCAgICAgICAgYiA9IHJlc3VsdFszXS5sZW5ndGggPT09IDIgPyByZXN1bHRbM10gOiByZXN1bHRbM10gKyByZXN1bHRbM107XG5cdCAgICAgICAgY29sb3JPYmogPSB7XG5cdCAgICAgICAgICByOiBwYXJzZUludChyLCAxNiksXG5cdCAgICAgICAgICBnOiBwYXJzZUludChnLCAxNiksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChiLCAxNiksXG5cdCAgICAgICAgICBhOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGNvbG9yWzBdICE9PSAnIycpIHtcblx0ICAgICAgaXNSZ2IgPSBjb2xvclswXSA9PT0gJ3InICYmIGNvbG9yWzFdID09PSAnZycgJiYgY29sb3JbMl0gPT09ICdiJztcblx0ICAgICAgaWYgKGlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSBjb2xvcjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoIWlzUmdiKSB7XG5cdCAgICAgICAgcmdiQ29sb3IgPSAhdGhpcy5zaG9ydENvbG9yc1tjb2xvcl0gPyAodGhpcy5kaXYuc3R5bGUuY29sb3IgPSBjb2xvciwgdGhpcy5jb21wdXRlZFN0eWxlKHRoaXMuZGl2KS5jb2xvcikgOiB0aGlzLnNob3J0Q29sb3JzW2NvbG9yXTtcblx0ICAgICAgfVxuXHQgICAgICByZWdleFN0cmluZzEgPSAnXnJnYmE/XFxcXCgoXFxcXGR7MSwzfSksXFxcXHM/KFxcXFxkezEsM30pLCc7XG5cdCAgICAgIHJlZ2V4U3RyaW5nMiA9ICdcXFxccz8oXFxcXGR7MSwzfSksP1xcXFxzPyhcXFxcZHsxfXwwP1xcXFwuXFxcXGR7MSx9KT9cXFxcKSQnO1xuXHQgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHJlZ2V4U3RyaW5nMSArIHJlZ2V4U3RyaW5nMiwgJ2dpJykuZXhlYyhyZ2JDb2xvcik7XG5cdCAgICAgIGNvbG9yT2JqID0ge307XG5cdCAgICAgIGFscGhhID0gcGFyc2VGbG9hdChyZXN1bHRbNF0gfHwgMSk7XG5cdCAgICAgIGlmIChyZXN1bHQpIHtcblx0ICAgICAgICBjb2xvck9iaiA9IHtcblx0ICAgICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTApLFxuXHQgICAgICAgICAgZzogcGFyc2VJbnQocmVzdWx0WzJdLCAxMCksXG5cdCAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDEwKSxcblx0ICAgICAgICAgIGE6IChhbHBoYSAhPSBudWxsKSAmJiAhaXNOYU4oYWxwaGEpID8gYWxwaGEgOiAxXG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNvbG9yT2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5jb21wdXRlZFN0eWxlID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKTtcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uKHN0cikge1xuXHQgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHRocm93IEVycm9yKCdTdHJpbmcgZXhwZWN0ZWQgLSBub3RoaW5nIHRvIGNhcGl0YWxpemUnKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZVJhbmQgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciByYW5kLCByYW5kQXJyLCB1bml0cztcblx0ICAgIHJhbmRBcnIgPSBzdHJpbmcuc3BsaXQoL3JhbmRcXCh8XFwsfFxcKS8pO1xuXHQgICAgdW5pdHMgPSB0aGlzLnBhcnNlVW5pdChyYW5kQXJyWzJdKTtcblx0ICAgIHJhbmQgPSB0aGlzLnJhbmQocGFyc2VGbG9hdChyYW5kQXJyWzFdKSwgcGFyc2VGbG9hdChyYW5kQXJyWzJdKSk7XG5cdCAgICBpZiAodW5pdHMudW5pdCAmJiByYW5kQXJyWzJdLm1hdGNoKHVuaXRzLnVuaXQpKSB7XG5cdCAgICAgIHJldHVybiByYW5kICsgdW5pdHMudW5pdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiByYW5kO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZVN0YWdnZXIgPSBmdW5jdGlvbihzdHJpbmcsIGluZGV4KSB7XG5cdCAgICB2YXIgYmFzZSwgbnVtYmVyLCBzcGxpdHRlZFZhbHVlLCB1bml0LCB1bml0VmFsdWUsIHZhbHVlO1xuXHQgICAgdmFsdWUgPSBzdHJpbmcuc3BsaXQoL3N0YWdnZXJcXCh8XFwpJC8pWzFdLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBzcGxpdHRlZFZhbHVlID0gdmFsdWUuc3BsaXQoLyhyYW5kXFwoLio/XFwpfFteXFwoLFxcc10rKSg/PVxccyosfFxccyokKS9naW0pO1xuXHQgICAgdmFsdWUgPSBzcGxpdHRlZFZhbHVlLmxlbmd0aCA+IDMgPyAoYmFzZSA9IHRoaXMucGFyc2VVbml0KHRoaXMucGFyc2VJZlJhbmQoc3BsaXR0ZWRWYWx1ZVsxXSkpLCBzcGxpdHRlZFZhbHVlWzNdKSA6IChiYXNlID0gdGhpcy5wYXJzZVVuaXQoMCksIHNwbGl0dGVkVmFsdWVbMV0pO1xuXHQgICAgdmFsdWUgPSB0aGlzLnBhcnNlSWZSYW5kKHZhbHVlKTtcblx0ICAgIHVuaXRWYWx1ZSA9IHRoaXMucGFyc2VVbml0KHZhbHVlKTtcblx0ICAgIG51bWJlciA9IGluZGV4ICogdW5pdFZhbHVlLnZhbHVlICsgYmFzZS52YWx1ZTtcblx0ICAgIHVuaXQgPSBiYXNlLmlzU3RyaWN0ID8gYmFzZS51bml0IDogdW5pdFZhbHVlLmlzU3RyaWN0ID8gdW5pdFZhbHVlLnVuaXQgOiAnJztcblx0ICAgIGlmICh1bml0KSB7XG5cdCAgICAgIHJldHVybiBcIlwiICsgbnVtYmVyICsgdW5pdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlSWZTdGFnZ2VyID0gZnVuY3Rpb24odmFsdWUsIGkpIHtcblx0ICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubWF0Y2goL3N0YWdnZXIvZykpKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RhZ2dlcih2YWx1ZSwgaSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlSWZSYW5kID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLm1hdGNoKC9yYW5kXFwoLykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYW5kKHN0cik7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gc3RyO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5wYXJzZURlbHRhID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgaW5kZXgpIHtcblx0ICAgIHZhciBjdXJ2ZSwgZGVsdGEsIGVhc2luZywgZW5kLCBlbmRBcnIsIGVuZENvbG9yT2JqLCBpLCBqLCBsZW4xLCBzdGFydCwgc3RhcnRBcnIsIHN0YXJ0Q29sb3JPYmo7XG5cdCAgICB2YWx1ZSA9IHRoaXMuY2xvbmVPYmoodmFsdWUpO1xuXHQgICAgZWFzaW5nID0gdmFsdWUuZWFzaW5nO1xuXHQgICAgaWYgKGVhc2luZyAhPSBudWxsKSB7XG5cdCAgICAgIGVhc2luZyA9IG1vanMuZWFzaW5nLnBhcnNlRWFzaW5nKGVhc2luZyk7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgdmFsdWUuZWFzaW5nO1xuXHQgICAgY3VydmUgPSB2YWx1ZS5jdXJ2ZTtcblx0ICAgIGlmIChjdXJ2ZSAhPSBudWxsKSB7XG5cdCAgICAgIGN1cnZlID0gbW9qcy5lYXNpbmcucGFyc2VFYXNpbmcoY3VydmUpO1xuXHQgICAgfVxuXHQgICAgZGVsZXRlIHZhbHVlLmN1cnZlO1xuXHQgICAgc3RhcnQgPSBPYmplY3Qua2V5cyh2YWx1ZSlbMF07XG5cdCAgICBlbmQgPSB2YWx1ZVtzdGFydF07XG5cdCAgICBkZWx0YSA9IHtcblx0ICAgICAgc3RhcnQ6IHN0YXJ0XG5cdCAgICB9O1xuXHQgICAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc3RhcnQpKSAmJiAhc3RhcnQubWF0Y2goL3JhbmRcXCgvKSAmJiAhc3RhcnQubWF0Y2goL3N0YWdnZXJcXCgvKSkge1xuXHQgICAgICBpZiAoa2V5ID09PSAnc3Ryb2tlTGluZWNhcCcpIHtcblx0ICAgICAgICB0aGlzLndhcm4oXCJTb3JyeSwgc3Ryb2tlLWxpbmVjYXAgcHJvcGVydHkgaXMgbm90IGFuaW1hdGFibGUgeWV0LCB1c2luZyB0aGUgc3RhcnQoXCIgKyBzdGFydCArIFwiKSB2YWx1ZSBpbnN0ZWFkXCIsIHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gZGVsdGE7XG5cdCAgICAgIH1cblx0ICAgICAgc3RhcnRDb2xvck9iaiA9IHRoaXMubWFrZUNvbG9yT2JqKHN0YXJ0KTtcblx0ICAgICAgZW5kQ29sb3JPYmogPSB0aGlzLm1ha2VDb2xvck9iaihlbmQpO1xuXHQgICAgICBkZWx0YSA9IHtcblx0ICAgICAgICB0eXBlOiAnY29sb3InLFxuXHQgICAgICAgIG5hbWU6IGtleSxcblx0ICAgICAgICBzdGFydDogc3RhcnRDb2xvck9iaixcblx0ICAgICAgICBlbmQ6IGVuZENvbG9yT2JqLFxuXHQgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgIGN1cnZlOiBjdXJ2ZSxcblx0ICAgICAgICBkZWx0YToge1xuXHQgICAgICAgICAgcjogZW5kQ29sb3JPYmouciAtIHN0YXJ0Q29sb3JPYmoucixcblx0ICAgICAgICAgIGc6IGVuZENvbG9yT2JqLmcgLSBzdGFydENvbG9yT2JqLmcsXG5cdCAgICAgICAgICBiOiBlbmRDb2xvck9iai5iIC0gc3RhcnRDb2xvck9iai5iLFxuXHQgICAgICAgICAgYTogZW5kQ29sb3JPYmouYSAtIHN0YXJ0Q29sb3JPYmouYVxuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc3Ryb2tlRGFzaGFycmF5JyB8fCBrZXkgPT09ICdzdHJva2VEYXNob2Zmc2V0JyB8fCBrZXkgPT09ICdvcmlnaW4nKSB7XG5cdCAgICAgIHN0YXJ0QXJyID0gdGhpcy5zdHJUb0FycihzdGFydCk7XG5cdCAgICAgIGVuZEFyciA9IHRoaXMuc3RyVG9BcnIoZW5kKTtcblx0ICAgICAgdGhpcy5ub3JtRGFzaEFycmF5cyhzdGFydEFyciwgZW5kQXJyKTtcblx0ICAgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBzdGFydEFyci5sZW5ndGg7IGogPCBsZW4xOyBpID0gKytqKSB7XG5cdCAgICAgICAgc3RhcnQgPSBzdGFydEFycltpXTtcblx0ICAgICAgICBlbmQgPSBlbmRBcnJbaV07XG5cdCAgICAgICAgdGhpcy5tZXJnZVVuaXRzKHN0YXJ0LCBlbmQsIGtleSk7XG5cdCAgICAgIH1cblx0ICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgdHlwZTogJ2FycmF5Jyxcblx0ICAgICAgICBuYW1lOiBrZXksXG5cdCAgICAgICAgc3RhcnQ6IHN0YXJ0QXJyLFxuXHQgICAgICAgIGVuZDogZW5kQXJyLFxuXHQgICAgICAgIGRlbHRhOiB0aGlzLmNhbGNBcnJEZWx0YShzdGFydEFyciwgZW5kQXJyKSxcblx0ICAgICAgICBlYXNpbmc6IGVhc2luZyxcblx0ICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgfTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmICghdGhpcy5jYWxsYmFja3NNYXBba2V5XSAmJiAhdGhpcy50d2Vlbk9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudW5pdE9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgICBlbmQgPSB0aGlzLnBhcnNlVW5pdCh0aGlzLnBhcnNlU3RyaW5nT3B0aW9uKGVuZCwgaW5kZXgpKTtcblx0ICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wYXJzZVVuaXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihzdGFydCwgaW5kZXgpKTtcblx0ICAgICAgICAgIHRoaXMubWVyZ2VVbml0cyhzdGFydCwgZW5kLCBrZXkpO1xuXHQgICAgICAgICAgZGVsdGEgPSB7XG5cdCAgICAgICAgICAgIHR5cGU6ICd1bml0Jyxcblx0ICAgICAgICAgICAgbmFtZToga2V5LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogZW5kLFxuXHQgICAgICAgICAgICBkZWx0YTogZW5kLnZhbHVlIC0gc3RhcnQudmFsdWUsXG5cdCAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGVuZCA9IHBhcnNlRmxvYXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihlbmQsIGluZGV4KSk7XG5cdCAgICAgICAgICBzdGFydCA9IHBhcnNlRmxvYXQodGhpcy5wYXJzZVN0cmluZ09wdGlvbihzdGFydCwgaW5kZXgpKTtcblx0ICAgICAgICAgIGRlbHRhID0ge1xuXHQgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcblx0ICAgICAgICAgICAgbmFtZToga2V5LFxuXHQgICAgICAgICAgICBzdGFydDogc3RhcnQsXG5cdCAgICAgICAgICAgIGVuZDogZW5kLFxuXHQgICAgICAgICAgICBkZWx0YTogZW5kIC0gc3RhcnQsXG5cdCAgICAgICAgICAgIGVhc2luZzogZWFzaW5nLFxuXHQgICAgICAgICAgICBjdXJ2ZTogY3VydmVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZGVsdGE7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLm1lcmdlVW5pdHMgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBrZXkpIHtcblx0ICAgIGlmICghZW5kLmlzU3RyaWN0ICYmIHN0YXJ0LmlzU3RyaWN0KSB7XG5cdCAgICAgIGVuZC51bml0ID0gc3RhcnQudW5pdDtcblx0ICAgICAgcmV0dXJuIGVuZC5zdHJpbmcgPSBcIlwiICsgZW5kLnZhbHVlICsgZW5kLnVuaXQ7XG5cdCAgICB9IGVsc2UgaWYgKGVuZC5pc1N0cmljdCAmJiAhc3RhcnQuaXNTdHJpY3QpIHtcblx0ICAgICAgc3RhcnQudW5pdCA9IGVuZC51bml0O1xuXHQgICAgICByZXR1cm4gc3RhcnQuc3RyaW5nID0gXCJcIiArIHN0YXJ0LnZhbHVlICsgc3RhcnQudW5pdDtcblx0ICAgIH0gZWxzZSBpZiAoZW5kLmlzU3RyaWN0ICYmIHN0YXJ0LmlzU3RyaWN0KSB7XG5cdCAgICAgIGlmIChlbmQudW5pdCAhPT0gc3RhcnQudW5pdCkge1xuXHQgICAgICAgIHN0YXJ0LnVuaXQgPSBlbmQudW5pdDtcblx0ICAgICAgICBzdGFydC5zdHJpbmcgPSBcIlwiICsgc3RhcnQudmFsdWUgKyBzdGFydC51bml0O1xuXHQgICAgICAgIHJldHVybiB0aGlzLndhcm4oXCJUd28gZGlmZmVyZW50IHVuaXRzIHdlcmUgc3BlY2lmaWVkIG9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBkZWx0YSBwcm9wZXJ0eSwgbW8gwrcganMgd2lsbCBmYWxsYmFjayB0byBlbmQgXFxcIlwiICsgZW5kLnVuaXQgKyBcIlxcXCIgdW5pdCBcIik7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucmFuZCA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG5cdCAgICByZXR1cm4gKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmlzRE9NID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGlzTm9kZTtcblx0ICAgIGlmIChvID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaXNOb2RlID0gdHlwZW9mIG8ubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJztcblx0ICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgaXNOb2RlO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRDaGlsZEVsZW1lbnRzID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgICAgdmFyIGNoaWxkTm9kZXMsIGNoaWxkcmVuLCBpO1xuXHQgICAgY2hpbGROb2RlcyA9IGVsZW1lbnQuY2hpbGROb2Rlcztcblx0ICAgIGNoaWxkcmVuID0gW107XG5cdCAgICBpID0gY2hpbGROb2Rlcy5sZW5ndGg7XG5cdCAgICB3aGlsZSAoaS0tKSB7XG5cdCAgICAgIGlmIChjaGlsZE5vZGVzW2ldLm5vZGVUeXBlID09PSAxKSB7XG5cdCAgICAgICAgY2hpbGRyZW4udW5zaGlmdChjaGlsZE5vZGVzW2ldKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoaWxkcmVuO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5kZWx0YSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0ICAgIHZhciBpc1R5cGUxLCBpc1R5cGUyLCBvYmosIHR5cGUxLCB0eXBlMjtcblx0ICAgIHR5cGUxID0gdHlwZW9mIHN0YXJ0O1xuXHQgICAgdHlwZTIgPSB0eXBlb2YgZW5kO1xuXHQgICAgaXNUeXBlMSA9IHR5cGUxID09PSAnc3RyaW5nJyB8fCB0eXBlMSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHN0YXJ0KTtcblx0ICAgIGlzVHlwZTIgPSB0eXBlMiA9PT0gJ3N0cmluZycgfHwgdHlwZTIgPT09ICdudW1iZXInICYmICFpc05hTihlbmQpO1xuXHQgICAgaWYgKCFpc1R5cGUxIHx8ICFpc1R5cGUyKSB7XG5cdCAgICAgIHRoaXMuZXJyb3IoXCJkZWx0YSBtZXRob2QgZXhwZWN0cyBTdHJpbmdzIG9yIE51bWJlcnMgYXQgaW5wdXQgYnV0IGdvdCAtIFwiICsgc3RhcnQgKyBcIiwgXCIgKyBlbmQpO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBvYmogPSB7fTtcblx0ICAgIG9ialtzdGFydF0gPSBlbmQ7XG5cdCAgICByZXR1cm4gb2JqO1xuXHQgIH07XG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXRVbmlxSUQgPSBmdW5jdGlvbigpIHtcblx0ICAgIHJldHVybiArK3RoaXMudW5pcUlEcztcblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuXHQgICAgdmFyIGRvbVBhdGg7XG5cdCAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGlmIChwYXRoLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpID09PSAnbScpIHtcblx0ICAgICAgICBkb21QYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHRoaXMuTlMsICdwYXRoJyk7XG5cdCAgICAgICAgZG9tUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZCcsIHBhdGgpO1xuXHQgICAgICAgIHJldHVybiBkb21QYXRoO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhdGgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAocGF0aC5zdHlsZSkge1xuXHQgICAgICByZXR1cm4gcGF0aDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuY2xvc2VFbm91Z2ggPSBmdW5jdGlvbihudW0xLCBudW0yLCBlcHMpIHtcblx0ICAgIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCBlcHM7XG5cdCAgfTtcblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmNoZWNrSWYzZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGRpdiwgcHJlZml4ZWQsIHN0eWxlLCB0cjtcblx0ICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgdGhpcy5zdHlsZShkaXYsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuXHQgICAgc3R5bGUgPSBkaXYuc3R5bGU7XG5cdCAgICBwcmVmaXhlZCA9IHRoaXMucHJlZml4LmNzcyArIFwidHJhbnNmb3JtXCI7XG5cdCAgICB0ciA9IHN0eWxlW3ByZWZpeGVkXSAhPSBudWxsID8gc3R5bGVbcHJlZml4ZWRdIDogc3R5bGUudHJhbnNmb3JtO1xuXHQgICAgcmV0dXJuIHRyICE9PSAnJztcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHZhcmlhYmxlIGhvbGRzIHBvaW50ZXIgdG8gYW4gb2JqZWN0LlxuXHQgICAgQHBhcmFtIHtBbnl9IFZhcmlhYmxlIHRvIHRlc3Rcblx0ICAgIEByZXR1cm5zIHtCb29sZWFufSBJZiB2YXJpYWJsZSBpcyBvYmplY3QuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdCAgICByZXR1cm4gdmFyaWFibGUgIT09IG51bGwgJiYgdHlwZW9mIHZhcmlhYmxlID09PSAnb2JqZWN0Jztcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBmaXJzdCB2YWx1ZSBvZiB0aGUgb2JqZWN0LlxuXHQgICAgVXNlZCB0byBnZXQgZW5kIHZhbHVlIG9uIOKIhnMuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gT2JqZWN0IHRvIGdldCB0aGUgdmFsdWUgb2YuXG5cdCAgICBAcmV0dXJucyB7QW55fSBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IG9iamVjdCcgcHJvcGVydHkuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5nZXREZWx0YUVuZCA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgdmFyIGtleTtcblx0ICAgIGtleSA9IE9iamVjdC5rZXlzKG9iailbMF07XG5cdCAgICByZXR1cm4gb2JqW2tleV07XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZmlyc3Qga2V5IG9mIHRoZSBvYmplY3QuXG5cdCAgICBVc2VkIHRvIGdldCBzdGFydCB2YWx1ZSBvbiDiiIZzLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IE9iamVjdCB0byBnZXQgdGhlIHZhbHVlIG9mLlxuXHQgICAgQHJldHVybnMge1N0cmluZ30gVGhlIGtleSBvZiB0aGUgZmlyc3Qgb2JqZWN0JyBwcm9wZXJ0eS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldERlbHRhU3RhcnQgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgIHZhciBrZXk7XG5cdCAgICBrZXkgPSBPYmplY3Qua2V5cyhvYmopWzBdO1xuXHQgICAgcmV0dXJuIGtleTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNoZWNrIGlmIHByb3BlcnkgZXhpc3RzIGluIGNhbGxiYWNrc01hcCBvciB0d2Vlbk9wdGlvbk1hcC5cblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBQcm9wZXJ0eSBuYW1lIHRvIGNoZWNrIGZvclxuXHQgICAgQHJldHVybnMge0Jvb2xlYW59IElmIHByb3BlcnR5IGlzIHR3ZWVuIHByb3BlcnR5LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUuaXNUd2VlblByb3AgPSBmdW5jdGlvbihrZXlOYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpcy50d2Vlbk9wdGlvbk1hcFtrZXlOYW1lXSB8fCB0aGlzLmNhbGxiYWNrc01hcFtrZXlOYW1lXTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHBhcnNlIHN0cmluZyBwcm9wZXJ0eSB2YWx1ZVxuXHQgICAgd2hpY2ggY2FuIGluY2x1ZGUgYm90aCBgcmFuZGAgYW5kIGBzdGFnZ2VyIGBcblx0ICAgIHZhbHVlIGluIHZhcmlvdXMgcG9zaXRpb25zLlxuXHQgICAgQHBhcmFtIHtTdHJpbmd9IFByb3BlcnR5IG5hbWUgdG8gY2hlY2sgZm9yLlxuXHQgICAgQHBhcmFtIHtOdW1iZXJ9IE9wdGlvbmFsIGluZGV4IGZvciBzdGFnZ2VyLlxuXHQgICAgQHJldHVybnMge051bWJlcn0gUGFyc2VkIG9wdGlvbiB2YWx1ZS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLnBhcnNlU3RyaW5nT3B0aW9uID0gZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdCAgICBpZiAoaW5kZXggPT0gbnVsbCkge1xuXHQgICAgICBpbmRleCA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VJZlN0YWdnZXIodmFsdWUsIGluZGV4KTtcblx0ICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlSWZSYW5kKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCB0aGUgbGFzdCBpdGVtIG9mIGFycmF5LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IHRvIGdldCB0aGUgbGFzdCBpdGVtIGluLlxuXHQgICAgQHJldHVybnMge0FueX0gVGhlIGxhc3QgaXRlbSBvZiBhcnJheS5cblx0ICAgKi9cblxuXHQgIEhlbHBlcnMucHJvdG90eXBlLmdldExhc3RJdGVtID0gZnVuY3Rpb24oYXJyKSB7XG5cdCAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHBhcnNlIEhUTUxFbGVtZW50LlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7U3RyaW5nLCBPYmplY3R9IFNlbGVjdG9yIHN0cmluZyBvciBIVE1MRWxlbWVudC5cblx0ICAgIEByZXR1cm5zIHtPYmplY3R9IEhUTUxFbGVtZW50LlxuXHQgICAqL1xuXG5cdCAgSGVscGVycy5wcm90b3R5cGUucGFyc2VFbCA9IGZ1bmN0aW9uKGVsKSB7XG5cdCAgICBpZiAoaC5pc0RPTShlbCkpIHtcblx0ICAgICAgcmV0dXJuIGVsO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG5cdCAgICB9XG5cdCAgICBpZiAoZWwgPT09IG51bGwpIHtcblx0ICAgICAgaC5lcnJvcihcIkNhbid0IHBhcnNlIEhUTUwgZWxlbWVudDogXCIsIGVsKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBlbDtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIGZvcmNlIGNvbXBvc2l0b3IgbGF5ZXIgb24gSFRNTEVsZW1lbnQuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHBhcmFtIHtPYmplY3R9IEhUTUxFbGVtZW50LlxuXHQgICAgQHJldHVybnMge09iamVjdH0gSFRNTEVsZW1lbnQuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5mb3JjZTNkID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIHRoaXMuc2V0UHJlZml4ZWRTdHlsZShlbCwgJ2JhY2tmYWNlLXZpc2liaWxpdHknLCAnaGlkZGVuJyk7XG5cdCAgICByZXR1cm4gZWw7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjaGVjayBpZiB2YWx1ZSBpcyBkZWx0YS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0FueX0gUHJvcGVydHkgdG8gY2hlY2suXG5cdCAgICBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdmFsdWUgaXMgZGVsdGEuXG5cdCAgICovXG5cblx0ICBIZWxwZXJzLnByb3RvdHlwZS5pc0RlbHRhID0gZnVuY3Rpb24ob3B0aW9uc1ZhbHVlKSB7XG5cdCAgICB2YXIgaXNPYmplY3Q7XG5cdCAgICBpc09iamVjdCA9IHRoaXMuaXNPYmplY3Qob3B0aW9uc1ZhbHVlKTtcblx0ICAgIGlzT2JqZWN0ID0gaXNPYmplY3QgJiYgIW9wdGlvbnNWYWx1ZS51bml0O1xuXHQgICAgcmV0dXJuICEoIWlzT2JqZWN0IHx8IHRoaXMuaXNBcnJheShvcHRpb25zVmFsdWUpIHx8IHRoaXMuaXNET00ob3B0aW9uc1ZhbHVlKSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBIZWxwZXJzO1xuXG5cdH0pKCk7XG5cblx0aCA9IG5ldyBIZWxwZXJzO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gaDtcblxuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBCaXQsIEJpdHNNYXAsIENpcmNsZSwgQ3Jvc3MsIEN1cnZlLCBDdXN0b20sIEVxdWFsLCBMaW5lLCBQb2x5Z29uLCBSZWN0LCBaaWd6YWcsIGg7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNilbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5cdEN1c3RvbSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuXHRDaXJjbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuXHRMaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cblx0WmlnemFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cblx0UmVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG5cdFBvbHlnb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuXHRDcm9zcyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG5cdEN1cnZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MilbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuXG5cdEVxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdEJpdHNNYXAgPSAoZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gQml0c01hcCgpIHtcblx0ICAgIHRoaXMuYWRkU2hhcGUgPSBoLmJpbmQodGhpcy5hZGRTaGFwZSwgdGhpcyk7XG5cdCAgfVxuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuYml0ID0gQml0O1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY3VzdG9tID0gQ3VzdG9tO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY2lyY2xlID0gQ2lyY2xlO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUubGluZSA9IExpbmU7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS56aWd6YWcgPSBaaWd6YWc7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5yZWN0ID0gUmVjdDtcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLnBvbHlnb24gPSBQb2x5Z29uO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuY3Jvc3MgPSBDcm9zcztcblxuXHQgIEJpdHNNYXAucHJvdG90eXBlLmVxdWFsID0gRXF1YWw7XG5cblx0ICBCaXRzTWFwLnByb3RvdHlwZS5jdXJ2ZSA9IEN1cnZlO1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuZ2V0U2hhcGUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICByZXR1cm4gdGhpc1tuYW1lXSB8fCBoLmVycm9yKFwibm8gXFxcIlwiICsgbmFtZSArIFwiXFxcIiBzaGFwZSBhdmFpbGFibGUgeWV0LCBwbGVhc2UgY2hvb3NlIGZyb20gdGhpcyBsaXN0OlwiLCBbJ2NpcmNsZScsICdsaW5lJywgJ3ppZ3phZycsICdyZWN0JywgJ3BvbHlnb24nLCAnY3Jvc3MnLCAnZXF1YWwnLCAnY3VydmUnXSk7XG5cdCAgfTtcblxuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBhZGQgc2hhcGUgdG8gdGhlIG1hcC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEBwYXJhbSB7U3RyaW5nfSBOYW1lIG9mIHRoZSBzaGFwZSBtb2R1bGUuXG5cdCAgICBAcGFyYW0ge09iamVjdH0gU2hhcGUgbW9kdWxlIGNsYXNzLlxuXHQgICAqL1xuXG5cdCAgQml0c01hcC5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbihuYW1lLCBNb2R1bGUpIHtcblx0ICAgIHJldHVybiB0aGlzW25hbWVdID0gTW9kdWxlO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQml0c01hcDtcblxuXHR9KSgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gbmV3IEJpdHNNYXA7XG5cblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgTW90aW9uUGF0aCwgVGltZWxpbmUsIFR3ZWVuLCBoLCByZXNpemUsXG5cdCAgYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH07XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHJlc2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG5cdFR3ZWVuID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KVtcImRlZmF1bHRcIl07XG5cblx0VGltZWxpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpW1wiZGVmYXVsdFwiXTtcblxuXHRNb3Rpb25QYXRoID0gKGZ1bmN0aW9uKCkge1xuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuXHQgICAgcGF0aDogbnVsbCxcblx0ICAgIGN1cnZhdHVyZToge1xuXHQgICAgICB4OiAnNzUlJyxcblx0ICAgICAgeTogJzUwJSdcblx0ICAgIH0sXG5cdCAgICBpc0NvbXBvc2l0ZUxheWVyOiB0cnVlLFxuXHQgICAgZGVsYXk6IDAsXG5cdCAgICBkdXJhdGlvbjogMTAwMCxcblx0ICAgIGVhc2luZzogbnVsbCxcblx0ICAgIHJlcGVhdDogMCxcblx0ICAgIHlveW86IGZhbHNlLFxuXHQgICAgb25TdGFydDogbnVsbCxcblx0ICAgIG9uQ29tcGxldGU6IG51bGwsXG5cdCAgICBvblVwZGF0ZTogbnVsbCxcblx0ICAgIG9mZnNldFg6IDAsXG5cdCAgICBvZmZzZXRZOiAwLFxuXHQgICAgYW5nbGVPZmZzZXQ6IG51bGwsXG5cdCAgICBwYXRoU3RhcnQ6IDAsXG5cdCAgICBwYXRoRW5kOiAxLFxuXHQgICAgbW90aW9uQmx1cjogMCxcblx0ICAgIHRyYW5zZm9ybU9yaWdpbjogbnVsbCxcblx0ICAgIGlzQW5nbGU6IGZhbHNlLFxuXHQgICAgaXNSZXZlcnNlOiBmYWxzZSxcblx0ICAgIGlzUnVuTGVzczogZmFsc2UsXG5cdCAgICBpc1ByZXNldFBvc2l0aW9uOiB0cnVlXG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIE1vdGlvblBhdGgobzEpIHtcblx0ICAgIHRoaXMubyA9IG8xICE9IG51bGwgPyBvMSA6IHt9O1xuXHQgICAgdGhpcy5jYWxjSGVpZ2h0ID0gYmluZCh0aGlzLmNhbGNIZWlnaHQsIHRoaXMpO1xuXHQgICAgaWYgKHRoaXMudmFycygpKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuY3JlYXRlVHdlZW4oKTtcblx0ICAgIHRoaXM7XG5cdCAgfVxuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUudmFycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5nZXRTY2FsZXIgPSBoLmJpbmQodGhpcy5nZXRTY2FsZXIsIHRoaXMpO1xuXHQgICAgdGhpcy5yZXNpemUgPSByZXNpemU7XG5cdCAgICB0aGlzLnByb3BzID0gaC5jbG9uZU9iaih0aGlzLmRlZmF1bHRzKTtcblx0ICAgIHRoaXMuZXh0ZW5kT3B0aW9ucyh0aGlzLm8pO1xuXHQgICAgdGhpcy5pc01vdGlvbkJsdXJSZXNldCA9IGguaXNTYWZhcmkgfHwgaC5pc0lFO1xuXHQgICAgdGhpcy5pc01vdGlvbkJsdXJSZXNldCAmJiAodGhpcy5wcm9wcy5tb3Rpb25CbHVyID0gMCk7XG5cdCAgICB0aGlzLmhpc3RvcnkgPSBbaC5jbG9uZU9iaih0aGlzLnByb3BzKV07XG5cdCAgICByZXR1cm4gdGhpcy5wb3N0VmFycygpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvUGF0aCA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBhbmdsZSwgY3VydmF0dXJlLCBjdXJ2YXR1cmVYLCBjdXJ2YXR1cmVZLCBjdXJ2ZVBvaW50LCBjdXJ2ZVhQb2ludCwgZFgsIGRZLCBlbmRQb2ludCwgcGF0aCwgcGVyY2VudCwgcmFkaXVzLCBzdGFydDtcblx0ICAgIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoaC5OUywgJ3BhdGgnKTtcblx0ICAgIHN0YXJ0ID0gby5zdGFydDtcblx0ICAgIGVuZFBvaW50ID0ge1xuXHQgICAgICB4OiBzdGFydC54ICsgby5zaGlmdC54LFxuXHQgICAgICB5OiBzdGFydC54ICsgby5zaGlmdC55XG5cdCAgICB9O1xuXHQgICAgY3VydmF0dXJlID0gby5jdXJ2YXR1cmU7XG5cdCAgICBkWCA9IG8uc2hpZnQueDtcblx0ICAgIGRZID0gby5zaGlmdC55O1xuXHQgICAgcmFkaXVzID0gTWF0aC5zcXJ0KGRYICogZFggKyBkWSAqIGRZKTtcblx0ICAgIHBlcmNlbnQgPSByYWRpdXMgLyAxMDA7XG5cdCAgICBhbmdsZSA9IE1hdGguYXRhbihkWSAvIGRYKSAqICgxODAgLyBNYXRoLlBJKSArIDkwO1xuXHQgICAgaWYgKG8uc2hpZnQueCA8IDApIHtcblx0ICAgICAgYW5nbGUgPSBhbmdsZSArIDE4MDtcblx0ICAgIH1cblx0ICAgIGN1cnZhdHVyZVggPSBoLnBhcnNlVW5pdChjdXJ2YXR1cmUueCk7XG5cdCAgICBjdXJ2YXR1cmVYID0gY3VydmF0dXJlWC51bml0ID09PSAnJScgPyBjdXJ2YXR1cmVYLnZhbHVlICogcGVyY2VudCA6IGN1cnZhdHVyZVgudmFsdWU7XG5cdCAgICBjdXJ2ZVhQb2ludCA9IGguZ2V0UmFkaWFsUG9pbnQoe1xuXHQgICAgICBjZW50ZXI6IHtcblx0ICAgICAgICB4OiBzdGFydC54LFxuXHQgICAgICAgIHk6IHN0YXJ0Lnlcblx0ICAgICAgfSxcblx0ICAgICAgcmFkaXVzOiBjdXJ2YXR1cmVYLFxuXHQgICAgICBhbmdsZTogYW5nbGVcblx0ICAgIH0pO1xuXHQgICAgY3VydmF0dXJlWSA9IGgucGFyc2VVbml0KGN1cnZhdHVyZS55KTtcblx0ICAgIGN1cnZhdHVyZVkgPSBjdXJ2YXR1cmVZLnVuaXQgPT09ICclJyA/IGN1cnZhdHVyZVkudmFsdWUgKiBwZXJjZW50IDogY3VydmF0dXJlWS52YWx1ZTtcblx0ICAgIGN1cnZlUG9pbnQgPSBoLmdldFJhZGlhbFBvaW50KHtcblx0ICAgICAgY2VudGVyOiB7XG5cdCAgICAgICAgeDogY3VydmVYUG9pbnQueCxcblx0ICAgICAgICB5OiBjdXJ2ZVhQb2ludC55XG5cdCAgICAgIH0sXG5cdCAgICAgIHJhZGl1czogY3VydmF0dXJlWSxcblx0ICAgICAgYW5nbGU6IGFuZ2xlICsgOTBcblx0ICAgIH0pO1xuXHQgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBcIk1cIiArIHN0YXJ0LnggKyBcIixcIiArIHN0YXJ0LnkgKyBcIiBRXCIgKyBjdXJ2ZVBvaW50LnggKyBcIixcIiArIGN1cnZlUG9pbnQueSArIFwiIFwiICsgZW5kUG9pbnQueCArIFwiLFwiICsgZW5kUG9pbnQueSk7XG5cdCAgICByZXR1cm4gcGF0aDtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUucG9zdFZhcnMgPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMucHJvcHMucGF0aFN0YXJ0ID0gaC5jbGFtcCh0aGlzLnByb3BzLnBhdGhTdGFydCwgMCwgMSk7XG5cdCAgICB0aGlzLnByb3BzLnBhdGhFbmQgPSBoLmNsYW1wKHRoaXMucHJvcHMucGF0aEVuZCwgdGhpcy5wcm9wcy5wYXRoU3RhcnQsIDEpO1xuXHQgICAgdGhpcy5hbmdsZSA9IDA7XG5cdCAgICB0aGlzLnNwZWVkWCA9IDA7XG5cdCAgICB0aGlzLnNwZWVkWSA9IDA7XG5cdCAgICB0aGlzLmJsdXJYID0gMDtcblx0ICAgIHRoaXMuYmx1clkgPSAwO1xuXHQgICAgdGhpcy5wcmV2Q29vcmRzID0ge307XG5cdCAgICB0aGlzLmJsdXJBbW91bnQgPSAyMDtcblx0ICAgIHRoaXMucHJvcHMubW90aW9uQmx1ciA9IGguY2xhbXAodGhpcy5wcm9wcy5tb3Rpb25CbHVyLCAwLCAxKTtcblx0ICAgIHRoaXMub25VcGRhdGUgPSB0aGlzLnByb3BzLm9uVXBkYXRlO1xuXHQgICAgaWYgKCF0aGlzLm8uZWwpIHtcblx0ICAgICAgaC5lcnJvcignTWlzc2VkIFwiZWxcIiBvcHRpb24uIEl0IGNvdWxkIGJlIGEgc2VsZWN0b3IsIERPTU5vZGUgb3IgYW5vdGhlciBtb2R1bGUuJyk7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdGhpcy5lbCA9IHRoaXMucGFyc2VFbCh0aGlzLnByb3BzLmVsKTtcblx0ICAgIHRoaXMucHJvcHMubW90aW9uQmx1ciA+IDAgJiYgdGhpcy5jcmVhdGVGaWx0ZXIoKTtcblx0ICAgIHRoaXMucGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xuXHQgICAgaWYgKCF0aGlzLnBhdGguZ2V0QXR0cmlidXRlKCdkJykpIHtcblx0ICAgICAgaC5lcnJvcignUGF0aCBoYXMgbm8gY29vcmRpbmF0ZXMgdG8gd29yayB3aXRoLCBhYm9ydGluZycpO1xuXHQgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHRoaXMubGVuID0gdGhpcy5wYXRoLmdldFRvdGFsTGVuZ3RoKCk7XG5cdCAgICB0aGlzLnNsaWNlZExlbiA9IHRoaXMubGVuICogKHRoaXMucHJvcHMucGF0aEVuZCAtIHRoaXMucHJvcHMucGF0aFN0YXJ0KTtcblx0ICAgIHRoaXMuc3RhcnRMZW4gPSB0aGlzLnByb3BzLnBhdGhTdGFydCAqIHRoaXMubGVuO1xuXHQgICAgdGhpcy5maWxsID0gdGhpcy5wcm9wcy5maWxsO1xuXHQgICAgaWYgKHRoaXMuZmlsbCAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5wYXJzZUVsKHRoaXMucHJvcHMuZmlsbC5jb250YWluZXIpO1xuXHQgICAgICB0aGlzLmZpbGxSdWxlID0gdGhpcy5wcm9wcy5maWxsLmZpbGxSdWxlIHx8ICdhbGwnO1xuXHQgICAgICB0aGlzLmdldFNjYWxlcigpO1xuXHQgICAgICBpZiAodGhpcy5jb250YWluZXIgIT0gbnVsbCkge1xuXHQgICAgICAgIHRoaXMucmVtb3ZlRXZlbnQodGhpcy5jb250YWluZXIsICdvbnJlc2l6ZScsIHRoaXMuZ2V0U2NhbGVyKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5hZGRFdmVudCh0aGlzLmNvbnRhaW5lciwgJ29ucmVzaXplJywgdGhpcy5nZXRTY2FsZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmFkZEV2ZW50ID0gZnVuY3Rpb24oZWwsIHR5cGUsIGhhbmRsZXIpIHtcblx0ICAgIHJldHVybiBlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbihlbCwgdHlwZSwgaGFuZGxlcikge1xuXHQgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5jcmVhdGVGaWx0ZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBkaXYsIHN2Zztcblx0ICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHQgICAgdGhpcy5maWx0ZXJJRCA9IFwiZmlsdGVyLVwiICsgKGguZ2V0VW5pcUlEKCkpO1xuXHQgICAgZGl2LmlubmVySFRNTCA9IFwiPHN2ZyBpZD1cXFwic3ZnLVwiICsgdGhpcy5maWx0ZXJJRCArIFwiXFxcIlxcbiAgICBzdHlsZT1cXFwidmlzaWJpbGl0eTpoaWRkZW47IHdpZHRoOjBweDsgaGVpZ2h0OjBweFxcXCI+XFxuICA8ZmlsdGVyIGlkPVxcXCJcIiArIHRoaXMuZmlsdGVySUQgKyBcIlxcXCIgeT1cXFwiLTIwXFxcIiB4PVxcXCItMjBcXFwiIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCI+XFxuICAgIDxmZU9mZnNldFxcbiAgICAgIGlkPVxcXCJibHVyLW9mZnNldFxcXCIgaW49XFxcIlNvdXJjZUdyYXBoaWNcXFwiXFxuICAgICAgZHg9XFxcIjBcXFwiIGR5PVxcXCIwXFxcIiByZXN1bHQ9XFxcIm9mZnNldDJcXFwiPjwvZmVPZmZzZXQ+XFxuICAgIDxmZUdhdXNzaWFuYmx1clxcbiAgICAgIGlkPVxcXCJibHVyXFxcIiBpbj1cXFwib2Zmc2V0MlxcXCJcXG4gICAgICBzdGREZXZpYXRpb249XFxcIjAsMFxcXCIgcmVzdWx0PVxcXCJibHVyMlxcXCI+PC9mZUdhdXNzaWFuYmx1cj5cXG4gICAgPGZlTWVyZ2U+XFxuICAgICAgPGZlTWVyZ2VOb2RlIGluPVxcXCJTb3VyY2VHcmFwaGljXFxcIj48L2ZlTWVyZ2VOb2RlPlxcbiAgICAgIDxmZU1lcmdlTm9kZSBpbj1cXFwiYmx1cjJcXFwiPjwvZmVNZXJnZU5vZGU+XFxuICAgIDwvZmVNZXJnZT5cXG4gIDwvZmlsdGVyPlxcbjwvc3ZnPlwiO1xuXHQgICAgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoXCIjc3ZnLVwiICsgdGhpcy5maWx0ZXJJRCk7XG5cdCAgICB0aGlzLmZpbHRlciA9IHN2Zy5xdWVyeVNlbGVjdG9yKCcjYmx1cicpO1xuXHQgICAgdGhpcy5maWx0ZXJPZmZzZXQgPSBzdmcucXVlcnlTZWxlY3RvcignI2JsdXItb2Zmc2V0Jyk7XG5cdCAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZShzdmcsIGRvY3VtZW50LmJvZHkuZmlyc3RDaGlsZCk7XG5cdCAgICB0aGlzLmVsLnN0eWxlWydmaWx0ZXInXSA9IFwidXJsKCNcIiArIHRoaXMuZmlsdGVySUQgKyBcIilcIjtcblx0ICAgIHJldHVybiB0aGlzLmVsLnN0eWxlW2gucHJlZml4LmNzcyArIFwiZmlsdGVyXCJdID0gXCJ1cmwoI1wiICsgdGhpcy5maWx0ZXJJRCArIFwiKVwiO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5wYXJzZUVsID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcblx0ICAgIH1cblx0ICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdCAgICAgIHJldHVybiBlbDtcblx0ICAgIH1cblx0ICAgIGlmIChlbC5fc2V0UHJvcCAhPSBudWxsKSB7XG5cdCAgICAgIHRoaXMuaXNNb2R1bGUgPSB0cnVlO1xuXHQgICAgICByZXR1cm4gZWw7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBwYXRoO1xuXHQgICAgcGF0aCA9IGgucGFyc2VQYXRoKHRoaXMucHJvcHMucGF0aCk7XG5cdCAgICBpZiAocGF0aCkge1xuXHQgICAgICByZXR1cm4gcGF0aDtcblx0ICAgIH1cblx0ICAgIGlmICh0aGlzLnByb3BzLnBhdGgueCB8fCB0aGlzLnByb3BzLnBhdGgueSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5jdXJ2ZVRvUGF0aCh7XG5cdCAgICAgICAgc3RhcnQ6IHtcblx0ICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICB5OiAwXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzaGlmdDoge1xuXHQgICAgICAgICAgeDogdGhpcy5wcm9wcy5wYXRoLnggfHwgMCxcblx0ICAgICAgICAgIHk6IHRoaXMucHJvcHMucGF0aC55IHx8IDBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGN1cnZhdHVyZToge1xuXHQgICAgICAgICAgeDogdGhpcy5wcm9wcy5jdXJ2YXR1cmUueCB8fCB0aGlzLmRlZmF1bHRzLmN1cnZhdHVyZS54LFxuXHQgICAgICAgICAgeTogdGhpcy5wcm9wcy5jdXJ2YXR1cmUueSB8fCB0aGlzLmRlZmF1bHRzLmN1cnZhdHVyZS55XG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuZ2V0U2NhbGVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZW5kLCBzaXplLCBzdGFydDtcblx0ICAgIHRoaXMuY1NpemUgPSB7XG5cdCAgICAgIHdpZHRoOiB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aCB8fCAwLFxuXHQgICAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodCB8fCAwXG5cdCAgICB9O1xuXHQgICAgc3RhcnQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aCgwKTtcblx0ICAgIGVuZCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKHRoaXMubGVuKTtcblx0ICAgIHNpemUgPSB7fTtcblx0ICAgIHRoaXMuc2NhbGVyID0ge307XG5cdCAgICBzaXplLndpZHRoID0gZW5kLnggPj0gc3RhcnQueCA/IGVuZC54IC0gc3RhcnQueCA6IHN0YXJ0LnggLSBlbmQueDtcblx0ICAgIHNpemUuaGVpZ2h0ID0gZW5kLnkgPj0gc3RhcnQueSA/IGVuZC55IC0gc3RhcnQueSA6IHN0YXJ0LnkgLSBlbmQueTtcblx0ICAgIHN3aXRjaCAodGhpcy5maWxsUnVsZSkge1xuXHQgICAgICBjYXNlICdhbGwnOlxuXHQgICAgICAgIHRoaXMuY2FsY1dpZHRoKHNpemUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNhbGNIZWlnaHQoc2l6ZSk7XG5cdCAgICAgIGNhc2UgJ3dpZHRoJzpcblx0ICAgICAgICB0aGlzLmNhbGNXaWR0aChzaXplKTtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIueSA9IHRoaXMuc2NhbGVyLng7XG5cdCAgICAgIGNhc2UgJ2hlaWdodCc6XG5cdCAgICAgICAgdGhpcy5jYWxjSGVpZ2h0KHNpemUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNjYWxlci54ID0gdGhpcy5zY2FsZXIueTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuY2FsY1dpZHRoID0gZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgdGhpcy5zY2FsZXIueCA9IHRoaXMuY1NpemUud2lkdGggLyBzaXplLndpZHRoO1xuXHQgICAgcmV0dXJuICFpc0Zpbml0ZSh0aGlzLnNjYWxlci54KSAmJiAodGhpcy5zY2FsZXIueCA9IDEpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5jYWxjSGVpZ2h0ID0gZnVuY3Rpb24oc2l6ZSkge1xuXHQgICAgdGhpcy5zY2FsZXIueSA9IHRoaXMuY1NpemUuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQ7XG5cdCAgICByZXR1cm4gIWlzRmluaXRlKHRoaXMuc2NhbGVyLnkpICYmICh0aGlzLnNjYWxlci55ID0gMSk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBmaXN0SXRlbSwga2V5LCB2YWx1ZTtcblx0ICAgIGlmIChvKSB7XG5cdCAgICAgIGZpc3RJdGVtID0gdGhpcy5oaXN0b3J5WzBdO1xuXHQgICAgICBmb3IgKGtleSBpbiBvKSB7XG5cdCAgICAgICAgdmFsdWUgPSBvW2tleV07XG5cdCAgICAgICAgaWYgKGguY2FsbGJhY2tzTWFwW2tleV0gfHwgaC50d2Vlbk9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgICBoLndhcm4oXCJ0aGUgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHByb3BlcnR5IGNhbiBub3QgYmUgb3ZlcnJpZGRlbiBvbiBydW4geWV0XCIpO1xuXHQgICAgICAgICAgZGVsZXRlIG9ba2V5XTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5oaXN0b3J5WzBdW2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy50dW5lT3B0aW9ucyhvKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzLnN0YXJ0VHdlZW4oKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuY3JlYXRlVHdlZW4gPSBmdW5jdGlvbigpIHtcblx0ICAgIHRoaXMudHdlZW4gPSBuZXcgVHdlZW4oe1xuXHQgICAgICBkdXJhdGlvbjogdGhpcy5wcm9wcy5kdXJhdGlvbixcblx0ICAgICAgZGVsYXk6IHRoaXMucHJvcHMuZGVsYXksXG5cdCAgICAgIHlveW86IHRoaXMucHJvcHMueW95byxcblx0ICAgICAgcmVwZWF0OiB0aGlzLnByb3BzLnJlcGVhdCxcblx0ICAgICAgZWFzaW5nOiB0aGlzLnByb3BzLmVhc2luZyxcblx0ICAgICAgb25TdGFydDogKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICAgIHJldHVybiAocmVmID0gX3RoaXMucHJvcHMub25TdGFydCkgIT0gbnVsbCA/IHJlZi5hcHBseShfdGhpcykgOiB2b2lkIDA7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcyksXG5cdCAgICAgIG9uQ29tcGxldGU6IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgICBfdGhpcy5wcm9wcy5tb3Rpb25CbHVyICYmIF90aGlzLnNldEJsdXIoe1xuXHQgICAgICAgICAgICBibHVyOiB7XG5cdCAgICAgICAgICAgICAgeDogMCxcblx0ICAgICAgICAgICAgICB5OiAwXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIG9mZnNldDoge1xuXHQgICAgICAgICAgICAgIHg6IDAsXG5cdCAgICAgICAgICAgICAgeTogMFxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICAgIHJldHVybiAocmVmID0gX3RoaXMucHJvcHMub25Db21wbGV0ZSkgIT0gbnVsbCA/IHJlZi5hcHBseShfdGhpcykgOiB2b2lkIDA7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcyksXG5cdCAgICAgIG9uVXBkYXRlOiAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24ocCkge1xuXHQgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFByb2dyZXNzKHApO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpLFxuXHQgICAgICBvbkZpcnN0VXBkYXRlOiAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oaXNGb3J3YXJkLCBpc1lveW8pIHtcblx0ICAgICAgICAgIGlmICghaXNGb3J3YXJkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDEgJiYgX3RoaXMudHVuZU9wdGlvbnMoX3RoaXMuaGlzdG9yeVswXSk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgfSkodGhpcylcblx0ICAgIH0pO1xuXHQgICAgdGhpcy50aW1lbGluZSA9IG5ldyBUaW1lbGluZTtcblx0ICAgIHRoaXMudGltZWxpbmUuYWRkKHRoaXMudHdlZW4pO1xuXHQgICAgIXRoaXMucHJvcHMuaXNSdW5MZXNzICYmIHRoaXMuc3RhcnRUd2VlbigpO1xuXHQgICAgcmV0dXJuIHRoaXMucHJvcHMuaXNQcmVzZXRQb3NpdGlvbiAmJiB0aGlzLnNldFByb2dyZXNzKDAsIHRydWUpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5zdGFydFR3ZWVuID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gc2V0VGltZW91dCgoKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgcmVmO1xuXHQgICAgICAgIHJldHVybiAocmVmID0gX3RoaXMudGltZWxpbmUpICE9IG51bGwgPyByZWYucGxheSgpIDogdm9pZCAwO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcykpLCAxKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuc2V0UHJvZ3Jlc3MgPSBmdW5jdGlvbihwLCBpc0luaXQpIHtcblx0ICAgIHZhciBsZW4sIHBvaW50LCB4LCB5O1xuXHQgICAgbGVuID0gdGhpcy5zdGFydExlbiArICghdGhpcy5wcm9wcy5pc1JldmVyc2UgPyBwICogdGhpcy5zbGljZWRMZW4gOiAoMSAtIHApICogdGhpcy5zbGljZWRMZW4pO1xuXHQgICAgcG9pbnQgPSB0aGlzLnBhdGguZ2V0UG9pbnRBdExlbmd0aChsZW4pO1xuXHQgICAgeCA9IHBvaW50LnggKyB0aGlzLnByb3BzLm9mZnNldFg7XG5cdCAgICB5ID0gcG9pbnQueSArIHRoaXMucHJvcHMub2Zmc2V0WTtcblx0ICAgIHRoaXMuX2dldEN1cnJlbnRBbmdsZShwb2ludCwgbGVuLCBwKTtcblx0ICAgIHRoaXMuX3NldFRyYW5zZm9ybU9yaWdpbihwKTtcblx0ICAgIHRoaXMuX3NldFRyYW5zZm9ybSh4LCB5LCBwLCBpc0luaXQpO1xuXHQgICAgcmV0dXJuIHRoaXMucHJvcHMubW90aW9uQmx1ciAmJiB0aGlzLm1ha2VNb3Rpb25CbHVyKHgsIHkpO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS5zZXRFbFBvc2l0aW9uID0gZnVuY3Rpb24oeCwgeSwgcCkge1xuXHQgICAgdmFyIGNvbXBvc2l0ZSwgaXNDb21wb3NpdGUsIHJvdGF0ZSwgdHJhbnNmb3JtO1xuXHQgICAgcm90YXRlID0gdGhpcy5hbmdsZSAhPT0gMCA/IFwicm90YXRlKFwiICsgdGhpcy5hbmdsZSArIFwiZGVnKVwiIDogJyc7XG5cdCAgICBpc0NvbXBvc2l0ZSA9IHRoaXMucHJvcHMuaXNDb21wb3NpdGVMYXllciAmJiBoLmlzM2Q7XG5cdCAgICBjb21wb3NpdGUgPSBpc0NvbXBvc2l0ZSA/ICd0cmFuc2xhdGVaKDApJyA6ICcnO1xuXHQgICAgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCxcIiArIHkgKyBcInB4KSBcIiArIHJvdGF0ZSArIFwiIFwiICsgY29tcG9zaXRlO1xuXHQgICAgcmV0dXJuIGguc2V0UHJlZml4ZWRTdHlsZSh0aGlzLmVsLCAndHJhbnNmb3JtJywgdHJhbnNmb3JtKTtcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuc2V0TW9kdWxlUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG5cdCAgICB0aGlzLmVsLl9zZXRQcm9wKHtcblx0ICAgICAgc2hpZnRYOiB4ICsgXCJweFwiLFxuXHQgICAgICBzaGlmdFk6IHkgKyBcInB4XCIsXG5cdCAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlXG5cdCAgICB9KTtcblx0ICAgIHJldHVybiB0aGlzLmVsLl9kcmF3KCk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLl9nZXRDdXJyZW50QW5nbGUgPSBmdW5jdGlvbihwb2ludCwgbGVuLCBwKSB7XG5cdCAgICB2YXIgYXRhbiwgaXNUcmFuc2Zvcm1GdW5PcmlnaW4sIHByZXZQb2ludCwgeDEsIHgyO1xuXHQgICAgaXNUcmFuc2Zvcm1GdW5PcmlnaW4gPSB0eXBlb2YgdGhpcy5wcm9wcy50cmFuc2Zvcm1PcmlnaW4gPT09ICdmdW5jdGlvbic7XG5cdCAgICBpZiAodGhpcy5wcm9wcy5pc0FuZ2xlIHx8ICh0aGlzLnByb3BzLmFuZ2xlT2Zmc2V0ICE9IG51bGwpIHx8IGlzVHJhbnNmb3JtRnVuT3JpZ2luKSB7XG5cdCAgICAgIHByZXZQb2ludCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKGxlbiAtIDEpO1xuXHQgICAgICB4MSA9IHBvaW50LnkgLSBwcmV2UG9pbnQueTtcblx0ICAgICAgeDIgPSBwb2ludC54IC0gcHJldlBvaW50Lng7XG5cdCAgICAgIGF0YW4gPSBNYXRoLmF0YW4oeDEgLyB4Mik7XG5cdCAgICAgICFpc0Zpbml0ZShhdGFuKSAmJiAoYXRhbiA9IDApO1xuXHQgICAgICB0aGlzLmFuZ2xlID0gYXRhbiAqIGguUkFEX1RPX0RFRztcblx0ICAgICAgaWYgKCh0eXBlb2YgdGhpcy5wcm9wcy5hbmdsZU9mZnNldCkgIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5hbmdsZSArPSB0aGlzLnByb3BzLmFuZ2xlT2Zmc2V0IHx8IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuYW5nbGUgPSB0aGlzLnByb3BzLmFuZ2xlT2Zmc2V0LmNhbGwodGhpcywgdGhpcy5hbmdsZSwgcCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmFuZ2xlID0gMDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuX3NldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHAsIGlzSW5pdCkge1xuXHQgICAgdmFyIHRyYW5zZm9ybTtcblx0ICAgIGlmICh0aGlzLnNjYWxlcikge1xuXHQgICAgICB4ICo9IHRoaXMuc2NhbGVyLng7XG5cdCAgICAgIHkgKj0gdGhpcy5zY2FsZXIueTtcblx0ICAgIH1cblx0ICAgIHRyYW5zZm9ybSA9IG51bGw7XG5cdCAgICBpZiAoIWlzSW5pdCkge1xuXHQgICAgICB0cmFuc2Zvcm0gPSB0eXBlb2YgdGhpcy5vblVwZGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5vblVwZGF0ZShwLCB7XG5cdCAgICAgICAgeDogeCxcblx0ICAgICAgICB5OiB5LFxuXHQgICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlXG5cdCAgICAgIH0pIDogdm9pZCAwO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuaXNNb2R1bGUpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuc2V0TW9kdWxlUG9zaXRpb24oeCwgeSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZXRFbFBvc2l0aW9uKHgsIHksIHApO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBoLnNldFByZWZpeGVkU3R5bGUodGhpcy5lbCwgJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUuX3NldFRyYW5zZm9ybU9yaWdpbiA9IGZ1bmN0aW9uKHApIHtcblx0ICAgIHZhciBpc1RyYW5zZm9ybUZ1bk9yaWdpbiwgdE9yaWdpbjtcblx0ICAgIGlmICh0aGlzLnByb3BzLnRyYW5zZm9ybU9yaWdpbikge1xuXHQgICAgICBpc1RyYW5zZm9ybUZ1bk9yaWdpbiA9IHR5cGVvZiB0aGlzLnByb3BzLnRyYW5zZm9ybU9yaWdpbiA9PT0gJ2Z1bmN0aW9uJztcblx0ICAgICAgdE9yaWdpbiA9ICFpc1RyYW5zZm9ybUZ1bk9yaWdpbiA/IHRoaXMucHJvcHMudHJhbnNmb3JtT3JpZ2luIDogdGhpcy5wcm9wcy50cmFuc2Zvcm1PcmlnaW4odGhpcy5hbmdsZSwgcCk7XG5cdCAgICAgIHJldHVybiBoLnNldFByZWZpeGVkU3R5bGUodGhpcy5lbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0T3JpZ2luKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUubWFrZU1vdGlvbkJsdXIgPSBmdW5jdGlvbih4LCB5KSB7XG5cdCAgICB2YXIgYWJzb2x1dGVBbmdsZSwgY29vcmRzLCBkWCwgZFksIHNpZ25YLCBzaWduWSwgdGFpbEFuZ2xlO1xuXHQgICAgdGFpbEFuZ2xlID0gMDtcblx0ICAgIHNpZ25YID0gMTtcblx0ICAgIHNpZ25ZID0gMTtcblx0ICAgIGlmICgodGhpcy5wcmV2Q29vcmRzLnggPT0gbnVsbCkgfHwgKHRoaXMucHJldkNvb3Jkcy55ID09IG51bGwpKSB7XG5cdCAgICAgIHRoaXMuc3BlZWRYID0gMDtcblx0ICAgICAgdGhpcy5zcGVlZFkgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZFggPSB4IC0gdGhpcy5wcmV2Q29vcmRzLng7XG5cdCAgICAgIGRZID0geSAtIHRoaXMucHJldkNvb3Jkcy55O1xuXHQgICAgICBpZiAoZFggPiAwKSB7XG5cdCAgICAgICAgc2lnblggPSAtMTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoc2lnblggPCAwKSB7XG5cdCAgICAgICAgc2lnblkgPSAtMTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLnNwZWVkWCA9IE1hdGguYWJzKGRYKTtcblx0ICAgICAgdGhpcy5zcGVlZFkgPSBNYXRoLmFicyhkWSk7XG5cdCAgICAgIHRhaWxBbmdsZSA9IE1hdGguYXRhbihkWSAvIGRYKSAqICgxODAgLyBNYXRoLlBJKSArIDkwO1xuXHQgICAgfVxuXHQgICAgYWJzb2x1dGVBbmdsZSA9IHRhaWxBbmdsZSAtIHRoaXMuYW5nbGU7XG5cdCAgICBjb29yZHMgPSB0aGlzLmFuZ1RvQ29vcmRzKGFic29sdXRlQW5nbGUpO1xuXHQgICAgdGhpcy5ibHVyWCA9IGguY2xhbXAoKHRoaXMuc3BlZWRYIC8gMTYpICogdGhpcy5wcm9wcy5tb3Rpb25CbHVyLCAwLCAxKTtcblx0ICAgIHRoaXMuYmx1clkgPSBoLmNsYW1wKCh0aGlzLnNwZWVkWSAvIDE2KSAqIHRoaXMucHJvcHMubW90aW9uQmx1ciwgMCwgMSk7XG5cdCAgICB0aGlzLnNldEJsdXIoe1xuXHQgICAgICBibHVyOiB7XG5cdCAgICAgICAgeDogMyAqIHRoaXMuYmx1clggKiB0aGlzLmJsdXJBbW91bnQgKiBNYXRoLmFicyhjb29yZHMueCksXG5cdCAgICAgICAgeTogMyAqIHRoaXMuYmx1clkgKiB0aGlzLmJsdXJBbW91bnQgKiBNYXRoLmFicyhjb29yZHMueSlcblx0ICAgICAgfSxcblx0ICAgICAgb2Zmc2V0OiB7XG5cdCAgICAgICAgeDogMyAqIHNpZ25YICogdGhpcy5ibHVyWCAqIGNvb3Jkcy54ICogdGhpcy5ibHVyQW1vdW50LFxuXHQgICAgICAgIHk6IDMgKiBzaWduWSAqIHRoaXMuYmx1clkgKiBjb29yZHMueSAqIHRoaXMuYmx1ckFtb3VudFxuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIHRoaXMucHJldkNvb3Jkcy54ID0geDtcblx0ICAgIHJldHVybiB0aGlzLnByZXZDb29yZHMueSA9IHk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLnNldEJsdXIgPSBmdW5jdGlvbihvKSB7XG5cdCAgICBpZiAoIXRoaXMuaXNNb3Rpb25CbHVyUmVzZXQpIHtcblx0ICAgICAgdGhpcy5maWx0ZXIuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCBvLmJsdXIueCArIFwiLFwiICsgby5ibHVyLnkpO1xuXHQgICAgICB0aGlzLmZpbHRlck9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4Jywgby5vZmZzZXQueCk7XG5cdCAgICAgIHJldHVybiB0aGlzLmZpbHRlck9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5Jywgby5vZmZzZXQueSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmV4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24obykge1xuXHQgICAgdmFyIGtleSwgcmVzdWx0cywgdmFsdWU7XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGtleSBpbiBvKSB7XG5cdCAgICAgIHZhbHVlID0gb1trZXldO1xuXHQgICAgICByZXN1bHRzLnB1c2godGhpc1trZXldID0gdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmV4dGVuZE9wdGlvbnMgPSBmdW5jdGlvbihvKSB7XG5cdCAgICB2YXIga2V5LCByZXN1bHRzLCB2YWx1ZTtcblx0ICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgIGZvciAoa2V5IGluIG8pIHtcblx0ICAgICAgdmFsdWUgPSBvW2tleV07XG5cdCAgICAgIHJlc3VsdHMucHVzaCh0aGlzLnByb3BzW2tleV0gPSB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0ICB9O1xuXG5cdCAgTW90aW9uUGF0aC5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHZhciBpdCwga2V5LCBvcHRzLCBwcmV2T3B0aW9ucywgdmFsdWU7XG5cdCAgICBwcmV2T3B0aW9ucyA9IHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMV07XG5cdCAgICBvcHRzID0ge307XG5cdCAgICBmb3IgKGtleSBpbiBwcmV2T3B0aW9ucykge1xuXHQgICAgICB2YWx1ZSA9IHByZXZPcHRpb25zW2tleV07XG5cdCAgICAgIGlmICghaC5jYWxsYmFja3NNYXBba2V5XSAmJiAhaC50d2Vlbk9wdGlvbk1hcFtrZXldIHx8IGtleSA9PT0gJ2R1cmF0aW9uJykge1xuXHQgICAgICAgIGlmIChvW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgb1trZXldID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChvW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgb1trZXldID0gdm9pZCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAoaC50d2Vlbk9wdGlvbk1hcFtrZXldKSB7XG5cdCAgICAgICAgb3B0c1trZXldID0ga2V5ICE9PSAnZHVyYXRpb24nID8gb1trZXldIDogb1trZXldICE9IG51bGwgPyBvW2tleV0gOiBwcmV2T3B0aW9uc1trZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLmhpc3RvcnkucHVzaChvKTtcblx0ICAgIGl0ID0gdGhpcztcblx0ICAgIG9wdHMub25VcGRhdGUgPSAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKHApIHtcblx0ICAgICAgICByZXR1cm4gX3RoaXMuc2V0UHJvZ3Jlc3MocCk7XG5cdCAgICAgIH07XG5cdCAgICB9KSh0aGlzKTtcblx0ICAgIG9wdHMub25TdGFydCA9IChmdW5jdGlvbihfdGhpcykge1xuXHQgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgdmFyIHJlZjtcblx0ICAgICAgICByZXR1cm4gKHJlZiA9IF90aGlzLnByb3BzLm9uU3RhcnQpICE9IG51bGwgPyByZWYuYXBwbHkoX3RoaXMpIDogdm9pZCAwO1xuXHQgICAgICB9O1xuXHQgICAgfSkodGhpcyk7XG5cdCAgICBvcHRzLm9uQ29tcGxldGUgPSAoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHZhciByZWY7XG5cdCAgICAgICAgcmV0dXJuIChyZWYgPSBfdGhpcy5wcm9wcy5vbkNvbXBsZXRlKSAhPSBudWxsID8gcmVmLmFwcGx5KF90aGlzKSA6IHZvaWQgMDtcblx0ICAgICAgfTtcblx0ICAgIH0pKHRoaXMpO1xuXHQgICAgb3B0cy5vbkZpcnN0VXBkYXRlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBpdC50dW5lT3B0aW9ucyhpdC5oaXN0b3J5W3RoaXMuaW5kZXhdKTtcblx0ICAgIH07XG5cdCAgICBvcHRzLmlzQ2hhaW5lZCA9ICFvLmRlbGF5O1xuXHQgICAgdGhpcy50aW1lbGluZS5hcHBlbmQobmV3IFR3ZWVuKG9wdHMpKTtcblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBNb3Rpb25QYXRoLnByb3RvdHlwZS50dW5lT3B0aW9ucyA9IGZ1bmN0aW9uKG8pIHtcblx0ICAgIHRoaXMuZXh0ZW5kT3B0aW9ucyhvKTtcblx0ICAgIHJldHVybiB0aGlzLnBvc3RWYXJzKCk7XG5cdCAgfTtcblxuXHQgIE1vdGlvblBhdGgucHJvdG90eXBlLmFuZ1RvQ29vcmRzID0gZnVuY3Rpb24oYW5nbGUpIHtcblx0ICAgIHZhciByYWRBbmdsZSwgeCwgeTtcblx0ICAgIGFuZ2xlID0gYW5nbGUgJSAzNjA7XG5cdCAgICByYWRBbmdsZSA9ICgoYW5nbGUgLSA5MCkgKiBNYXRoLlBJKSAvIDE4MDtcblx0ICAgIHggPSBNYXRoLmNvcyhyYWRBbmdsZSk7XG5cdCAgICB5ID0gTWF0aC5zaW4ocmFkQW5nbGUpO1xuXHQgICAgeCA9IHggPCAwID8gTWF0aC5tYXgoeCwgLTAuNykgOiBNYXRoLm1pbih4LCAuNyk7XG5cdCAgICB5ID0geSA8IDAgPyBNYXRoLm1heCh5LCAtMC43KSA6IE1hdGgubWluKHksIC43KTtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHg6IHggKiAxLjQyODU3MTQyOSxcblx0ICAgICAgeTogeSAqIDEuNDI4NTcxNDI5XG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICByZXR1cm4gTW90aW9uUGF0aDtcblxuXHR9KSgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gTW90aW9uUGF0aDtcblxuXG4vKioqLyB9LFxuLyogMjIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBFYXNpbmcsIFBJLCBQYXRoRWFzaW5nLCBhcHByb3hpbWF0ZSwgYmV6aWVyLCBlYXNpbmcsIGgsIG1peCwgc2luO1xuXG5cdGJlemllciA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xuXG5cdFBhdGhFYXNpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxuXHRtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblx0YXBwcm94aW1hdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXyg0Nyk7XG5cblx0c2luID0gTWF0aC5zaW47XG5cblx0UEkgPSBNYXRoLlBJO1xuXG5cdEVhc2luZyA9IChmdW5jdGlvbigpIHtcblx0ICBmdW5jdGlvbiBFYXNpbmcoKSB7fVxuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5iZXppZXIgPSBiZXppZXI7XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLlBhdGhFYXNpbmcgPSBQYXRoRWFzaW5nO1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5wYXRoID0gKG5ldyBQYXRoRWFzaW5nKCdjcmVhdG9yJykpLmNyZWF0ZTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuYXBwcm94aW1hdGUgPSBhcHByb3hpbWF0ZTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblx0ICAgIHJldHVybiAxIC0gcDtcblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5saW5lYXIgPSB7XG5cdCAgICBub25lOiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiBrO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmVhc2UgPSB7XG5cdCAgICBcImluXCI6IGJlemllci5hcHBseShFYXNpbmcsIFswLjQyLCAwLCAxLCAxXSksXG5cdCAgICBvdXQ6IGJlemllci5hcHBseShFYXNpbmcsIFswLCAwLCAwLjU4LCAxXSksXG5cdCAgICBpbm91dDogYmV6aWVyLmFwcGx5KEVhc2luZywgWzAuNDIsIDAsIDAuNTgsIDFdKVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnNpbiA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBQSSAvIDIpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gc2luKGsgKiBQSSAvIDIpO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKFBJICogaykpO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLnF1YWQgPSB7XG5cdCAgICBcImluXCI6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIGsgKiBrO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqICgyIC0gayk7XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuXHQgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuY3ViaWMgPSB7XG5cdCAgICBcImluXCI6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIGsgKiBrICogaztcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5xdWFydCA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgcmV0dXJuIDEgLSAoLS1rICogayAqIGsgKiBrKTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGs7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5xdWludCA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XG5cdCAgICB9LFxuXHQgICAgb3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHJldHVybiAtLWsgKiBrICogayAqIGsgKiBrICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgKiBrICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuZXhwbyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICBpZiAoayA9PT0gMCkge1xuXHQgICAgICAgIHJldHVybiAwO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIGspO1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gMC41ICogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuY2lyYyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuYmFjayA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgcztcblx0ICAgICAgcyA9IDEuNzAxNTg7XG5cdCAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgcztcblx0ICAgICAgcyA9IDEuNzAxNTg7XG5cdCAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuXHQgICAgfSxcblx0ICAgIGlub3V0OiBmdW5jdGlvbihrKSB7XG5cdCAgICAgIHZhciBzO1xuXHQgICAgICBzID0gMS43MDE1OCAqIDEuNTI1O1xuXHQgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqICgocyArIDEpICogayArIHMpICsgMik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEVhc2luZy5wcm90b3R5cGUuZWxhc3RpYyA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuXHQgICAgfSxcblx0ICAgIG91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogaykgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICsgMTtcblx0ICAgIH0sXG5cdCAgICBpbm91dDogZnVuY3Rpb24oaykge1xuXHQgICAgICB2YXIgYSwgcCwgcztcblx0ICAgICAgcyA9IHZvaWQgMDtcblx0ICAgICAgcCA9IDAuNDtcblx0ICAgICAgaWYgKGsgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoayA9PT0gMSkge1xuXHQgICAgICAgIHJldHVybiAxO1xuXHQgICAgICB9XG5cdCAgICAgIGEgPSAxO1xuXHQgICAgICBzID0gcCAvIDQ7XG5cdCAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcblx0ICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIC0xMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKiAwLjUgKyAxO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBFYXNpbmcucHJvdG90eXBlLmJvdW5jZSA9IHtcblx0ICAgIFwiaW5cIjogZnVuY3Rpb24oaykge1xuXHQgICAgICByZXR1cm4gMSAtIGVhc2luZy5ib3VuY2Uub3V0KDEgLSBrKTtcblx0ICAgIH0sXG5cdCAgICBvdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPCAoMSAvIDIuNzUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xuXHQgICAgICB9IGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG5cdCAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG5cdCAgICAgIH0gZWxzZSBpZiAoayA8ICgyLjUgLyAyLjc1KSkge1xuXHQgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjYyNSAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgaW5vdXQ6IGZ1bmN0aW9uKGspIHtcblx0ICAgICAgaWYgKGsgPCAwLjUpIHtcblx0ICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZVtcImluXCJdKGsgKiAyKSAqIDAuNTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZS5vdXQoayAqIDIgLSAxKSAqIDAuNSArIDAuNTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5wYXJzZUVhc2luZyA9IGZ1bmN0aW9uKGVhc2luZykge1xuXHQgICAgdmFyIGVhc2luZ1BhcmVudCwgdHlwZTtcblx0ICAgIGlmIChlYXNpbmcgPT0gbnVsbCkge1xuXHQgICAgICBlYXNpbmcgPSAnbGluZWFyLm5vbmUnO1xuXHQgICAgfVxuXHQgICAgdHlwZSA9IHR5cGVvZiBlYXNpbmc7XG5cdCAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgaWYgKGVhc2luZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA9PT0gJ20nKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucGF0aChlYXNpbmcpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVhc2luZyA9IHRoaXMuX3NwbGl0RWFzaW5nKGVhc2luZyk7XG5cdCAgICAgICAgZWFzaW5nUGFyZW50ID0gdGhpc1tlYXNpbmdbMF1dO1xuXHQgICAgICAgIGlmICghZWFzaW5nUGFyZW50KSB7XG5cdCAgICAgICAgICBoLmVycm9yKFwiRWFzaW5nIHdpdGggbmFtZSBcXFwiXCIgKyBlYXNpbmdbMF0gKyBcIlxcXCIgd2FzIG5vdCBmb3VuZCwgZmFsbGJhY2sgdG8gXFxcImxpbmVhci5ub25lXFxcIiBpbnN0ZWFkXCIpO1xuXHQgICAgICAgICAgcmV0dXJuIHRoaXNbJ2xpbmVhciddWydub25lJ107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBlYXNpbmdQYXJlbnRbZWFzaW5nWzFdXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGguaXNBcnJheShlYXNpbmcpKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmJlemllci5hcHBseSh0aGlzLCBlYXNpbmcpO1xuXHQgICAgfVxuXHQgICAgaWYgKCdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIGVhc2luZztcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRWFzaW5nLnByb3RvdHlwZS5fc3BsaXRFYXNpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0ICAgIHZhciBmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHNwbGl0O1xuXHQgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIHN0cmluZztcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmcubGVuZ3RoKSB7XG5cdCAgICAgIHNwbGl0ID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdCAgICAgIGZpcnN0UGFydCA9IHNwbGl0WzBdLnRvTG93ZXJDYXNlKCkgfHwgJ2xpbmVhcic7XG5cdCAgICAgIHNlY29uZFBhcnQgPSBzcGxpdFsxXS50b0xvd2VyQ2FzZSgpIHx8ICdub25lJztcblx0ICAgICAgcmV0dXJuIFtmaXJzdFBhcnQsIHNlY29uZFBhcnRdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmV0dXJuIFsnbGluZWFyJywgJ25vbmUnXTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVhc2luZztcblxuXHR9KSgpO1xuXG5cdGVhc2luZyA9IG5ldyBFYXNpbmc7XG5cblx0ZWFzaW5nLm1peCA9IG1peChlYXNpbmcpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZWFzaW5nO1xuXG5cbi8qKiovIH0sXG4vKiAyMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG5cdCAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG5cdCAgfVxuXHR9O1xuXG4vKioqLyB9LFxuLyogMjQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuXHQgIGlmICghc2VsZikge1xuXHQgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuXHQgIH1cblxuXHQgIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMjUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF9zZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oNDgpO1xuXG5cdHZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG5cdHZhciBfY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG5cblx0dmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuXHQgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuXHQgIH1cblxuXHQgIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG5cdCAgICBjb25zdHJ1Y3Rvcjoge1xuXHQgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG5cdCAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXHQgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9XG5cdCAgfSk7XG5cdCAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAyNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7XG5cblx0dmFyIF9pbmhlcml0czIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuXHR2YXIgX2luaGVyaXRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2luaGVyaXRzMik7XG5cblx0dmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuXHR2YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5cdHZhciBfaCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdHZhciBfaDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBCaXQgPSBmdW5jdGlvbiAoX01vZHVsZSkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEJpdCwgX01vZHVsZSk7XG5cblx0ICBmdW5jdGlvbiBCaXQoKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBCaXQpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX01vZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblx0ICBCaXQucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgdGhpcy5fZGVmYXVsdHMgPSB7XG5cdCAgICAgICducyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdCAgICAgICd0YWcnOiAnZWxsaXBzZScsXG5cdCAgICAgICdwYXJlbnQnOiBkb2N1bWVudC5ib2R5LFxuXHQgICAgICAncmF0aW8nOiAxLFxuXHQgICAgICAncmFkaXVzJzogNTAsXG5cdCAgICAgICdyYWRpdXNYJzogbnVsbCxcblx0ICAgICAgJ3JhZGl1c1knOiBudWxsLFxuXHQgICAgICAnc3Ryb2tlJzogJ2hvdHBpbmsnLFxuXHQgICAgICAnc3Ryb2tlLWRhc2hhcnJheSc6ICcnLFxuXHQgICAgICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnJyxcblx0ICAgICAgJ3N0cm9rZS1saW5lY2FwJzogJycsXG5cdCAgICAgICdzdHJva2Utd2lkdGgnOiAyLFxuXHQgICAgICAnc3Ryb2tlLW9wYWNpdHknOiAxLFxuXHQgICAgICAnZmlsbCc6ICd0cmFuc3BhcmVudCcsXG5cdCAgICAgICdmaWxsLW9wYWNpdHknOiAxLFxuXHQgICAgICAnd2lkdGgnOiAwLFxuXHQgICAgICAnaGVpZ2h0JzogMFxuXHQgICAgfTtcblx0ICAgIHRoaXMuX2RyYXdNYXAgPSBbJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLWRhc2hhcnJheScsICdmaWxsJywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ2ZpbGwtb3BhY2l0eScsICd0cmFuc2Zvcm0nXTtcblx0ICB9O1xuXG5cdCAgQml0LnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uIF92YXJzKCkge1xuXHQgICAgdGhpcy5fc3RhdGUgPSB7fTtcblx0ICAgIHRoaXMuX2RyYXdNYXBMZW5ndGggPSB0aGlzLl9kcmF3TWFwLmxlbmd0aDtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlbmRlcmVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIC8vIHNldCBgX2lzUmVuZGVyZWRgIGhhdGNoXG5cdCAgICB0aGlzLl9pc1JlbmRlcmVkID0gdHJ1ZTtcblx0ICAgIC8vIGNyZWF0ZSBgU1ZHYCBjYW52YXMgdG8gZHJhdyBpblxuXHQgICAgdGhpcy5fY3JlYXRlU1ZHQ2FudmFzKCk7XG5cdCAgICAvLyBzZXQgY2FudmFzIHNpemVcblx0ICAgIHRoaXMuX3NldENhbnZhc1NpemUoKTtcblx0ICAgIC8vIGRyYXcgdGhlIGluaXRpYWwgc3RhdGVcblx0ICAgIC8vIHRoaXMuX2RyYXcoKTtcblx0ICAgIC8vIGFwcGVuZCB0aGUgY2FudmFzIHRvIHRoZSBwYXJlbnQgZnJvbSBwcm9wc1xuXHQgICAgdGhpcy5fcHJvcHMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGNyZWF0ZSBgU1ZHYCBjYW52YXMgdG8gZHJhdyBpbi5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fY3JlYXRlU1ZHQ2FudmFzID0gZnVuY3Rpb24gX2NyZWF0ZVNWR0NhbnZhcygpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICAvLyBjcmVhdGUgY2FudmFzIC0gYHN2Z2AgZWxlbWVudCB0byBkcmF3IGluXG5cdCAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocC5ucywgJ3N2ZycpO1xuXHQgICAgLy8gY3JlYXRlIHRoZSBlbGVtZW50IHNoYXBlIGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgY2FudmFzXG5cdCAgICB0aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHAubnMsIHAudGFnKTtcblx0ICAgIHRoaXMuX2NhbnZhcy5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gc2V0IHNpemUgb2YgdGhlIF9jYW52YXMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3NldENhbnZhc1NpemUgPSBmdW5jdGlvbiBfc2V0Q2FudmFzU2l6ZSgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgc3R5bGUgPSB0aGlzLl9jYW52YXMuc3R5bGU7XG5cblx0ICAgIHN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHQgICAgc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdCAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdCAgICBzdHlsZS5sZWZ0ID0gJzBweCc7XG5cdCAgICBzdHlsZS50b3AgPSAnMHB4Jztcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyB0aGUgc2hhcGUuXG5cdCAgICBDYWxsZWQgb24gZXZlcnkgZnJhbWUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbiBfZHJhdygpIHtcblx0ICAgIHRoaXMuX3Byb3BzLmxlbmd0aCA9IHRoaXMuX2dldExlbmd0aCgpO1xuXG5cdCAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZSxcblx0ICAgICAgICBwcm9wcyA9IHRoaXMuX3Byb3BzO1xuXG5cdCAgICB2YXIgbGVuID0gdGhpcy5fZHJhd01hcExlbmd0aDtcblx0ICAgIHdoaWxlIChsZW4tLSkge1xuXHQgICAgICB2YXIgbmFtZSA9IHRoaXMuX2RyYXdNYXBbbGVuXTtcblx0ICAgICAgc3dpdGNoIChuYW1lKSB7XG5cdCAgICAgICAgY2FzZSAnc3Ryb2tlLWRhc2hhcnJheSc6XG5cdCAgICAgICAgY2FzZSAnc3Ryb2tlLWRhc2hvZmZzZXQnOlxuXHQgICAgICAgICAgdGhpcy5jYXN0U3Ryb2tlRGFzaChuYW1lKTtcblx0ICAgICAgfVxuXHQgICAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKG5hbWUsIHRoaXMuX3Byb3BzW25hbWVdKTtcblx0ICAgIH1cblx0ICAgIHRoaXMuX3N0YXRlLnJhZGl1cyA9IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICB9O1xuXG5cdCAgQml0LnByb3RvdHlwZS5jYXN0U3Ryb2tlRGFzaCA9IGZ1bmN0aW9uIGNhc3RTdHJva2VEYXNoKG5hbWUpIHtcblx0ICAgIC8vICMgaWYgYXJyYXkgb2YgdmFsdWVzXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKF9oMi5kZWZhdWx0LmlzQXJyYXkocFtuYW1lXSkpIHtcblx0ICAgICAgdmFyIHN0cm9rZSA9ICcnO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBbbmFtZV0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgZGFzaCA9IHBbbmFtZV1baV0sXG5cdCAgICAgICAgICAgIGNhc3QgPSBkYXNoLnVuaXQgPT09ICclJyA/IHRoaXMuY2FzdFBlcmNlbnQoZGFzaC52YWx1ZSkgOiBkYXNoLnZhbHVlO1xuXHQgICAgICAgIHN0cm9rZSArPSBjYXN0ICsgJyAnO1xuXHQgICAgICB9XG5cdCAgICAgIHBbbmFtZV0gPSBzdHJva2UgPT09ICcwICcgPyBzdHJva2UgPSAnJyA6IHN0cm9rZTtcblx0ICAgICAgcmV0dXJuIHBbbmFtZV0gPSBzdHJva2U7XG5cdCAgICB9XG5cdCAgICAvLyAjIGlmIHNpbmdsZSB2YWx1ZVxuXHQgICAgaWYgKCgwLCBfdHlwZW9mMy5kZWZhdWx0KShwW25hbWVdKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgICAgc3Ryb2tlID0gcFtuYW1lXS51bml0ID09PSAnJScgPyB0aGlzLmNhc3RQZXJjZW50KHBbbmFtZV0udmFsdWUpIDogcFtuYW1lXS52YWx1ZTtcblx0ICAgICAgcFtuYW1lXSA9IHN0cm9rZSA9PT0gMCA/IHN0cm9rZSA9ICcnIDogc3Ryb2tlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCaXQucHJvdG90eXBlLmNhc3RQZXJjZW50ID0gZnVuY3Rpb24gY2FzdFBlcmNlbnQocGVyY2VudCkge1xuXHQgICAgcmV0dXJuIHBlcmNlbnQgKiAodGhpcy5fcHJvcHMubGVuZ3RoIC8gMTAwKTtcblx0ICB9O1xuXG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBzZXQgcHJvcHMgdG8gYXR0cmlidXRlcyBhbmQgY2FjaGUgdGhlIHZhbHVlcy5cblx0ICAgIEBwcml2YXRlXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fc2V0QXR0cklmQ2hhbmdlZCA9IGZ1bmN0aW9uIF9zZXRBdHRySWZDaGFuZ2VkKG5hbWUsIHZhbHVlKSB7XG5cdCAgICBpZiAodGhpcy5fc3RhdGVbbmFtZV0gIT09IHZhbHVlKSB7XG5cdCAgICAgIC8vIHRoaXMuZWwuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHQgICAgICB0aGlzLl9zdGF0ZVtuYW1lXSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBsZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IExlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24gX2dldExlbmd0aCgpIHtcblx0ICAgIHZhciBwID0gdGhpcy5fcHJvcHMsXG5cdCAgICAgICAgbGVuID0gMCxcblx0ICAgICAgICBpc0dldExlbmd0aCA9ICEhKHRoaXMuZWwgJiYgdGhpcy5lbC5nZXRUb3RhbExlbmd0aCk7XG5cblx0ICAgIGlmIChpc0dldExlbmd0aCAmJiB0aGlzLmVsLmdldEF0dHJpYnV0ZSgnZCcpKSB7XG5cdCAgICAgIGxlbiA9IHRoaXMuZWwuZ2V0VG90YWxMZW5ndGgoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGxlbiA9IDIgKiAocC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGVuO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBjYWxjdWxhdGUgdG90YWwgc3VtIGJldHdlZW4gcG9pbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7QXJyYXl9IEFycmF5IG9mIHBvaW50cy5cblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IERpc3RhbmNlIGJld3R3ZWVuIGFsbCBwb2ludHMuXG5cdCAgKi9cblxuXG5cdCAgQml0LnByb3RvdHlwZS5fZ2V0UG9pbnRzUGVyaW1pdGVyID0gZnVuY3Rpb24gX2dldFBvaW50c1BlcmltaXRlcihwb2ludHMpIHtcblx0ICAgIHZhciBzdW0gPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBzdW0gKz0gdGhpcy5fcG9pbnRzRGVsdGEocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcblx0ICAgIH1cblxuXHQgICAgc3VtICs9IHRoaXMuX3BvaW50c0RlbHRhKHBvaW50c1swXSwgX2gyLmRlZmF1bHQuZ2V0TGFzdEl0ZW0ocG9pbnRzKSk7XG5cdCAgICByZXR1cm4gc3VtO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgZGVsdGEgZnJvbSB0d28gcG9pbnRzLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7T2JqZWN0fSBQb2ludCAxLlxuXHQgICAgQHBhcmFtIHtPYmplY3R9IFBvaW50IDIuXG5cdCAgICBAcmV0dXJucyB7TnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb29pbnRzLlxuXHQgICovXG5cblxuXHQgIEJpdC5wcm90b3R5cGUuX3BvaW50c0RlbHRhID0gZnVuY3Rpb24gX3BvaW50c0RlbHRhKHBvaW50MSwgcG9pbnQyKSB7XG5cdCAgICB2YXIgZHggPSBNYXRoLmFicyhwb2ludDEueCAtIHBvaW50Mi54KSxcblx0ICAgICAgICBkeSA9IE1hdGguYWJzKHBvaW50MS55IC0gcG9pbnQyLnkpO1xuXHQgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIHNldCBtb2R1bGUncyBzaXplLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBwYXJhbSB7TnVtYmVyfSBNb2R1bGUgd2lkdGguXG5cdCAgICBAcGFyYW0ge051bWJlcn0gTW9kdWxlIGhlaWdodC5cblx0ICAqL1xuXG5cblx0ICBCaXQucHJvdG90eXBlLl9zZXRTaXplID0gZnVuY3Rpb24gX3NldFNpemUod2lkdGgsIGhlaWdodCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHAud2lkdGggPSB3aWR0aDtcblx0ICAgIHAuaGVpZ2h0ID0gaGVpZ2h0O1xuXHQgICAgdGhpcy5fZHJhdygpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gQml0O1xuXHR9KF9tb2R1bGUyLmRlZmF1bHQpO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEJpdDtcblxuLyoqKi8gfSxcbi8qIDI3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XG5cblx0dmFyIF9hc3NpZ24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXNzaWduKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IF9hc3NpZ24yLmRlZmF1bHQgfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG5cdCAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG5cdCAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0YXJnZXQ7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAyOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9LFxuLyogMjkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXyg1MSksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSxcbi8qIDMwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKCkge1xuXHQgICd1c2Ugc3RyaWN0Jztcblx0ICB2YXIgY2FuY2VsLCBpLCBpc09sZEJyb3dzZXIsIGxhc3RUaW1lLCB2ZW5kb3JzLCB2cCwgdztcblx0ICB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XG5cdCAgaSA9IDA7XG5cdCAgdyA9IHdpbmRvdztcblx0ICB3aGlsZSAoaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHQgICAgdnAgPSB2ZW5kb3JzW2ldO1xuXHQgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3W3ZwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHQgICAgY2FuY2VsID0gd1t2cCArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xuXHQgICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNhbmNlbCB8fCB3W3ZwICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuXHQgICAgKytpO1xuXHQgIH1cblx0ICBpc09sZEJyb3dzZXIgPSAhdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXcuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cdCAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3Lm5hdmlnYXRvci51c2VyQWdlbnQpIHx8IGlzT2xkQnJvd3Nlcikge1xuXHQgICAgbGFzdFRpbWUgPSAwO1xuXHQgICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHQgICAgICB2YXIgbmV4dFRpbWUsIG5vdztcblx0ICAgICAgbm93ID0gRGF0ZS5ub3coKTtcblx0ICAgICAgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xuXHQgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XG5cdCAgICAgIH0pLCBuZXh0VGltZSAtIG5vdyk7XG5cdCAgICB9O1xuXHQgICAgdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcblx0ICB9XG5cdH0pKCk7XG5cblxuLyoqKi8gfSxcbi8qIDMxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKHJvb3QpIHtcblx0ICB2YXIgb2Zmc2V0LCByZWYsIHJlZjE7XG5cdCAgaWYgKHJvb3QucGVyZm9ybWFuY2UgPT0gbnVsbCkge1xuXHQgICAgcm9vdC5wZXJmb3JtYW5jZSA9IHt9O1xuXHQgIH1cblx0ICBEYXRlLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xuXHQgIH07XG5cdCAgaWYgKHJvb3QucGVyZm9ybWFuY2Uubm93ID09IG51bGwpIHtcblx0ICAgIG9mZnNldCA9ICgocmVmID0gcm9vdC5wZXJmb3JtYW5jZSkgIT0gbnVsbCA/IChyZWYxID0gcmVmLnRpbWluZykgIT0gbnVsbCA/IHJlZjEubmF2aWdhdGlvblN0YXJ0IDogdm9pZCAwIDogdm9pZCAwKSA/IHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgOiBEYXRlLm5vdygpO1xuXHQgICAgcmV0dXJuIHJvb3QucGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gb2Zmc2V0O1xuXHQgICAgfTtcblx0ICB9XG5cdH0pKHdpbmRvdyk7XG5cblxuLyoqKi8gfSxcbi8qIDMyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSxcbi8qIDMzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oNTQpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0sXG4vKiAzNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1xuXHQvKiFcblx0ICBMZWdvTXVzaHJvb20gQGxlZ29tdXNocm9vbSBodHRwOi8vbGVnb211c2hyb29tLmNvbVxuXHQgIE1JVCBMaWNlbnNlIDIwMTRcblx0ICovXG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0KGZ1bmN0aW9uKCkge1xuXHQgIHZhciBNYWluO1xuXHQgIE1haW4gPSAoZnVuY3Rpb24oKSB7XG5cdCAgICBmdW5jdGlvbiBNYWluKG8pIHtcblx0ICAgICAgdGhpcy5vID0gbyAhPSBudWxsID8gbyA6IHt9O1xuXHQgICAgICBpZiAod2luZG93LmlzQW55UmVzaXplRXZlbnRJbml0ZWQpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICAgIH1cblx0ICAgICAgdGhpcy52YXJzKCk7XG5cdCAgICAgIHRoaXMucmVkZWZpbmVQcm90bygpO1xuXHQgICAgfVxuXG5cdCAgICBNYWluLnByb3RvdHlwZS52YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHdpbmRvdy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkID0gdHJ1ZTtcblx0ICAgICAgdGhpcy5hbGxvd2VkUHJvdG9zID0gW0hUTUxEaXZFbGVtZW50LCBIVE1MRm9ybUVsZW1lbnQsIEhUTUxMaW5rRWxlbWVudCwgSFRNTEJvZHlFbGVtZW50LCBIVE1MUGFyYWdyYXBoRWxlbWVudCwgSFRNTEZpZWxkU2V0RWxlbWVudCwgSFRNTExlZ2VuZEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MT0xpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBIVE1MSGVhZGluZ0VsZW1lbnQsIEhUTUxRdW90ZUVsZW1lbnQsIEhUTUxQcmVFbGVtZW50LCBIVE1MQlJFbGVtZW50LCBIVE1MRm9udEVsZW1lbnQsIEhUTUxIUkVsZW1lbnQsIEhUTUxNb2RFbGVtZW50LCBIVE1MUGFyYW1FbGVtZW50LCBIVE1MTWFwRWxlbWVudCwgSFRNTFRhYmxlRWxlbWVudCwgSFRNTFRhYmxlQ2FwdGlvbkVsZW1lbnQsIEhUTUxJbWFnZUVsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTElucHV0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEFuY2hvckVsZW1lbnQsIEhUTUxPYmplY3RFbGVtZW50LCBIVE1MVGFibGVDb2xFbGVtZW50LCBIVE1MVGFibGVTZWN0aW9uRWxlbWVudCwgSFRNTFRhYmxlUm93RWxlbWVudF07XG5cdCAgICAgIHJldHVybiB0aGlzLnRpbWVyRWxlbWVudHMgPSB7XG5cdCAgICAgICAgaW1nOiAxLFxuXHQgICAgICAgIHRleHRhcmVhOiAxLFxuXHQgICAgICAgIGlucHV0OiAxLFxuXHQgICAgICAgIGVtYmVkOiAxLFxuXHQgICAgICAgIG9iamVjdDogMSxcblx0ICAgICAgICBzdmc6IDEsXG5cdCAgICAgICAgY2FudmFzOiAxLFxuXHQgICAgICAgIHRyOiAxLFxuXHQgICAgICAgIHRib2R5OiAxLFxuXHQgICAgICAgIHRoZWFkOiAxLFxuXHQgICAgICAgIHRmb290OiAxLFxuXHQgICAgICAgIGE6IDEsXG5cdCAgICAgICAgc2VsZWN0OiAxLFxuXHQgICAgICAgIG9wdGlvbjogMSxcblx0ICAgICAgICBvcHRncm91cDogMSxcblx0ICAgICAgICBkbDogMSxcblx0ICAgICAgICBkdDogMSxcblx0ICAgICAgICBicjogMSxcblx0ICAgICAgICBiYXNlZm9udDogMSxcblx0ICAgICAgICBmb250OiAxLFxuXHQgICAgICAgIGNvbDogMSxcblx0ICAgICAgICBpZnJhbWU6IDFcblx0ICAgICAgfTtcblx0ICAgIH07XG5cblx0ICAgIE1haW4ucHJvdG90eXBlLnJlZGVmaW5lUHJvdG8gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGksIGl0LCBwcm90bywgdDtcblx0ICAgICAgaXQgPSB0aGlzO1xuXHQgICAgICByZXR1cm4gdCA9IChmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgaiwgbGVuLCByZWYsIHJlc3VsdHM7XG5cdCAgICAgICAgcmVmID0gdGhpcy5hbGxvd2VkUHJvdG9zO1xuXHQgICAgICAgIHJlc3VsdHMgPSBbXTtcblx0ICAgICAgICBmb3IgKGkgPSBqID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaiA8IGxlbjsgaSA9ICsraikge1xuXHQgICAgICAgICAgcHJvdG8gPSByZWZbaV07XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICByZXN1bHRzLnB1c2goKGZ1bmN0aW9uKHByb3RvKSB7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lciwgcmVtb3Zlcjtcblx0ICAgICAgICAgICAgbGlzdGVuZXIgPSBwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciB8fCBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICAgIChmdW5jdGlvbihsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgIHZhciB3cmFwcGVkTGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgd3JhcHBlZExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9uO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IHdpbmRvdyB8fCB0aGlzICE9PSBkb2N1bWVudCkge1xuXHQgICAgICAgICAgICAgICAgICBvcHRpb24gPSBhcmd1bWVudHNbMF0gPT09ICdvbnJlc2l6ZScgJiYgIXRoaXMuaXNBbnlSZXNpemVFdmVudEluaXRlZDtcblx0ICAgICAgICAgICAgICAgICAgb3B0aW9uICYmIGl0LmhhbmRsZVJlc2l6ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnczogYXJndW1lbnRzLFxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQ6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgIGlmIChwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gd3JhcHBlZExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50ID0gd3JhcHBlZExpc3RlbmVyO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSkobGlzdGVuZXIpO1xuXHQgICAgICAgICAgICByZW1vdmVyID0gcHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgcHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50O1xuXHQgICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKHJlbW92ZXIpIHtcblx0ICAgICAgICAgICAgICB2YXIgd3JhcHBlZFJlbW92ZXI7XG5cdCAgICAgICAgICAgICAgd3JhcHBlZFJlbW92ZXIgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaXNBbnlSZXNpemVFdmVudEluaXRlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pZnJhbWUgJiYgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmlmcmFtZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgaWYgKHByb3RvLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSB3cmFwcGVkUmVtb3Zlcjtcblx0ICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3RvLnByb3RvdHlwZS5kZXRhY2hFdmVudCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5kZXRhY2hFdmVudCA9IHdyYXBwZWRMaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pKHJlbW92ZXIpO1xuXHQgICAgICAgICAgfSkocHJvdG8pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG5cdCAgICAgIH0pLmNhbGwodGhpcyk7XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgIHZhciBjb21wdXRlZFN0eWxlLCBlbCwgaWZyYW1lLCBpc0VtcHR5LCBpc05vUG9zLCBpc1N0YXRpYywgcmVmO1xuXHQgICAgICBlbCA9IGFyZ3MudGhhdDtcblx0ICAgICAgaWYgKCF0aGlzLnRpbWVyRWxlbWVudHNbZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuXHQgICAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHQgICAgICAgIGVsLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuXHQgICAgICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0ICAgICAgICBpZnJhbWUuc3R5bGUuekluZGV4ID0gLTk5OTtcblx0ICAgICAgICBpZnJhbWUuc3R5bGUub3BhY2l0eSA9IDA7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG5cdCAgICAgICAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuXHQgICAgICAgIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUoZWwpIDogZWwuY3VycmVudFN0eWxlO1xuXHQgICAgICAgIGlzTm9Qb3MgPSBlbC5zdHlsZS5wb3NpdGlvbiA9PT0gJyc7XG5cdCAgICAgICAgaXNTdGF0aWMgPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBpc05vUG9zO1xuXHQgICAgICAgIGlzRW1wdHkgPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnJyAmJiBlbC5zdHlsZS5wb3NpdGlvbiA9PT0gJyc7XG5cdCAgICAgICAgaWYgKGlzU3RhdGljIHx8IGlzRW1wdHkpIHtcblx0ICAgICAgICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKChyZWYgPSBpZnJhbWUuY29udGVudFdpbmRvdykgIT0gbnVsbCkge1xuXHQgICAgICAgICAgcmVmLm9ucmVzaXplID0gKGZ1bmN0aW9uKF90aGlzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRpc3BhdGNoRXZlbnQoZWwpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfSkodGhpcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsLmlmcmFtZSA9IGlmcmFtZTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLmluaXRUaW1lcihlbCk7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGVsLmlzQW55UmVzaXplRXZlbnRJbml0ZWQgPSB0cnVlO1xuXHQgICAgfTtcblxuXHQgICAgTWFpbi5wcm90b3R5cGUuaW5pdFRpbWVyID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cdCAgICAgIHdpZHRoID0gMDtcblx0ICAgICAgaGVpZ2h0ID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZnVuY3Rpb24oX3RoaXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICB2YXIgbmV3SGVpZ2h0LCBuZXdXaWR0aDtcblx0ICAgICAgICAgIG5ld1dpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG5cdCAgICAgICAgICBuZXdIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG5cdCAgICAgICAgICBpZiAobmV3V2lkdGggIT09IHdpZHRoIHx8IG5ld0hlaWdodCAhPT0gaGVpZ2h0KSB7XG5cdCAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoZWwpO1xuXHQgICAgICAgICAgICB3aWR0aCA9IG5ld1dpZHRoO1xuXHQgICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgIH0pKHRoaXMpLCB0aGlzLm8uaW50ZXJ2YWwgfHwgNjIuNSk7XG5cdCAgICB9O1xuXG5cdCAgICBNYWluLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZWwpIHtcblx0ICAgICAgdmFyIGU7XG5cdCAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuXHQgICAgICAgIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuXHQgICAgICAgIGUuaW5pdEV2ZW50KCdvbnJlc2l6ZScsIGZhbHNlLCBmYWxzZSk7XG5cdCAgICAgICAgcmV0dXJuIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcblx0ICAgICAgICBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcblx0ICAgICAgICByZXR1cm4gZWwuZmlyZUV2ZW50KCdvbnJlc2l6ZScsIGUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgTWFpbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICB2YXIgaSwgaXQsIGosIGxlbiwgcHJvdG8sIHJlZiwgcmVzdWx0cztcblx0ICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcblx0ICAgICAgdGhpcy5pbnRlcnZhbCA9IG51bGw7XG5cdCAgICAgIHdpbmRvdy5pc0FueVJlc2l6ZUV2ZW50SW5pdGVkID0gZmFsc2U7XG5cdCAgICAgIGl0ID0gdGhpcztcblx0ICAgICAgcmVmID0gdGhpcy5hbGxvd2VkUHJvdG9zO1xuXHQgICAgICByZXN1bHRzID0gW107XG5cdCAgICAgIGZvciAoaSA9IGogPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG5cdCAgICAgICAgcHJvdG8gPSByZWZbaV07XG5cdCAgICAgICAgaWYgKHByb3RvLnByb3RvdHlwZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0cy5wdXNoKChmdW5jdGlvbihwcm90bykge1xuXHQgICAgICAgICAgdmFyIGxpc3RlbmVyO1xuXHQgICAgICAgICAgbGlzdGVuZXIgPSBwcm90by5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciB8fCBwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgcHJvdG8ucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBFbGVtZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHQgICAgICAgICAgfSBlbHNlIGlmIChwcm90by5wcm90b3R5cGUuYXR0YWNoRXZlbnQpIHtcblx0ICAgICAgICAgICAgcHJvdG8ucHJvdG90eXBlLmF0dGFjaEV2ZW50ID0gRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoRXZlbnQ7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgICBpZiAocHJvdG8ucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3RvLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8ucHJvdG90eXBlLmRldGFjaEV2ZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm90by5wcm90b3R5cGUuZGV0YWNoRXZlbnQgPSBFbGVtZW50LnByb3RvdHlwZS5kZXRhY2hFdmVudDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KShwcm90bykpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiByZXN1bHRzO1xuXHQgICAgfTtcblxuXHQgICAgcmV0dXJuIE1haW47XG5cblx0ICB9KSgpO1xuXHQgIGlmICh0cnVlKSB7XG5cdCAgICByZXR1cm4gIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWFpbjtcblx0ICAgIH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0ICB9IGVsc2UgaWYgKCh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSAmJiAodHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSkge1xuXHQgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gbmV3IE1haW47XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyAhPT0gbnVsbCkge1xuXHQgICAgICB3aW5kb3cuQW55UmVzaXplRXZlbnQgPSBNYWluO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93ICE9PSBudWxsID8gd2luZG93LmFueVJlc2l6ZUV2ZW50ID0gbmV3IE1haW4gOiB2b2lkIDA7XG5cdCAgfVxuXHR9KSgpO1xuXG5cbi8qKiovIH0sXG4vKiAzNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFJlY3QsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cblx0UmVjdCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKFJlY3QsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gUmVjdCgpIHtcblx0ICAgIHJldHVybiBSZWN0Ll9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIFJlY3QucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFJlY3QuX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdyZWN0Jztcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnJ4ID0gMDtcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy5yeSA9IDA7XG5cdCAgfTtcblxuXHQgIFJlY3QucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcCwgcmFkaXVzWCwgcmFkaXVzWTtcblx0ICAgIFJlY3QuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICBwID0gdGhpcy5fcHJvcHM7XG5cdCAgICByYWRpdXNYID0gcC5yYWRpdXNYICE9IG51bGwgPyBwLnJhZGl1c1ggOiBwLnJhZGl1cztcblx0ICAgIHJhZGl1c1kgPSBwLnJhZGl1c1kgIT0gbnVsbCA/IHAucmFkaXVzWSA6IHAucmFkaXVzO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnd2lkdGgnLCAyICogcmFkaXVzWCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdoZWlnaHQnLCAyICogcmFkaXVzWSk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd4JywgKHAud2lkdGggLyAyKSAtIHJhZGl1c1gpO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneScsIChwLmhlaWdodCAvIDIpIC0gcmFkaXVzWSk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdyeCcsIHAucngpO1xuXHQgICAgcmV0dXJuIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3J5JywgcC5yeSk7XG5cdCAgfTtcblxuXHQgIFJlY3QucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJldHVybiAyICogKDIgKiByYWRpdXNYICsgMiAqIHJhZGl1c1kpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUmVjdDtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUmVjdDtcblxuXG4vKioqLyB9LFxuLyogMzYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2syID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cblx0dmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpO1xuXG5cdHZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjIpO1xuXG5cdHZhciBfaW5oZXJpdHMyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cblx0dmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpO1xuXG5cdHZhciBfYml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cblx0dmFyIF9iaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYml0KTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBDdXN0b20gPSBmdW5jdGlvbiAoX0JpdCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEN1c3RvbSwgX0JpdCk7XG5cblx0ICBmdW5jdGlvbiBDdXN0b20oKSB7XG5cdCAgICAoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBDdXN0b20pO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX0JpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbiBfZGVjbGFyZURlZmF1bHRzKCkge1xuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cy5jYWxsKHRoaXMpO1xuXG5cdCAgICB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy5wYXJlbnQgPSBudWxsO1xuXG5cdCAgICAvLyByZW1vdmUgYHN0cm9rZS13aWR0aGAgZnJvbSBgX2RyYXdNYXBgXG5cdCAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gcmVjYWwgc3Ryb2tlV2lkdGggc2l6ZSByZWdhcmRpbmcgc2NhbGVcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZHJhd01hcC5sZW5ndGg7IGkrKykge1xuXHQgICAgICBpZiAodGhpcy5fZHJhd01hcFtpXSA9PT0gJ3N0cm9rZS13aWR0aCcpIHtcblx0ICAgICAgICB0aGlzLl9kcmF3TWFwLnNwbGljZShpLCAxKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2hhcGUgdG8gc2V0IG9uIG1vZHVsZSdzIHBhdGguXG5cdCAgICBAcHVibGljXG5cdCAgICBAcmV0dXJucyB7U3RyaW5nfSBFbXB0eSBzdHJpbmcuXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5nZXRTaGFwZSA9IGZ1bmN0aW9uIGdldFNoYXBlKCkge1xuXHQgICAgcmV0dXJuICcnO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2hhcGUgcGVyaW1ldGVyIGxlbmd0aC5cblx0ICAgIEBwdWJsaWNcblx0ICAgIEByZXR1cm5zIHtOdW1iZXJ9IERlZmF1bHQgbGVuZ3RoIHN0cmluZy5cblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcblx0ICAgIHJldHVybiAxMDA7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgdGhlIHNoYXBlLlxuXHQgICAgQ2FsbGVkIG9uIGV2ZXJ5IGZyYW1lLlxuXHQgICAgQHByaXZhdGVcblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHN0YXRlID0gdGhpcy5fc3RhdGUsXG5cdCAgICAgICAgcmFkaXVzWENoYW5nZSA9IHN0YXRlWydyYWRpdXNYJ10gIT09IHAucmFkaXVzWCxcblx0ICAgICAgICByYWRpdXNZQ2hhbmdlID0gc3RhdGVbJ3JhZGl1c1knXSAhPT0gcC5yYWRpdXNZLFxuXHQgICAgICAgIHJhZGl1c0NoYW5nZSA9IHN0YXRlWydyYWRpdXMnXSAhPT0gcC5yYWRpdXM7XG5cblx0ICAgIC8vIHVwZGF0ZSB0cmFuc2Zvcm0gb25seSBpZiBvbmUgb2YgcmFkaXVzZXMgY2hhbmdlZFxuXHQgICAgaWYgKHJhZGl1c1hDaGFuZ2UgfHwgcmFkaXVzWUNoYW5nZSB8fCByYWRpdXNDaGFuZ2UpIHtcblx0ICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRoaXMuX2dldFNjYWxlKCkpO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzWCddID0gcC5yYWRpdXNYO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzWSddID0gcC5yYWRpdXNZO1xuXHQgICAgICBzdGF0ZVsncmFkaXVzJ10gPSBwLnJhZGl1cztcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgnc3Ryb2tlLXdpZHRoJywgcFsnc3Ryb2tlLXdpZHRoJ10gLyBwLm1heFNjYWxlKTtcblxuXHQgICAgX0JpdC5wcm90b3R5cGUuX2RyYXcuY2FsbCh0aGlzKTtcblx0ICB9O1xuXHQgIC8qXG5cdCAgICBNZXRob2QgZm9yIGluaXRpYWwgcmVuZGVyIG9mIHRoZSBzaGFwZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gX3JlbmRlcigpIHtcblx0ICAgIGlmICh0aGlzLl9pc1JlbmRlcmVkKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2lzUmVuZGVyZWQgPSB0cnVlO1xuXG5cdCAgICB0aGlzLl9sZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcC5wYXJlbnQuaW5uZXJIVE1MID0gJzxzdmcgaWQ9XCJqcy1tb2pzLXNoYXBlLWNhbnZhc1wiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIj48ZyBpZD1cImpzLW1vanMtc2hhcGUtZWxcIj4nICsgdGhpcy5nZXRTaGFwZSgpICsgJzwvZz48L3N2Zz4nO1xuXG5cdCAgICB0aGlzLl9jYW52YXMgPSBwLnBhcmVudC5xdWVyeVNlbGVjdG9yKCcjanMtbW9qcy1zaGFwZS1jYW52YXMnKTtcblx0ICAgIHRoaXMuZWwgPSBwLnBhcmVudC5xdWVyeVNlbGVjdG9yKCcjanMtbW9qcy1zaGFwZS1lbCcpO1xuXHQgICAgdGhpcy5fc2V0Q2FudmFzU2l6ZSgpO1xuXHQgIH07XG5cdCAgLypcblx0ICAgIE1ldGhvZCB0byBnZXQgc2NhbGVzIGZvciB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG11dGF0ZXMgQHByb3BzXG5cdCAgKi9cblxuXG5cdCAgQ3VzdG9tLnByb3RvdHlwZS5fZ2V0U2NhbGUgPSBmdW5jdGlvbiBfZ2V0U2NhbGUoKSB7XG5cdCAgICB2YXIgcCA9IHRoaXMuX3Byb3BzLFxuXHQgICAgICAgIHJhZGl1c1ggPSBwLnJhZGl1c1ggPyBwLnJhZGl1c1ggOiBwLnJhZGl1cyxcblx0ICAgICAgICByYWRpdXNZID0gcC5yYWRpdXNZID8gcC5yYWRpdXNZIDogcC5yYWRpdXM7XG5cblx0ICAgIHAuc2NhbGVYID0gMiAqIHJhZGl1c1ggLyAxMDA7XG5cdCAgICBwLnNjYWxlWSA9IDIgKiByYWRpdXNZIC8gMTAwO1xuXHQgICAgcC5tYXhTY2FsZSA9IE1hdGgubWF4KHAuc2NhbGVYLCBwLnNjYWxlWSk7XG5cblx0ICAgIHAuc2hpZnRYID0gcC53aWR0aCAvIDIgLSA1MCAqIHAuc2NhbGVYO1xuXHQgICAgcC5zaGlmdFkgPSBwLmhlaWdodCAvIDIgLSA1MCAqIHAuc2NhbGVZO1xuXG5cdCAgICB2YXIgdHJhbnNsYXRlID0gJ3RyYW5zbGF0ZSgnICsgcC5zaGlmdFggKyAnLCAnICsgcC5zaGlmdFkgKyAnKSc7XG5cdCAgICByZXR1cm4gdHJhbnNsYXRlICsgJyBzY2FsZSgnICsgcC5zY2FsZVggKyAnLCAnICsgcC5zY2FsZVkgKyAnKSc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGxlbmd0aCBvZiB0aGUgc2hhcGUuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQHJldHVybnMge051bWJlcn0gTGVuZ3RoIG9mIHRoZSBzaGFwZS5cblx0ICAqL1xuXG5cblx0ICBDdXN0b20ucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbiBfZ2V0TGVuZ3RoKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEN1c3RvbTtcblx0fShfYml0Mi5kZWZhdWx0KTtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBDdXN0b207XG5cbi8qKiovIH0sXG4vKiAzNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIENpcmNsZSxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuXHRDaXJjbGUgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChDaXJjbGUsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuXHQgICAgcmV0dXJuIENpcmNsZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIENpcmNsZS5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnNoYXBlID0gJ2VsbGlwc2UnO1xuXHQgIH07XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcngsIHJ5O1xuXHQgICAgcnggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcnkgPSB0aGlzLl9wcm9wcy5yYWRpdXNZICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNZIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgncngnLCByeCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCdyeScsIHJ5KTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ2N4JywgdGhpcy5fcHJvcHMud2lkdGggLyAyKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ2N5JywgdGhpcy5fcHJvcHMuaGVpZ2h0IC8gMik7XG5cdCAgICByZXR1cm4gQ2lyY2xlLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH07XG5cblx0ICBDaXJjbGUucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciByYWRpdXNYLCByYWRpdXNZO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIHJldHVybiAyICogTWF0aC5QSSAqIE1hdGguc3FydCgocmFkaXVzWCAqIHJhZGl1c1ggKyByYWRpdXNZICogcmFkaXVzWSkgLyAyKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIENpcmNsZTtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG5cbi8qKiovIH0sXG4vKiAzOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIExpbmUsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cblx0TGluZSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKExpbmUsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gTGluZSgpIHtcblx0ICAgIHJldHVybiBMaW5lLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIExpbmUucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIExpbmUuX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy50YWcgPSAnbGluZSc7XG5cdCAgfTtcblxuXHQgIExpbmUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmFkaXVzWCwgeCwgeTtcblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgeCA9IHRoaXMuX3Byb3BzLndpZHRoIC8gMjtcblx0ICAgIHkgPSB0aGlzLl9wcm9wcy5oZWlnaHQgLyAyO1xuXHQgICAgdGhpcy5fc2V0QXR0cklmQ2hhbmdlZCgneDEnLCB4IC0gcmFkaXVzWCk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd4MicsIHggKyByYWRpdXNYKTtcblx0ICAgIHRoaXMuX3NldEF0dHJJZkNoYW5nZWQoJ3kxJywgeSk7XG5cdCAgICB0aGlzLl9zZXRBdHRySWZDaGFuZ2VkKCd5MicsIHkpO1xuXHQgICAgcmV0dXJuIExpbmUuX19zdXBlcl9fLl9kcmF3LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBMaW5lO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG5cbi8qKiovIH0sXG4vKiAzOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFppZ3phZyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuXHRaaWd6YWcgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChaaWd6YWcsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gWmlnemFnKCkge1xuXHQgICAgcmV0dXJuIFppZ3phZy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBaaWd6YWcucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFppZ3phZy5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgdGhpcy5fZGVmYXVsdHMudGFnID0gJ3BhdGgnO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnBvaW50cyA9IDM7XG5cdCAgfTtcblxuXHQgIFppZ3phZy5wcm90b3R5cGUuX2RyYXcgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBjdXJyZW50WCwgY3VycmVudFksIGRlbHRhLCBpLCBpc1BvaW50cywgaXNSYWRpdXNYLCBpc1JhZGl1c1ksIGosIGxlbmd0aCwgcCwgcG9pbnRzLCByYWRpdXNYLCByYWRpdXNZLCByZWYsIHN0ZXBYLCB4LCB5LCB5RmxpcDtcblx0ICAgIFppZ3phZy5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIGlmICghdGhpcy5fcHJvcHMucG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICBpc1JhZGl1c1ggPSByYWRpdXNYID09PSB0aGlzLl9wcmV2UmFkaXVzWDtcblx0ICAgIGlzUmFkaXVzWSA9IHJhZGl1c1kgPT09IHRoaXMuX3ByZXZSYWRpdXNZO1xuXHQgICAgaXNQb2ludHMgPSBwLnBvaW50cyA9PT0gdGhpcy5fcHJldlBvaW50cztcblx0ICAgIGlmIChpc1JhZGl1c1ggJiYgaXNSYWRpdXNZICYmIGlzUG9pbnRzKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHggPSBwLndpZHRoIC8gMjtcblx0ICAgIHkgPSBwLmhlaWdodCAvIDI7XG5cdCAgICBjdXJyZW50WCA9IHggLSByYWRpdXNYO1xuXHQgICAgY3VycmVudFkgPSB5O1xuXHQgICAgc3RlcFggPSAoMiAqIHJhZGl1c1gpIC8gKHAucG9pbnRzIC0gMSk7XG5cdCAgICB5RmxpcCA9IC0xO1xuXHQgICAgZGVsdGEgPSBNYXRoLnNxcnQoc3RlcFggKiBzdGVwWCArIHJhZGl1c1kgKiByYWRpdXNZKTtcblx0ICAgIGxlbmd0aCA9IC1kZWx0YTtcblx0ICAgIHBvaW50cyA9IFwiTVwiICsgY3VycmVudFggKyBcIiwgXCIgKyB5ICsgXCIgXCI7XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gcC5wb2ludHM7IDAgPD0gcmVmID8gaiA8IHJlZiA6IGogPiByZWY7IGkgPSAwIDw9IHJlZiA/ICsraiA6IC0taikge1xuXHQgICAgICBwb2ludHMgKz0gXCJMXCIgKyBjdXJyZW50WCArIFwiLCBcIiArIGN1cnJlbnRZICsgXCIgXCI7XG5cdCAgICAgIGN1cnJlbnRYICs9IHN0ZXBYO1xuXHQgICAgICBsZW5ndGggKz0gZGVsdGE7XG5cdCAgICAgIGN1cnJlbnRZID0geUZsaXAgPT09IC0xID8geSAtIHJhZGl1c1kgOiB5O1xuXHQgICAgICB5RmxpcCA9IC15RmxpcDtcblx0ICAgIH1cblx0ICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcblx0ICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgcG9pbnRzKTtcblx0ICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIFppZ3phZy5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIFppZ3phZztcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gWmlnemFnO1xuXG5cbi8qKiovIH0sXG4vKiA0MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIFBvbHlnb24sIGgsXG5cdCAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuXHQgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRCaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KVtcImRlZmF1bHRcIl0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cblx0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG5cdFBvbHlnb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuXHQgIGV4dGVuZChQb2x5Z29uLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG5cdCAgICByZXR1cm4gUG9seWdvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZGVjbGFyZSBkZWZhdWx0cy5cblx0ICAgIEBvdmVycmlkZXMgQCBCaXRcblx0ICAgKi9cblxuXHQgIFBvbHlnb24ucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIFBvbHlnb24uX19zdXBlcl9fLl9kZWNsYXJlRGVmYXVsdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdwYXRoJztcblx0ICAgIHJldHVybiB0aGlzLl9kZWZhdWx0cy5wb2ludHMgPSAzO1xuXHQgIH07XG5cblxuXHQgIC8qXG5cdCAgICBNZXRob2QgdG8gZHJhdyB0aGUgc2hhcGUuXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgICovXG5cblx0ICBQb2x5Z29uLnByb3RvdHlwZS5fZHJhdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGNoYXIsIGQsIGksIGlzUG9pbnRzLCBpc1JhZGl1c1gsIGlzUmFkaXVzWSwgaiwgaywgbGVuLCBwLCBwb2ludCwgcmFkaXVzWCwgcmFkaXVzWSwgcmVmLCByZWYxLCBzdGVwO1xuXHQgICAgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICBpc1BvaW50cyA9IHAucG9pbnRzID09PSB0aGlzLl9wcmV2UG9pbnRzO1xuXHQgICAgaWYgKCEoaXNSYWRpdXNYICYmIGlzUmFkaXVzWSAmJiBpc1BvaW50cykpIHtcblx0ICAgICAgc3RlcCA9IDM2MCAvIHRoaXMuX3Byb3BzLnBvaW50cztcblx0ICAgICAgaWYgKHRoaXMuX3JhZGlhbFBvaW50cyA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzID0gW107XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzLmxlbmd0aCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgZm9yIChpID0gaiA9IDAsIHJlZiA9IHRoaXMuX3Byb3BzLnBvaW50czsgMCA8PSByZWYgPyBqIDwgcmVmIDogaiA+IHJlZjsgaSA9IDAgPD0gcmVmID8gKytqIDogLS1qKSB7XG5cdCAgICAgICAgdGhpcy5fcmFkaWFsUG9pbnRzLnB1c2goaC5nZXRSYWRpYWxQb2ludCh7XG5cdCAgICAgICAgICByYWRpdXM6IHRoaXMuX3Byb3BzLnJhZGl1cyxcblx0ICAgICAgICAgIHJhZGl1c1g6IHRoaXMuX3Byb3BzLnJhZGl1c1gsXG5cdCAgICAgICAgICByYWRpdXNZOiB0aGlzLl9wcm9wcy5yYWRpdXNZLFxuXHQgICAgICAgICAgYW5nbGU6IGkgKiBzdGVwLFxuXHQgICAgICAgICAgY2VudGVyOiB7XG5cdCAgICAgICAgICAgIHg6IHAud2lkdGggLyAyLFxuXHQgICAgICAgICAgICB5OiBwLmhlaWdodCAvIDJcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KSk7XG5cdCAgICAgIH1cblx0ICAgICAgZCA9ICcnO1xuXHQgICAgICByZWYxID0gdGhpcy5fcmFkaWFsUG9pbnRzO1xuXHQgICAgICBmb3IgKGkgPSBrID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGsgPCBsZW47IGkgPSArK2spIHtcblx0ICAgICAgICBwb2ludCA9IHJlZjFbaV07XG5cdCAgICAgICAgY2hhciA9IGkgPT09IDAgPyAnTScgOiAnTCc7XG5cdCAgICAgICAgZCArPSBcIlwiICsgY2hhciArIChwb2ludC54LnRvRml4ZWQoNCkpICsgXCIsXCIgKyAocG9pbnQueS50b0ZpeGVkKDQpKSArIFwiIFwiO1xuXHQgICAgICB9XG5cdCAgICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgICAgdGhpcy5fcHJldlJhZGl1c1ggPSByYWRpdXNYO1xuXHQgICAgICB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgICAgIHRoaXMuZWwuc2V0QXR0cmlidXRlKCdkJywgKGQgKz0gJ3onKSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gUG9seWdvbi5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9O1xuXG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGdldCBsZW5ndGggb2YgdGhlIHNoYXBlLlxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICAqL1xuXG5cdCAgUG9seWdvbi5wcm90b3R5cGUuX2dldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2dldFBvaW50c1BlcmltaXRlcih0aGlzLl9yYWRpYWxQb2ludHMpO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUG9seWdvbjtcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUG9seWdvbjtcblxuXG4vKioqLyB9LFxuLyogNDEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdFxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHR2YXIgQml0LCBDcm9zcyxcblx0ICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG5cdCAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdEJpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpW1wiZGVmYXVsdFwiXSB8fCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxuXHRDcm9zcyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG5cdCAgZXh0ZW5kKENyb3NzLCBzdXBlckNsYXNzKTtcblxuXHQgIGZ1bmN0aW9uIENyb3NzKCkge1xuXHQgICAgcmV0dXJuIENyb3NzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIENyb3NzLnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzID0gZnVuY3Rpb24oKSB7XG5cdCAgICBDcm9zcy5fX3N1cGVyX18uX2RlY2xhcmVEZWZhdWx0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzLnRhZyA9ICdwYXRoJztcblx0ICB9O1xuXG5cdCAgQ3Jvc3MucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZCwgaXNSYWRpdXNYLCBpc1JhZGl1c1ksIGxpbmUxLCBsaW5lMiwgcCwgcmFkaXVzWCwgcmFkaXVzWSwgeCwgeDEsIHgyLCB5LCB5MSwgeTI7XG5cdCAgICBDcm9zcy5fX3N1cGVyX18uX2RyYXcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgIHAgPSB0aGlzLl9wcm9wcztcblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICBpc1JhZGl1c1ggPSByYWRpdXNYID09PSB0aGlzLl9wcmV2UmFkaXVzWDtcblx0ICAgIGlzUmFkaXVzWSA9IHJhZGl1c1kgPT09IHRoaXMuX3ByZXZSYWRpdXNZO1xuXHQgICAgaWYgKGlzUmFkaXVzWCAmJiBpc1JhZGl1c1kpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgeCA9IHRoaXMuX3Byb3BzLndpZHRoIC8gMjtcblx0ICAgIHkgPSB0aGlzLl9wcm9wcy5oZWlnaHQgLyAyO1xuXHQgICAgeDEgPSB4IC0gcmFkaXVzWDtcblx0ICAgIHgyID0geCArIHJhZGl1c1g7XG5cdCAgICBsaW5lMSA9IFwiTVwiICsgeDEgKyBcIixcIiArIHkgKyBcIiBMXCIgKyB4MiArIFwiLFwiICsgeTtcblx0ICAgIHkxID0geSAtIHJhZGl1c1k7XG5cdCAgICB5MiA9IHkgKyByYWRpdXNZO1xuXHQgICAgbGluZTIgPSBcIk1cIiArIHggKyBcIixcIiArIHkxICsgXCIgTFwiICsgeCArIFwiLFwiICsgeTI7XG5cdCAgICBkID0gbGluZTEgKyBcIiBcIiArIGxpbmUyO1xuXHQgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCBkKTtcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIENyb3NzLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgcmFkaXVzWCwgcmFkaXVzWTtcblx0ICAgIHJhZGl1c1ggPSB0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzO1xuXHQgICAgcmFkaXVzWSA9IHRoaXMuX3Byb3BzLnJhZGl1c1kgIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1kgOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByZXR1cm4gMiAqIChyYWRpdXNYICsgcmFkaXVzWSk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBDcm9zcztcblxuXHR9KShCaXQpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gQ3Jvc3M7XG5cblxuLyoqKi8gfSxcbi8qIDQyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5cdHZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxuXHR2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cblx0dmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yKTtcblxuXHR2YXIgX2luaGVyaXRzMiA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5cdHZhciBfaW5oZXJpdHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW5oZXJpdHMyKTtcblxuXHR2YXIgX2JpdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5cdHZhciBfYml0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2JpdCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHR2YXIgQ3VydmUgPSBmdW5jdGlvbiAoX0JpdCkge1xuXHQgICgwLCBfaW5oZXJpdHMzLmRlZmF1bHQpKEN1cnZlLCBfQml0KTtcblxuXHQgIGZ1bmN0aW9uIEN1cnZlKCkge1xuXHQgICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgQ3VydmUpO1xuXHQgICAgcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgX0JpdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRlY2xhcmUgbW9kdWxlJ3MgZGVmYXVsdHMuXG5cdCAgICBAcHJpdmF0ZVxuXHQgICAgQG92ZXJyaWRlcyBAIEJpdFxuXHQgICovXG5cblx0ICBDdXJ2ZS5wcm90b3R5cGUuX2RlY2xhcmVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9kZWNsYXJlRGVmYXVsdHMoKSB7XG5cdCAgICBfQml0LnByb3RvdHlwZS5fZGVjbGFyZURlZmF1bHRzLmNhbGwodGhpcyk7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgfTtcblx0ICAvKlxuXHQgICAgTWV0aG9kIHRvIGRyYXcgdGhlIG1vZHVsZS5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAb3ZlcnJpZGVzIEAgQml0XG5cdCAgKi9cblxuXG5cdCAgQ3VydmUucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24gX2RyYXcoKSB7XG5cdCAgICBfQml0LnByb3RvdHlwZS5fZHJhdy5jYWxsKHRoaXMpO1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblxuXHQgICAgdmFyIHJhZGl1c1ggPSBwLnJhZGl1c1ggIT0gbnVsbCA/IHAucmFkaXVzWCA6IHAucmFkaXVzO1xuXHQgICAgdmFyIHJhZGl1c1kgPSBwLnJhZGl1c1kgIT0gbnVsbCA/IHAucmFkaXVzWSA6IHAucmFkaXVzO1xuXG5cdCAgICB2YXIgaXNSYWRpdXNYID0gcmFkaXVzWCA9PT0gdGhpcy5fcHJldlJhZGl1c1g7XG5cdCAgICB2YXIgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICB2YXIgaXNQb2ludHMgPSBwLnBvaW50cyA9PT0gdGhpcy5fcHJldlBvaW50cztcblx0ICAgIC8vIHNraXAgaWYgbm90aGluZyBjaGFuZ2VkXG5cdCAgICBpZiAoaXNSYWRpdXNYICYmIGlzUmFkaXVzWSAmJiBpc1BvaW50cykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIHZhciB4ID0gcC53aWR0aCAvIDI7XG5cdCAgICB2YXIgeSA9IHAuaGVpZ2h0IC8gMjtcblx0ICAgIHZhciB4MSA9IHggLSByYWRpdXNYO1xuXHQgICAgdmFyIHgyID0geCArIHJhZGl1c1g7XG5cblx0ICAgIHZhciBkID0gJ00nICsgeDEgKyAnICcgKyB5ICsgJyBRICcgKyB4ICsgJyAnICsgKHkgLSAyICogcmFkaXVzWSkgKyAnICcgKyB4MiArICcgJyArIHk7XG5cblx0ICAgIC8vIHNldCB0aGUgYGRgIGF0dHJpYnV0ZSBhbmQgc2F2ZSBpdCB0byBgX3ByZXZEYFxuXHQgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCBkKTtcblx0ICAgIC8vIHNhdmUgdGhlIHByb3BlcnRpZXNcblx0ICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNZID0gcmFkaXVzWTtcblx0ICB9O1xuXG5cdCAgQ3VydmUucHJvdG90eXBlLl9nZXRMZW5ndGggPSBmdW5jdGlvbiBfZ2V0TGVuZ3RoKCkge1xuXHQgICAgdmFyIHAgPSB0aGlzLl9wcm9wcztcblxuXHQgICAgdmFyIHJhZGl1c1ggPSBwLnJhZGl1c1ggIT0gbnVsbCA/IHAucmFkaXVzWCA6IHAucmFkaXVzO1xuXHQgICAgdmFyIHJhZGl1c1kgPSBwLnJhZGl1c1kgIT0gbnVsbCA/IHAucmFkaXVzWSA6IHAucmFkaXVzO1xuXG5cdCAgICB2YXIgZFJhZGl1cyA9IHJhZGl1c1ggKyByYWRpdXNZO1xuXHQgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoKDMgKiByYWRpdXNYICsgcmFkaXVzWSkgKiAocmFkaXVzWCArIDMgKiByYWRpdXNZKSk7XG5cblx0ICAgIHJldHVybiAuNSAqIE1hdGguUEkgKiAoMyAqIGRSYWRpdXMgLSBzcXJ0KTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEN1cnZlO1xuXHR9KF9iaXQyLmRlZmF1bHQpOyAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG5cblx0ZXhwb3J0cy5kZWZhdWx0ID0gQ3VydmU7XG5cbi8qKiovIH0sXG4vKiA0MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBCaXQsIEVxdWFsLFxuXHQgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcblx0ICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0Qml0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNilbXCJkZWZhdWx0XCJdIHx8IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5cdEVxdWFsID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcblx0ICBleHRlbmQoRXF1YWwsIHN1cGVyQ2xhc3MpO1xuXG5cdCAgZnVuY3Rpb24gRXF1YWwoKSB7XG5cdCAgICByZXR1cm4gRXF1YWwuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgRXF1YWwucHJvdG90eXBlLl9kZWNsYXJlRGVmYXVsdHMgPSBmdW5jdGlvbigpIHtcblx0ICAgIEVxdWFsLl9fc3VwZXJfXy5fZGVjbGFyZURlZmF1bHRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICB0aGlzLl9kZWZhdWx0cy50YWcgPSAncGF0aCc7XG5cdCAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHMucG9pbnRzID0gMjtcblx0ICB9O1xuXG5cdCAgRXF1YWwucHJvdG90eXBlLl9kcmF3ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgZCwgaSwgaXNQb2ludHMsIGlzUmFkaXVzWCwgaXNSYWRpdXNZLCBqLCBwLCByYWRpdXNYLCByYWRpdXNZLCByZWYsIHgsIHgxLCB4MiwgeSwgeVN0YXJ0LCB5U3RlcDtcblx0ICAgIEVxdWFsLl9fc3VwZXJfXy5fZHJhdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgcCA9IHRoaXMuX3Byb3BzO1xuXHQgICAgaWYgKCF0aGlzLl9wcm9wcy5wb2ludHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgcmFkaXVzWCA9IHRoaXMuX3Byb3BzLnJhZGl1c1ggIT0gbnVsbCA/IHRoaXMuX3Byb3BzLnJhZGl1c1ggOiB0aGlzLl9wcm9wcy5yYWRpdXM7XG5cdCAgICByYWRpdXNZID0gdGhpcy5fcHJvcHMucmFkaXVzWSAhPSBudWxsID8gdGhpcy5fcHJvcHMucmFkaXVzWSA6IHRoaXMuX3Byb3BzLnJhZGl1cztcblx0ICAgIGlzUmFkaXVzWCA9IHJhZGl1c1ggPT09IHRoaXMuX3ByZXZSYWRpdXNYO1xuXHQgICAgaXNSYWRpdXNZID0gcmFkaXVzWSA9PT0gdGhpcy5fcHJldlJhZGl1c1k7XG5cdCAgICBpc1BvaW50cyA9IHAucG9pbnRzID09PSB0aGlzLl9wcmV2UG9pbnRzO1xuXHQgICAgaWYgKGlzUmFkaXVzWCAmJiBpc1JhZGl1c1kgJiYgaXNQb2ludHMpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgeCA9IHRoaXMuX3Byb3BzLndpZHRoIC8gMjtcblx0ICAgIHkgPSB0aGlzLl9wcm9wcy5oZWlnaHQgLyAyO1xuXHQgICAgeDEgPSB4IC0gcmFkaXVzWDtcblx0ICAgIHgyID0geCArIHJhZGl1c1g7XG5cdCAgICBkID0gJyc7XG5cdCAgICB5U3RlcCA9IDIgKiByYWRpdXNZIC8gKHRoaXMuX3Byb3BzLnBvaW50cyAtIDEpO1xuXHQgICAgeVN0YXJ0ID0geSAtIHJhZGl1c1k7XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fcHJvcHMucG9pbnRzOyAwIDw9IHJlZiA/IGogPCByZWYgOiBqID4gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgeSA9IFwiXCIgKyAoaSAqIHlTdGVwICsgeVN0YXJ0KTtcblx0ICAgICAgZCArPSBcIk1cIiArIHgxICsgXCIsIFwiICsgeSArIFwiIExcIiArIHgyICsgXCIsIFwiICsgeSArIFwiIFwiO1xuXHQgICAgfVxuXHQgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2QnLCBkKTtcblx0ICAgIHRoaXMuX3ByZXZQb2ludHMgPSBwLnBvaW50cztcblx0ICAgIHRoaXMuX3ByZXZSYWRpdXNYID0gcmFkaXVzWDtcblx0ICAgIHJldHVybiB0aGlzLl9wcmV2UmFkaXVzWSA9IHJhZGl1c1k7XG5cdCAgfTtcblxuXHQgIEVxdWFsLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gMiAqICh0aGlzLl9wcm9wcy5yYWRpdXNYICE9IG51bGwgPyB0aGlzLl9wcm9wcy5yYWRpdXNYIDogdGhpcy5fcHJvcHMucmFkaXVzKTtcblx0ICB9O1xuXG5cdCAgcmV0dXJuIEVxdWFsO1xuXG5cdH0pKEJpdCk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBFcXVhbDtcblxuXG4vKioqLyB9LFxuLyogNDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgQmV6aWVyRWFzaW5nLCBiZXppZXJFYXNpbmcsIGgsXG5cdCAgaW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9O1xuXG5cdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXG5cdC8qKlxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTQgR2HDq3RhbiBSZW5hdWRlYXUgaHR0cDovL2dvby5nbC9FbDNrN3Vcblx0ICogQWRvcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZ1xuXHQgKi9cblxuXHRCZXppZXJFYXNpbmcgPSAoZnVuY3Rpb24oKSB7XG5cdCAgZnVuY3Rpb24gQmV6aWVyRWFzaW5nKG8pIHtcblx0ICAgIHRoaXMudmFycygpO1xuXHQgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGU7XG5cdCAgfVxuXG5cdCAgQmV6aWVyRWFzaW5nLnByb3RvdHlwZS52YXJzID0gZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZSA9IGguYmluZCh0aGlzLmdlbmVyYXRlLCB0aGlzKTtcblx0ICB9O1xuXG5cdCAgQmV6aWVyRWFzaW5nLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuXHQgICAgdmFyIEEsIEIsIEMsIE5FV1RPTl9JVEVSQVRJT05TLCBORVdUT05fTUlOX1NMT1BFLCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUywgU1VCRElWSVNJT05fUFJFQ0lTSU9OLCBfcHJlY29tcHV0ZWQsIGFyZywgYmluYXJ5U3ViZGl2aWRlLCBjYWxjQmV6aWVyLCBjYWxjU2FtcGxlVmFsdWVzLCBmLCBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQsIGdldFNsb3BlLCBnZXRURm9yWCwgaSwgaiwga1NhbXBsZVN0ZXBTaXplLCBrU3BsaW5lVGFibGVTaXplLCBtU2FtcGxlVmFsdWVzLCBuZXd0b25SYXBoc29uSXRlcmF0ZSwgcHJlY29tcHV0ZSwgc3RyO1xuXHQgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmVycm9yKCdCZXppZXIgZnVuY3Rpb24gZXhwZWN0cyA0IGFyZ3VtZW50cycpO1xuXHQgICAgfVxuXHQgICAgZm9yIChpID0gaiA9IDA7IGogPCA0OyBpID0gKytqKSB7XG5cdCAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcblx0ICAgICAgaWYgKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJnKSB8fCAhaXNGaW5pdGUoYXJnKSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdCZXppZXIgZnVuY3Rpb24gZXhwZWN0cyA0IGFyZ3VtZW50cycpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAobVgxIDwgMCB8fCBtWDEgPiAxIHx8IG1YMiA8IDAgfHwgbVgyID4gMSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5lcnJvcignQmV6aWVyIHggdmFsdWVzIHNob3VsZCBiZSA+IDAgYW5kIDwgMScpO1xuXHQgICAgfVxuXHQgICAgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xuXHQgICAgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xuXHQgICAgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuXHQgICAgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcblx0ICAgIGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcblx0ICAgIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblx0ICAgIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IGluZGV4T2YuY2FsbChnbG9iYWwsICdGbG9hdDMyQXJyYXknKSA+PSAwO1xuXHQgICAgQSA9IGZ1bmN0aW9uKGFBMSwgYUEyKSB7XG5cdCAgICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG5cdCAgICB9O1xuXHQgICAgQiA9IGZ1bmN0aW9uKGFBMSwgYUEyKSB7XG5cdCAgICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG5cdCAgICB9O1xuXHQgICAgQyA9IGZ1bmN0aW9uKGFBMSkge1xuXHQgICAgICByZXR1cm4gMy4wICogYUExO1xuXHQgICAgfTtcblx0ICAgIGNhbGNCZXppZXIgPSBmdW5jdGlvbihhVCwgYUExLCBhQTIpIHtcblx0ICAgICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuXHQgICAgfTtcblx0ICAgIGdldFNsb3BlID0gZnVuY3Rpb24oYVQsIGFBMSwgYUEyKSB7XG5cdCAgICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuXHQgICAgfTtcblx0ICAgIG5ld3RvblJhcGhzb25JdGVyYXRlID0gZnVuY3Rpb24oYVgsIGFHdWVzc1QpIHtcblx0ICAgICAgdmFyIGN1cnJlbnRTbG9wZSwgY3VycmVudFg7XG5cdCAgICAgIGkgPSAwO1xuXHQgICAgICB3aGlsZSAoaSA8IE5FV1RPTl9JVEVSQVRJT05TKSB7XG5cdCAgICAgICAgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG5cdCAgICAgICAgICByZXR1cm4gYUd1ZXNzVDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuXHQgICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG5cdCAgICAgICAgKytpO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhR3Vlc3NUO1xuXHQgICAgfTtcblx0ICAgIGNhbGNTYW1wbGVWYWx1ZXMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgaSA9IDA7XG5cdCAgICAgIHdoaWxlIChpIDwga1NwbGluZVRhYmxlU2l6ZSkge1xuXHQgICAgICAgIG1TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcblx0ICAgICAgICArK2k7XG5cdCAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdCAgICBiaW5hcnlTdWJkaXZpZGUgPSBmdW5jdGlvbihhWCwgYUEsIGFCKSB7XG5cdCAgICAgIHZhciBjdXJyZW50VCwgY3VycmVudFgsIGlzQmlnO1xuXHQgICAgICBjdXJyZW50WCA9IHZvaWQgMDtcblx0ICAgICAgY3VycmVudFQgPSB2b2lkIDA7XG5cdCAgICAgIGkgPSAwO1xuXHQgICAgICB3aGlsZSAodHJ1ZSkge1xuXHQgICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG5cdCAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblx0ICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcblx0ICAgICAgICAgIGFCID0gY3VycmVudFQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGFBID0gY3VycmVudFQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlzQmlnID0gTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OO1xuXHQgICAgICAgIGlmICghKGlzQmlnICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBjdXJyZW50VDtcblx0ICAgIH07XG5cdCAgICBnZXRURm9yWCA9IGZ1bmN0aW9uKGFYKSB7XG5cdCAgICAgIHZhciBjdXJyZW50U2FtcGxlLCBkZWx0YSwgZGlzdCwgZ3Vlc3NGb3JULCBpbml0aWFsU2xvcGUsIGludGVydmFsU3RhcnQsIGxhc3RTYW1wbGU7XG5cdCAgICAgIGludGVydmFsU3RhcnQgPSAwLjA7XG5cdCAgICAgIGN1cnJlbnRTYW1wbGUgPSAxO1xuXHQgICAgICBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cdCAgICAgIHdoaWxlIChjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVgpIHtcblx0ICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcblx0ICAgICAgICArK2N1cnJlbnRTYW1wbGU7XG5cdCAgICAgIH1cblx0ICAgICAgLS1jdXJyZW50U2FtcGxlO1xuXHQgICAgICBkZWx0YSA9IG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXTtcblx0ICAgICAgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gZGVsdGE7XG5cdCAgICAgIGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplO1xuXHQgICAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblx0ICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuXHQgICAgICB9IGVsc2Uge1xuXG5cdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcblx0ICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICAgIHByZWNvbXB1dGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIF9wcmVjb21wdXRlZDtcblx0ICAgICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblx0ICAgICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG5cdCAgICAgICAgcmV0dXJuIGNhbGNTYW1wbGVWYWx1ZXMoKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblx0ICAgIG1TYW1wbGVWYWx1ZXMgPSAhZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblx0ICAgIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXHQgICAgZiA9IGZ1bmN0aW9uKGFYKSB7XG5cdCAgICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG5cdCAgICAgICAgcHJlY29tcHV0ZSgpO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuXHQgICAgICAgIHJldHVybiBhWDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoYVggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoYVggPT09IDEpIHtcblx0ICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcblx0ICAgIH07XG5cdCAgICBzdHIgPSBcImJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG5cdCAgICBmLnRvU3RyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiBzdHI7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGY7XG5cdCAgfTtcblxuXHQgIEJlemllckVhc2luZy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihtc2cpIHtcblx0ICAgIHJldHVybiBoLmVycm9yKG1zZyk7XG5cdCAgfTtcblxuXHQgIHJldHVybiBCZXppZXJFYXNpbmc7XG5cblx0fSkoKTtcblxuXHRiZXppZXJFYXNpbmcgPSBuZXcgQmV6aWVyRWFzaW5nO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gYmV6aWVyRWFzaW5nO1xuXG5cdC8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KCkpKSlcblxuLyoqKi8gfSxcbi8qIDQ1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgUGF0aEVhc2luZywgaDtcblxuXHRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblx0UGF0aEVhc2luZyA9IChmdW5jdGlvbigpIHtcblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fdmFycyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdGhpcy5fcHJlY29tcHV0ZSA9IGguY2xhbXAodGhpcy5vLnByZWNvbXB1dGUgfHwgMTQ1MCwgMTAwLCAxMDAwMCk7XG5cdCAgICB0aGlzLl9zdGVwID0gMSAvIHRoaXMuX3ByZWNvbXB1dGU7XG5cdCAgICB0aGlzLl9yZWN0ID0gdGhpcy5vLnJlY3QgfHwgMTAwO1xuXHQgICAgdGhpcy5fYXBwcm94aW1hdGVNYXggPSB0aGlzLm8uYXBwcm94aW1hdGVNYXggfHwgNTtcblx0ICAgIHRoaXMuX2VwcyA9IHRoaXMuby5lcHMgfHwgMC4wMDE7XG5cdCAgICByZXR1cm4gdGhpcy5fYm91bmRzUHJldlByb2dyZXNzID0gLTE7XG5cdCAgfTtcblxuXHQgIGZ1bmN0aW9uIFBhdGhFYXNpbmcocGF0aCwgbzEpIHtcblx0ICAgIHRoaXMubyA9IG8xICE9IG51bGwgPyBvMSA6IHt9O1xuXHQgICAgaWYgKHBhdGggPT09ICdjcmVhdG9yJykge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB0aGlzLnBhdGggPSBoLnBhcnNlUGF0aChwYXRoKTtcblx0ICAgIGlmICh0aGlzLnBhdGggPT0gbnVsbCkge1xuXHQgICAgICByZXR1cm4gaC5lcnJvcignRXJyb3Igd2hpbGUgcGFyc2luZyB0aGUgcGF0aCcpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5fdmFycygpO1xuXHQgICAgdGhpcy5wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMuX25vcm1hbGl6ZVBhdGgodGhpcy5wYXRoLmdldEF0dHJpYnV0ZSgnZCcpKSk7XG5cdCAgICB0aGlzLnBhdGhMZW5ndGggPSB0aGlzLnBhdGguZ2V0VG90YWxMZW5ndGgoKTtcblx0ICAgIHRoaXMuc2FtcGxlID0gaC5iaW5kKHRoaXMuc2FtcGxlLCB0aGlzKTtcblx0ICAgIHRoaXMuX2hhcmRTYW1wbGUgPSBoLmJpbmQodGhpcy5faGFyZFNhbXBsZSwgdGhpcyk7XG5cdCAgICB0aGlzLl9wcmVTYW1wbGUoKTtcblx0ICAgIHRoaXM7XG5cdCAgfVxuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX3ByZVNhbXBsZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGksIGosIGxlbmd0aCwgcG9pbnQsIHByb2dyZXNzLCByZWYsIHJlc3VsdHM7XG5cdCAgICB0aGlzLl9zYW1wbGVzID0gW107XG5cdCAgICByZXN1bHRzID0gW107XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgcmVmID0gdGhpcy5fcHJlY29tcHV0ZTsgMCA8PSByZWYgPyBqIDw9IHJlZiA6IGogPj0gcmVmOyBpID0gMCA8PSByZWYgPyArK2ogOiAtLWopIHtcblx0ICAgICAgcHJvZ3Jlc3MgPSBpICogdGhpcy5fc3RlcDtcblx0ICAgICAgbGVuZ3RoID0gdGhpcy5wYXRoTGVuZ3RoICogcHJvZ3Jlc3M7XG5cdCAgICAgIHBvaW50ID0gdGhpcy5wYXRoLmdldFBvaW50QXRMZW5ndGgobGVuZ3RoKTtcblx0ICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuX3NhbXBsZXNbaV0gPSB7XG5cdCAgICAgICAgcG9pbnQ6IHBvaW50LFxuXHQgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuXHQgICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc1xuXHQgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHRzO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fZmluZEJvdW5kcyA9IGZ1bmN0aW9uKGFycmF5LCBwKSB7XG5cdCAgICB2YXIgYnVmZmVyLCBkaXJlY3Rpb24sIGVuZCwgaSwgaiwgbGVuLCBsb29wRW5kLCBwb2ludFAsIHBvaW50WCwgcmVmLCByZWYxLCBzdGFydCwgdmFsdWU7XG5cdCAgICBpZiAocCA9PT0gdGhpcy5fYm91bmRzUHJldlByb2dyZXNzKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9wcmV2Qm91bmRzO1xuXHQgICAgfVxuXHQgICAgaWYgKHRoaXMuX2JvdW5kc1N0YXJ0SW5kZXggPT0gbnVsbCkge1xuXHQgICAgICB0aGlzLl9ib3VuZHNTdGFydEluZGV4ID0gMDtcblx0ICAgIH1cblx0ICAgIGxlbiA9IGFycmF5Lmxlbmd0aDtcblx0ICAgIGlmICh0aGlzLl9ib3VuZHNQcmV2UHJvZ3Jlc3MgPiBwKSB7XG5cdCAgICAgIGxvb3BFbmQgPSAwO1xuXHQgICAgICBkaXJlY3Rpb24gPSAncmV2ZXJzZSc7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBsb29wRW5kID0gbGVuO1xuXHQgICAgICBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG5cdCAgICB9XG5cdCAgICBpZiAoZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcblx0ICAgICAgc3RhcnQgPSBhcnJheVswXTtcblx0ICAgICAgZW5kID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdGFydCA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuXHQgICAgICBlbmQgPSBhcnJheVswXTtcblx0ICAgIH1cblx0ICAgIGZvciAoaSA9IGogPSByZWYgPSB0aGlzLl9ib3VuZHNTdGFydEluZGV4LCByZWYxID0gbG9vcEVuZDsgcmVmIDw9IHJlZjEgPyBqIDwgcmVmMSA6IGogPiByZWYxOyBpID0gcmVmIDw9IHJlZjEgPyArK2ogOiAtLWopIHtcblx0ICAgICAgdmFsdWUgPSBhcnJheVtpXTtcblx0ICAgICAgcG9pbnRYID0gdmFsdWUucG9pbnQueCAvIHRoaXMuX3JlY3Q7XG5cdCAgICAgIHBvaW50UCA9IHA7XG5cdCAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdyZXZlcnNlJykge1xuXHQgICAgICAgIGJ1ZmZlciA9IHBvaW50WDtcblx0ICAgICAgICBwb2ludFggPSBwb2ludFA7XG5cdCAgICAgICAgcG9pbnRQID0gYnVmZmVyO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChwb2ludFggPCBwb2ludFApIHtcblx0ICAgICAgICBzdGFydCA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMuX2JvdW5kc1N0YXJ0SW5kZXggPSBpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGVuZCA9IHZhbHVlO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICB0aGlzLl9ib3VuZHNQcmV2UHJvZ3Jlc3MgPSBwO1xuXHQgICAgcmV0dXJuIHRoaXMuX3ByZXZCb3VuZHMgPSB7XG5cdCAgICAgIHN0YXJ0OiBzdGFydCxcblx0ICAgICAgZW5kOiBlbmRcblx0ICAgIH07XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLnNhbXBsZSA9IGZ1bmN0aW9uKHApIHtcblx0ICAgIHZhciBib3VuZHMsIHJlcztcblx0ICAgIHAgPSBoLmNsYW1wKHAsIDAsIDEpO1xuXHQgICAgYm91bmRzID0gdGhpcy5fZmluZEJvdW5kcyh0aGlzLl9zYW1wbGVzLCBwKTtcblx0ICAgIHJlcyA9IHRoaXMuX2NoZWNrSWZCb3VuZHNDbG9zZUVub3VnaChwLCBib3VuZHMpO1xuXHQgICAgaWYgKHJlcyAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiByZXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fZmluZEFwcHJveGltYXRlKHAsIGJvdW5kcy5zdGFydCwgYm91bmRzLmVuZCk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9jaGVja0lmQm91bmRzQ2xvc2VFbm91Z2ggPSBmdW5jdGlvbihwLCBib3VuZHMpIHtcblx0ICAgIHZhciBwb2ludCwgeTtcblx0ICAgIHBvaW50ID0gdm9pZCAwO1xuXHQgICAgeSA9IHRoaXMuX2NoZWNrSWZQb2ludENsb3NlRW5vdWdoKHAsIGJvdW5kcy5zdGFydC5wb2ludCk7XG5cdCAgICBpZiAoeSAhPSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB5O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuX2NoZWNrSWZQb2ludENsb3NlRW5vdWdoKHAsIGJvdW5kcy5lbmQucG9pbnQpO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fY2hlY2tJZlBvaW50Q2xvc2VFbm91Z2ggPSBmdW5jdGlvbihwLCBwb2ludCkge1xuXHQgICAgaWYgKGguY2xvc2VFbm91Z2gocCwgcG9pbnQueCAvIHRoaXMuX3JlY3QsIHRoaXMuX2VwcykpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVZKHBvaW50KTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX2FwcHJveGltYXRlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgcCkge1xuXHQgICAgdmFyIGRlbHRhUCwgcGVyY2VudFA7XG5cdCAgICBkZWx0YVAgPSBlbmQucG9pbnQueCAtIHN0YXJ0LnBvaW50Lng7XG5cdCAgICBwZXJjZW50UCA9IChwIC0gKHN0YXJ0LnBvaW50LnggLyB0aGlzLl9yZWN0KSkgLyAoZGVsdGFQIC8gdGhpcy5fcmVjdCk7XG5cdCAgICByZXR1cm4gc3RhcnQubGVuZ3RoICsgcGVyY2VudFAgKiAoZW5kLmxlbmd0aCAtIHN0YXJ0Lmxlbmd0aCk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9maW5kQXBwcm94aW1hdGUgPSBmdW5jdGlvbihwLCBzdGFydCwgZW5kLCBhcHByb3hpbWF0ZU1heCkge1xuXHQgICAgdmFyIGFwcHJveGltYXRpb24sIGFyZ3MsIG5ld1BvaW50LCBwb2ludCwgeDtcblx0ICAgIGlmIChhcHByb3hpbWF0ZU1heCA9PSBudWxsKSB7XG5cdCAgICAgIGFwcHJveGltYXRlTWF4ID0gdGhpcy5fYXBwcm94aW1hdGVNYXg7XG5cdCAgICB9XG5cdCAgICBhcHByb3hpbWF0aW9uID0gdGhpcy5fYXBwcm94aW1hdGUoc3RhcnQsIGVuZCwgcCk7XG5cdCAgICBwb2ludCA9IHRoaXMucGF0aC5nZXRQb2ludEF0TGVuZ3RoKGFwcHJveGltYXRpb24pO1xuXHQgICAgeCA9IHBvaW50LnggLyB0aGlzLl9yZWN0O1xuXHQgICAgaWYgKGguY2xvc2VFbm91Z2gocCwgeCwgdGhpcy5fZXBzKSkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVkocG9pbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKC0tYXBwcm94aW1hdGVNYXggPCAxKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVZKHBvaW50KTtcblx0ICAgICAgfVxuXHQgICAgICBuZXdQb2ludCA9IHtcblx0ICAgICAgICBwb2ludDogcG9pbnQsXG5cdCAgICAgICAgbGVuZ3RoOiBhcHByb3hpbWF0aW9uXG5cdCAgICAgIH07XG5cdCAgICAgIGFyZ3MgPSBwIDwgeCA/IFtwLCBzdGFydCwgbmV3UG9pbnQsIGFwcHJveGltYXRlTWF4XSA6IFtwLCBuZXdQb2ludCwgZW5kLCBhcHByb3hpbWF0ZU1heF07XG5cdCAgICAgIHJldHVybiB0aGlzLl9maW5kQXBwcm94aW1hdGUuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9yZXNvbHZlWSA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cdCAgICByZXR1cm4gMSAtIChwb2ludC55IC8gdGhpcy5fcmVjdCk7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9ub3JtYWxpemVQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuXHQgICAgdmFyIGNvbW1hbmRzLCBlbmRJbmRleCwgbm9ybWFsaXplZFBhdGgsIHBvaW50cywgc3RhcnRJbmRleCwgc3ZnQ29tbWFuZHNSZWdleHA7XG5cdCAgICBzdmdDb21tYW5kc1JlZ2V4cCA9IC9bTXxMfEh8VnxDfFN8UXxUfEFdL2dpbTtcblx0ICAgIHBvaW50cyA9IHBhdGguc3BsaXQoc3ZnQ29tbWFuZHNSZWdleHApO1xuXHQgICAgcG9pbnRzLnNoaWZ0KCk7XG5cdCAgICBjb21tYW5kcyA9IHBhdGgubWF0Y2goc3ZnQ29tbWFuZHNSZWdleHApO1xuXHQgICAgc3RhcnRJbmRleCA9IDA7XG5cdCAgICBwb2ludHNbc3RhcnRJbmRleF0gPSB0aGlzLl9ub3JtYWxpemVTZWdtZW50KHBvaW50c1tzdGFydEluZGV4XSk7XG5cdCAgICBlbmRJbmRleCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXHQgICAgcG9pbnRzW2VuZEluZGV4XSA9IHRoaXMuX25vcm1hbGl6ZVNlZ21lbnQocG9pbnRzW2VuZEluZGV4XSwgdGhpcy5fcmVjdCB8fCAxMDApO1xuXHQgICAgcmV0dXJuIG5vcm1hbGl6ZWRQYXRoID0gdGhpcy5fam9pbk5vcm1hbGl6ZWRQYXRoKGNvbW1hbmRzLCBwb2ludHMpO1xuXHQgIH07XG5cblx0ICBQYXRoRWFzaW5nLnByb3RvdHlwZS5fam9pbk5vcm1hbGl6ZWRQYXRoID0gZnVuY3Rpb24oY29tbWFuZHMsIHBvaW50cykge1xuXHQgICAgdmFyIGNvbW1hbmQsIGksIGosIGxlbjEsIG5vcm1hbGl6ZWRQYXRoLCBzcGFjZTtcblx0ICAgIG5vcm1hbGl6ZWRQYXRoID0gJyc7XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IGNvbW1hbmRzLmxlbmd0aDsgaiA8IGxlbjE7IGkgPSArK2opIHtcblx0ICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2ldO1xuXHQgICAgICBzcGFjZSA9IGkgPT09IDAgPyAnJyA6ICcgJztcblx0ICAgICAgbm9ybWFsaXplZFBhdGggKz0gXCJcIiArIHNwYWNlICsgY29tbWFuZCArIChwb2ludHNbaV0udHJpbSgpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBub3JtYWxpemVkUGF0aDtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuX25vcm1hbGl6ZVNlZ21lbnQgPSBmdW5jdGlvbihzZWdtZW50LCB2YWx1ZSkge1xuXHQgICAgdmFyIGksIGosIGxhc3RQb2ludCwgbGVuMSwgblJneCwgcGFpcnMsIHBhcnNlZFgsIHBvaW50LCBzcGFjZSwgeDtcblx0ICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgIHZhbHVlID0gMDtcblx0ICAgIH1cblx0ICAgIHNlZ21lbnQgPSBzZWdtZW50LnRyaW0oKTtcblx0ICAgIG5SZ3ggPSAvKC18XFwrKT8oKFxcZCsoXFwuKFxcZHxcXGUoLXxcXCspPykrKT8pfChcXC4/KFxcZHxcXGV8KFxcLXxcXCspKSspKS9naW07XG5cdCAgICBwYWlycyA9IHRoaXMuX2dldFNlZ21lbnRQYWlycyhzZWdtZW50Lm1hdGNoKG5SZ3gpKTtcblx0ICAgIGxhc3RQb2ludCA9IHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdO1xuXHQgICAgeCA9IGxhc3RQb2ludFswXTtcblx0ICAgIHBhcnNlZFggPSBOdW1iZXIoeCk7XG5cdCAgICBpZiAocGFyc2VkWCAhPT0gdmFsdWUpIHtcblx0ICAgICAgc2VnbWVudCA9ICcnO1xuXHQgICAgICBsYXN0UG9pbnRbMF0gPSB2YWx1ZTtcblx0ICAgICAgZm9yIChpID0gaiA9IDAsIGxlbjEgPSBwYWlycy5sZW5ndGg7IGogPCBsZW4xOyBpID0gKytqKSB7XG5cdCAgICAgICAgcG9pbnQgPSBwYWlyc1tpXTtcblx0ICAgICAgICBzcGFjZSA9IGkgPT09IDAgPyAnJyA6ICcgJztcblx0ICAgICAgICBzZWdtZW50ICs9IFwiXCIgKyBzcGFjZSArIHBvaW50WzBdICsgXCIsXCIgKyBwb2ludFsxXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHNlZ21lbnQ7XG5cdCAgfTtcblxuXHQgIFBhdGhFYXNpbmcucHJvdG90eXBlLl9nZXRTZWdtZW50UGFpcnMgPSBmdW5jdGlvbihhcnJheSkge1xuXHQgICAgdmFyIGksIGosIGxlbjEsIG5ld0FycmF5LCBwYWlyLCB2YWx1ZTtcblx0ICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSB7XG5cdCAgICAgIGguZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSB0aGUgcGF0aCAtIHNlZ21lbnQgcGFpcnMgYXJlIG5vdCBldmVuLicsIGFycmF5KTtcblx0ICAgIH1cblx0ICAgIG5ld0FycmF5ID0gW107XG5cdCAgICBmb3IgKGkgPSBqID0gMCwgbGVuMSA9IGFycmF5Lmxlbmd0aDsgaiA8IGxlbjE7IGkgPSBqICs9IDIpIHtcblx0ICAgICAgdmFsdWUgPSBhcnJheVtpXTtcblx0ICAgICAgcGFpciA9IFthcnJheVtpXSwgYXJyYXlbaSArIDFdXTtcblx0ICAgICAgbmV3QXJyYXkucHVzaChwYWlyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXdBcnJheTtcblx0ICB9O1xuXG5cdCAgUGF0aEVhc2luZy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24ocGF0aCwgbykge1xuXHQgICAgdmFyIGhhbmRsZXI7XG5cdCAgICBoYW5kbGVyID0gbmV3IFBhdGhFYXNpbmcocGF0aCwgbyk7XG5cdCAgICBoYW5kbGVyLnNhbXBsZS5wYXRoID0gaGFuZGxlci5wYXRoO1xuXHQgICAgcmV0dXJuIGhhbmRsZXIuc2FtcGxlO1xuXHQgIH07XG5cblx0ICByZXR1cm4gUGF0aEVhc2luZztcblxuXHR9KSgpO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gUGF0aEVhc2luZztcblxuXG4vKioqLyB9LFxuLyogNDYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBjcmVhdGUsIGVhc2luZywgZ2V0TmVhcmVzdCwgbWl4LCBwYXJzZUlmRWFzaW5nLCBzb3J0LFxuXHQgIHNsaWNlID0gW10uc2xpY2U7XG5cblx0ZWFzaW5nID0gbnVsbDtcblxuXHRwYXJzZUlmRWFzaW5nID0gZnVuY3Rpb24oaXRlbSkge1xuXHQgIGlmICh0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiBpdGVtLnZhbHVlO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXR1cm4gZWFzaW5nLnBhcnNlRWFzaW5nKGl0ZW0udmFsdWUpO1xuXHQgIH1cblx0fTtcblxuXHRzb3J0ID0gZnVuY3Rpb24oYSwgYikge1xuXHQgIHZhciByZXR1cm5WYWx1ZTtcblx0ICBhLnZhbHVlID0gcGFyc2VJZkVhc2luZyhhKTtcblx0ICBiLnZhbHVlID0gcGFyc2VJZkVhc2luZyhiKTtcblx0ICByZXR1cm5WYWx1ZSA9IDA7XG5cdCAgYS50byA8IGIudG8gJiYgKHJldHVyblZhbHVlID0gLTEpO1xuXHQgIGEudG8gPiBiLnRvICYmIChyZXR1cm5WYWx1ZSA9IDEpO1xuXHQgIHJldHVybiByZXR1cm5WYWx1ZTtcblx0fTtcblxuXHRnZXROZWFyZXN0ID0gZnVuY3Rpb24oYXJyYXksIHByb2dyZXNzKSB7XG5cdCAgdmFyIGksIGluZGV4LCBqLCBsZW4sIHZhbHVlO1xuXHQgIGluZGV4ID0gMDtcblx0ICBmb3IgKGkgPSBqID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBqIDwgbGVuOyBpID0gKytqKSB7XG5cdCAgICB2YWx1ZSA9IGFycmF5W2ldO1xuXHQgICAgaW5kZXggPSBpO1xuXHQgICAgaWYgKHZhbHVlLnRvID4gcHJvZ3Jlc3MpIHtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiBpbmRleDtcblx0fTtcblxuXHRtaXggPSBmdW5jdGlvbigpIHtcblx0ICB2YXIgYXJncztcblx0ICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG5cdCAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuXHQgICAgYXJncyA9IGFyZ3Muc29ydChzb3J0KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgYXJnc1swXS52YWx1ZSA9IHBhcnNlSWZFYXNpbmcoYXJnc1swXSk7XG5cdCAgfVxuXHQgIHJldHVybiBmdW5jdGlvbihwcm9ncmVzcykge1xuXHQgICAgdmFyIGluZGV4LCB2YWx1ZTtcblx0ICAgIGluZGV4ID0gZ2V0TmVhcmVzdChhcmdzLCBwcm9ncmVzcyk7XG5cdCAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgIHZhbHVlID0gYXJnc1tpbmRleF0udmFsdWU7XG5cdCAgICAgIGlmIChpbmRleCA9PT0gYXJncy5sZW5ndGggLSAxICYmIHByb2dyZXNzID4gYXJnc1tpbmRleF0udG8pIHtcblx0ICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlKHByb2dyZXNzKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXHR9O1xuXG5cdGNyZWF0ZSA9IGZ1bmN0aW9uKGUpIHtcblx0ICBlYXNpbmcgPSBlO1xuXHQgIHJldHVybiBtaXg7XG5cdH07XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cblxuLyoqKi8gfSxcbi8qIDQ3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cblx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuXHR2YXIgX3R5cGVvZjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxuXHR2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuXHR2YXIgX2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxuXHR2YXIgX2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaCk7XG5cblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuXHQvKlxuXHQgIE1ldGhvZCB0byBib290c3RyYXAgYXBwcm94aW1hdGlvbiBmdW5jdGlvbi5cblx0ICBAcHJpdmF0ZVxuXHQgIEBwYXJhbSAgIHtPYmplY3R9IFNhbXBsZXMgT2JqZWN0LlxuXHQgIEByZXR1cm5zIHtGdW5jdGlvbn0gQXBwcm94aW1hdGUgZnVuY3Rpb24uXG5cdCovXG5cdHZhciBfcHJveGltYXRlID0gZnVuY3Rpb24gX3Byb3hpbWF0ZShzYW1wbGVzKSB7XG5cdCAgdmFyIG4gPSBzYW1wbGVzLmJhc2UsXG5cdCAgICAgIHNhbXBsZXNBbW91bnQgPSBNYXRoLnBvdygxMCwgbiksXG5cdCAgICAgIHNhbXBsZXNTdGVwID0gMSAvIHNhbXBsZXNBbW91bnQ7XG5cblx0ICBmdW5jdGlvbiBSb3VuZE51bWJlcihpbnB1dCwgbnVtYmVyRGVjaW1hbHMpIHtcblx0ICAgIG51bWJlckRlY2ltYWxzID0gK251bWJlckRlY2ltYWxzIHx8IDA7IC8vICt2YXIgbWFnaWMhXG5cblx0ICAgIHZhciBtdWx0aXBseWVyID0gTWF0aC5wb3coMTAuMCwgbnVtYmVyRGVjaW1hbHMpO1xuXG5cdCAgICByZXR1cm4gTWF0aC5yb3VuZChpbnB1dCAqIG11bHRpcGx5ZXIpIC8gbXVsdGlwbHllcjtcblx0ICB9XG5cblx0ICB2YXIgY2FjaGVkID0gZnVuY3Rpb24gY2FjaGVkKHApIHtcblx0ICAgIHZhciBuZXdLZXkgPSBSb3VuZE51bWJlcihwLCBuKSxcblx0ICAgICAgICBzYW1wbGUgPSBzYW1wbGVzW25ld0tleS50b1N0cmluZygpXTtcblxuXHQgICAgaWYgKE1hdGguYWJzKHAgLSBuZXdLZXkpIDwgc2FtcGxlc1N0ZXApIHtcblx0ICAgICAgcmV0dXJuIHNhbXBsZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHAgPiBuZXdLZXkpIHtcblx0ICAgICAgdmFyIG5leHRJbmRleCA9IG5ld0tleSArIHNhbXBsZXNTdGVwO1xuXHQgICAgICB2YXIgbmV4dFZhbHVlID0gc2FtcGxlc1tuZXh0SW5kZXhdO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIG5leHRJbmRleCA9IG5ld0tleSAtIHNhbXBsZXNTdGVwO1xuXHQgICAgICB2YXIgbmV4dFZhbHVlID0gc2FtcGxlc1tuZXh0SW5kZXhdO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgZExlbmd0aCA9IG5leHRJbmRleCAtIG5ld0tleTtcblx0ICAgIHZhciBkVmFsdWUgPSBuZXh0VmFsdWUgLSBzYW1wbGU7XG5cdCAgICBpZiAoZFZhbHVlIDwgc2FtcGxlc1N0ZXApIHtcblx0ICAgICAgcmV0dXJuIHNhbXBsZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHByb2dyZXNzU2NhbGUgPSAocCAtIG5ld0tleSkgLyBkTGVuZ3RoO1xuXHQgICAgdmFyIGNvZWYgPSBuZXh0VmFsdWUgPiBzYW1wbGUgPyAtMSA6IDE7XG5cdCAgICB2YXIgc2NhbGVkRGlmZmVyZW5jZSA9IGNvZWYgKiBwcm9ncmVzc1NjYWxlICogZFZhbHVlO1xuXG5cdCAgICByZXR1cm4gc2FtcGxlICsgc2NhbGVkRGlmZmVyZW5jZTtcblx0ICB9O1xuXG5cdCAgY2FjaGVkLmdldFNhbXBsZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gc2FtcGxlcztcblx0ICB9O1xuXG5cdCAgcmV0dXJuIGNhY2hlZDtcblx0fTtcblx0Lypcblx0ICAgIE1ldGhvZCB0byB0YWtlIHNhbXBsZXMgb2YgdGhlIGZ1bmN0aW9uIGFuZCBjYWxsIHRoZSBfcHJveGltYXRlXG5cdCAgICBtZXRob2Qgd2l0aCB0aGUgZHVuY3Rpb24gYW5kIHNhbXBsZXMuIE9yIGlmIHNhbXBsZXMgcGFzc2VkIC0gcGlwZVxuXHQgICAgdGhlbSB0byB0aGUgX3Byb3hpbWF0ZSBtZXRob2Qgd2l0aG91dCBzYW1wbGluZy5cblx0ICAgIEBwcml2YXRlXG5cdCAgICBAcGFyYW0ge0Z1bmN0aW9ufSBGdW5jdGlvbiB0byBzYW1wbGUuXG5cdCAgICBAcGFyYW0ge051bWJlciwgT2JqZWN0LCBTdHJpbmd9IFByZWNpc2lvbiBvciBwcmVjb21wdXRlZCBzYW1wbGVzLlxuXHQgICovXG5cdHZhciBfc2FtcGxlID0gZnVuY3Rpb24gX3NhbXBsZShmbikge1xuXHQgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gNCA6IGFyZ3VtZW50c1sxXTtcblxuXG5cdCAgdmFyIG5UeXBlID0gdHlwZW9mIG4gPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobik7XG5cblx0ICB2YXIgc2FtcGxlcyA9IHt9O1xuXHQgIGlmIChuVHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgIHZhciBwID0gMCxcblx0ICAgICAgICBzYW1wbGVzQ291bnQgPSBNYXRoLnBvdygxMCwgbiksXG5cdCAgICAgICAgc3RlcCA9IDEgLyBzYW1wbGVzQ291bnQ7XG5cblx0ICAgIHNhbXBsZXNbMF0gPSBmbigwKTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlc0NvdW50IC0gMTsgaSsrKSB7XG5cdCAgICAgIHAgKz0gc3RlcDtcblxuXHQgICAgICB2YXIgaW5kZXggPSBwYXJzZUZsb2F0KHAudG9GaXhlZChuKSk7XG5cdCAgICAgIHNhbXBsZXNbaW5kZXhdID0gZm4ocCk7XG5cdCAgICB9XG5cdCAgICBzYW1wbGVzWzFdID0gZm4oMSk7XG5cblx0ICAgIHNhbXBsZXMuYmFzZSA9IG47XG5cdCAgfSBlbHNlIGlmIChuVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIHNhbXBsZXMgPSBuO1xuXHQgIH0gZWxzZSBpZiAoblR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBzYW1wbGVzID0gSlNPTi5wYXJzZShuKTtcblx0ICB9XG5cblx0ICByZXR1cm4gQXBwcm94aW1hdGUuX3NhbXBsZS5fcHJveGltYXRlKHNhbXBsZXMpO1xuXHR9O1xuXG5cdHZhciBBcHByb3hpbWF0ZSA9IHsgX3NhbXBsZTogX3NhbXBsZSwgX3Byb3hpbWF0ZTogX3Byb3hpbWF0ZSB9O1xuXHRBcHByb3hpbWF0ZS5fc2FtcGxlLl9wcm94aW1hdGUgPSBBcHByb3hpbWF0ZS5fcHJveGltYXRlO1xuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IEFwcHJveGltYXRlLl9zYW1wbGU7XG5cbi8qKiovIH0sXG4vKiA0OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG4vKioqLyB9LFxuLyogNDkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogX193ZWJwYWNrX3JlcXVpcmVfXyg1NiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuLyoqKi8gfSxcbi8qIDUwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IF9fd2VicGFja19yZXF1aXJlX18oNTcpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cbi8qKiovIH0sXG4vKiA1MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG4vKioqLyB9LFxuLyogNTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpLk9iamVjdC5rZXlzO1xuXG4vKioqLyB9LFxuLyogNTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24obW9kdWxlKSB7J3VzZSBzdHJpY3QnO1xuXG5cdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cblx0dmFyIF90eXBlb2YyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cblx0dmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cblx0dmFyIF9oID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cblx0dmFyIF9oMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2gpO1xuXG5cdHZhciBfc2hhcGVzTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cblx0dmFyIF9zaGFwZXNNYXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhcGVzTWFwKTtcblxuXHR2YXIgX3NoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXHR2YXIgX3NoYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYXBlKTtcblxuXHR2YXIgX3NoYXBlU3dpcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cdHZhciBfc2hhcGVTd2lybDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFwZVN3aXJsKTtcblxuXHR2YXIgX2J1cnN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXHR2YXIgX2J1cnN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2J1cnN0KTtcblxuXHR2YXIgX2h0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5cdHZhciBfaHRtbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9odG1sKTtcblxuXHR2YXIgX3N0YWdnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cdHZhciBfc3RhZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdGFnZ2VyKTtcblxuXHR2YXIgX3Nwcml0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG5cdHZhciBfc3ByaXRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zcHJpdGVyKTtcblxuXHR2YXIgX21vdGlvblBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuXHR2YXIgX21vdGlvblBhdGgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbW90aW9uUGF0aCk7XG5cblx0dmFyIF90d2VlbiA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cblx0dmFyIF90d2VlbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90d2Vlbik7XG5cblx0dmFyIF90aW1lbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblx0dmFyIF90aW1lbGluZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW1lbGluZSk7XG5cblx0dmFyIF90d2VlbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cblx0dmFyIF90d2VlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R3ZWVuZXIpO1xuXG5cdHZhciBfdHdlZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cblx0dmFyIF90d2VlbmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHdlZW5hYmxlKTtcblxuXHR2YXIgX3RoZW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cblx0dmFyIF90aGVuYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aGVuYWJsZSk7XG5cblx0dmFyIF90dW5hYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cblx0dmFyIF90dW5hYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R1bmFibGUpO1xuXG5cdHZhciBfZGVsdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuXHR2YXIgX2RlbHRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbHRhKTtcblxuXHR2YXIgX2RlbHRhcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5cdHZhciBfZGVsdGFzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlbHRhcyk7XG5cblx0dmFyIF9tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuXHR2YXIgX21vZHVsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tb2R1bGUpO1xuXG5cdHZhciBfZWFzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cblx0dmFyIF9lYXNpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWFzaW5nKTtcblxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5cdHZhciBtb2pzID0ge1xuXHQgIHJldmlzaW9uOiAnMC4yODguMScsIGlzRGVidWc6IHRydWUsIGhlbHBlcnM6IF9oMi5kZWZhdWx0LFxuXHQgIFNoYXBlOiBfc2hhcGUyLmRlZmF1bHQsIFNoYXBlU3dpcmw6IF9zaGFwZVN3aXJsMi5kZWZhdWx0LCBCdXJzdDogX2J1cnN0Mi5kZWZhdWx0LCBIdG1sOiBfaHRtbDIuZGVmYXVsdCwgc3RhZ2dlcjogX3N0YWdnZXIyLmRlZmF1bHQsIFNwcml0ZXI6IF9zcHJpdGVyMi5kZWZhdWx0LCBNb3Rpb25QYXRoOiBfbW90aW9uUGF0aDIuZGVmYXVsdCxcblx0ICBUd2VlbjogX3R3ZWVuMi5kZWZhdWx0LCBUaW1lbGluZTogX3RpbWVsaW5lMi5kZWZhdWx0LCBUd2VlbmFibGU6IF90d2VlbmFibGUyLmRlZmF1bHQsIFRoZW5hYmxlOiBfdGhlbmFibGUyLmRlZmF1bHQsIFR1bmFibGU6IF90dW5hYmxlMi5kZWZhdWx0LCBNb2R1bGU6IF9tb2R1bGUyLmRlZmF1bHQsXG5cdCAgdHdlZW5lcjogX3R3ZWVuZXIyLmRlZmF1bHQsIGVhc2luZzogX2Vhc2luZzIuZGVmYXVsdCwgc2hhcGVzTWFwOiBfc2hhcGVzTWFwMi5kZWZhdWx0LCBfcG9vbDogeyBEZWx0YTogX2RlbHRhMi5kZWZhdWx0LCBEZWx0YXM6IF9kZWx0YXMyLmRlZmF1bHQgfVxuXHR9O1xuXG5cdC8vIGZ1bmN0aW9ucyBhbGlhc1xuXHRtb2pzLmggPSBtb2pzLmhlbHBlcnM7XG5cdG1vanMuZGVsdGEgPSBtb2pzLmguZGVsdGE7XG5cdC8vIGN1c3RvbSBzaGFwZSBhZGQgZnVuY3Rpb24gYW5kIGNsYXNzXG5cdG1vanMuYWRkU2hhcGUgPSBtb2pzLnNoYXBlc01hcC5hZGRTaGFwZTtcblx0bW9qcy5DdXN0b21TaGFwZSA9IG1vanMuc2hhcGVzTWFwLmN1c3RvbTtcblx0Ly8gbW9kdWxlIGFsaWFzXG5cdG1vanMuVHJhbnNpdCA9IG1vanMuU2hhcGU7XG5cdG1vanMuU3dpcmwgPSBtb2pzLlNoYXBlU3dpcmw7XG5cblx0Ly8gVE9ETzpcblx0Lypcblx0ICBIL1YgaW4gcGF0aHNcblxuXHQgIHJhbmQgZm9yIGRpcmVjdGlvblxuXHQgIGJ1cnN0IGNoaWxkcmVuIGFuZ2xlIGFmdGVyIHR1bmVcblx0ICBidXJzdCBwYXRoU2NhbGUgYWZ0ZXIgdHVuZVxuXHQgIHN3aXJsIHRoZW4gaXNzdWVcblx0ICAncmFuZCcgYW5nbGUgZmxpY2sgd2l0aCBgdGhlbmBcblx0ICBub3QgYWJsZSB0byBgcGxheSgpYCBpbiBgb25Db21wbGV0ZWAgY2FsbGJhY2tcblx0ICAtLS1cblx0ICBtb2R1bGUgbmFtZXNcblx0ICBzd2lybHMgaW4gdGhlbiBjaGFpbnMgZm9yIHgveVxuXHQgIHBhcnNlIHJhbmQoc3RhZ2dlcigyMCwgMTApLCAyMCkgdmFsdWVzXG5cdCAgcGVyY2VudGFnZSBmb3IgcmFkaXVzXG5cblx0ICBpc3N1ZTpcblx0ICAgIGNvbnN0IHNoYXBlID0gbmV3IG1vanMuU2hhcGUoe1xuXHQgICAgICBzY2FsZTogeyAwOiAxIH0sXG5cdCAgICAgIGR1cmF0aW9uOiAxMDAwXG5cdCAgICB9KVxuXHQgICAgLnRoZW4oeyBzY2FsZTogMCB9KVxuXHQgICAgLnRoZW4oeyBzY2FsZTogMSwgb25Db21wbGV0ZSAoKSB7IHRoaXMucGF1c2UoKTsgfSB9KVxuXHQgICAgLnRoZW4oeyBzY2FsZTogMCB9KVxuXHQgICAgLnRoZW4oeyBzY2FsZTogMSB9KVxuXHQgICAgO1xuXG5cdCAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblx0ICAgICAgc2hhcGVcblx0ICAgICAgICAudHVuZSh7IGZpbGw6ICdjeWFuJyB9KVxuXHQgICAgICAgIC5wbGF5KCk7XG5cdCAgICB9KTtcblx0Ki9cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXHRpZiAodHJ1ZSkge1xuXHQgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgIHJldHVybiBtb2pzO1xuXHQgIH0uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fVxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXHRpZiAoKGZhbHNlID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkobW9kdWxlKSkgPT09IFwib2JqZWN0XCIgJiYgKDAsIF90eXBlb2YzLmRlZmF1bHQpKG1vZHVsZS5leHBvcnRzKSA9PT0gXCJvYmplY3RcIikge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gbW9qcztcblx0fVxuXG5cdGV4cG9ydHMuZGVmYXVsdCA9IG1vanM7XG5cblxuXHR0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93Lm1vanMgPSBtb2pzKTtcblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKG1vZHVsZSkpKVxuXG4vKioqLyB9LFxuLyogNTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KS5TeW1ib2w7XG5cbi8qKiovIH0sXG4vKiA1NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0X193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCkuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuXG4vKioqLyB9LFxuLyogNTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpe1xuXHQgIHJldHVybiAkLmNyZWF0ZShQLCBEKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDU3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KS5PYmplY3QuYXNzaWduO1xuXG4vKioqLyB9LFxuLyogNTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXHR2YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MCk7XG5cdEl0ZXJhdG9ycy5Ob2RlTGlzdCA9IEl0ZXJhdG9ycy5IVE1MQ29sbGVjdGlvbiA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLyoqKi8gfSxcbi8qIDU5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciAkYXQgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSkodHJ1ZSk7XG5cblx0Ly8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDcyKShTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbihpdGVyYXRlZCl7XG5cdCAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuXHQgIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG5cdC8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcblx0fSwgZnVuY3Rpb24oKXtcblx0ICB2YXIgTyAgICAgPSB0aGlzLl90XG5cdCAgICAsIGluZGV4ID0gdGhpcy5faVxuXHQgICAgLCBwb2ludDtcblx0ICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuXHQgIHBvaW50ID0gJGF0KE8sIGluZGV4KTtcblx0ICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcblx0ICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xuXHR9KTtcblxuLyoqKi8gfSxcbi8qIDYwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKVxuXHQgICwgZ2V0ICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcblx0ICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcblx0ICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG5cdCAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA2MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHN0b3JlICA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpKCd3a3MnKVxuXHQgICwgdWlkICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nilcblx0ICAsIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpLlN5bWJvbDtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcblx0ICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cblx0ICAgIFN5bWJvbCAmJiBTeW1ib2xbbmFtZV0gfHwgKFN5bWJvbCB8fCB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDYyICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdC8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cblx0dmFyICQgICAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nilcblx0ICAsIGdsb2JhbCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nylcblx0ICAsIGhhcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OClcblx0ICAsIERFU0NSSVBUT1JTICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OSlcblx0ICAsICRleHBvcnQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MClcblx0ICAsIHJlZGVmaW5lICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MSlcblx0ICAsICRmYWlscyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Milcblx0ICAsIHNoYXJlZCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NSlcblx0ICAsIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mylcblx0ICAsIHVpZCAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nilcblx0ICAsIHdrcyAgICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSlcblx0ICAsIGtleU9mICAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NClcblx0ICAsICRuYW1lcyAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NSlcblx0ICAsIGVudW1LZXlzICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nilcblx0ICAsIGlzQXJyYXkgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Nylcblx0ICAsIGFuT2JqZWN0ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mylcblx0ICAsIHRvSU9iamVjdCAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OClcblx0ICAsIGNyZWF0ZURlc2MgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OSlcblx0ICAsIGdldERlc2MgICAgICAgID0gJC5nZXREZXNjXG5cdCAgLCBzZXREZXNjICAgICAgICA9ICQuc2V0RGVzY1xuXHQgICwgX2NyZWF0ZSAgICAgICAgPSAkLmNyZWF0ZVxuXHQgICwgZ2V0TmFtZXMgICAgICAgPSAkbmFtZXMuZ2V0XG5cdCAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcblx0ICAsICRKU09OICAgICAgICAgID0gZ2xvYmFsLkpTT05cblx0ICAsIF9zdHJpbmdpZnkgICAgID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5XG5cdCAgLCBzZXR0ZXIgICAgICAgICA9IGZhbHNlXG5cdCAgLCBISURERU4gICAgICAgICA9IHdrcygnX2hpZGRlbicpXG5cdCAgLCBpc0VudW0gICAgICAgICA9ICQuaXNFbnVtXG5cdCAgLCBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jylcblx0ICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcblx0ICAsIHVzZU5hdGl2ZSAgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuXHQgICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xuXHR2YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbigpe1xuXHQgIHJldHVybiBfY3JlYXRlKHNldERlc2Moe30sICdhJywge1xuXHQgICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gc2V0RGVzYyh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cblx0ICB9KSkuYSAhPSA3O1xuXHR9KSA/IGZ1bmN0aW9uKGl0LCBrZXksIEQpe1xuXHQgIHZhciBwcm90b0Rlc2MgPSBnZXREZXNjKE9iamVjdFByb3RvLCBrZXkpO1xuXHQgIGlmKHByb3RvRGVzYylkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcblx0ICBzZXREZXNjKGl0LCBrZXksIEQpO1xuXHQgIGlmKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pc2V0RGVzYyhPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xuXHR9IDogc2V0RGVzYztcblxuXHR2YXIgd3JhcCA9IGZ1bmN0aW9uKHRhZyl7XG5cdCAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbC5wcm90b3R5cGUpO1xuXHQgIHN5bS5fayA9IHRhZztcblx0ICBERVNDUklQVE9SUyAmJiBzZXR0ZXIgJiYgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7XG5cdCAgICBjb25maWd1cmFibGU6IHRydWUsXG5cdCAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcblx0ICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuXHQgICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiBzeW07XG5cdH07XG5cblx0dmFyIGlzU3ltYm9sID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG5cdH07XG5cblx0dmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpe1xuXHQgIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkpe1xuXHQgICAgaWYoIUQuZW51bWVyYWJsZSl7XG5cdCAgICAgIGlmKCFoYXMoaXQsIEhJRERFTikpc2V0RGVzYyhpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG5cdCAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBpZihoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKWl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuXHQgICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcblx0ICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG5cdCAgfSByZXR1cm4gc2V0RGVzYyhpdCwga2V5LCBEKTtcblx0fTtcblx0dmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCl7XG5cdCAgYW5PYmplY3QoaXQpO1xuXHQgIHZhciBrZXlzID0gZW51bUtleXMoUCA9IHRvSU9iamVjdChQKSlcblx0ICAgICwgaSAgICA9IDBcblx0ICAgICwgbCA9IGtleXMubGVuZ3RoXG5cdCAgICAsIGtleTtcblx0ICB3aGlsZShsID4gaSkkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cdHZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKXtcblx0ICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG5cdH07XG5cdHZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpe1xuXHQgIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5KTtcblx0ICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldXG5cdCAgICA/IEUgOiB0cnVlO1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KXtcblx0ICB2YXIgRCA9IGdldERlc2MoaXQgPSB0b0lPYmplY3QoaXQpLCBrZXkpO1xuXHQgIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuXHQgIHJldHVybiBEO1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcblx0ICB2YXIgbmFtZXMgID0gZ2V0TmFtZXModG9JT2JqZWN0KGl0KSlcblx0ICAgICwgcmVzdWx0ID0gW11cblx0ICAgICwgaSAgICAgID0gMFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZighaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4pcmVzdWx0LnB1c2goa2V5KTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHR2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCl7XG5cdCAgdmFyIG5hbWVzICA9IGdldE5hbWVzKHRvSU9iamVjdChpdCkpXG5cdCAgICAsIHJlc3VsdCA9IFtdXG5cdCAgICAsIGkgICAgICA9IDBcblx0ICAgICwga2V5O1xuXHQgIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pKXJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0dmFyICRzdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuXHQgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuXHQgIHZhciBhcmdzID0gW2l0XVxuXHQgICAgLCBpICAgID0gMVxuXHQgICAgLCAkJCAgID0gYXJndW1lbnRzXG5cdCAgICAsIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG5cdCAgd2hpbGUoJCQubGVuZ3RoID4gaSlhcmdzLnB1c2goJCRbaSsrXSk7XG5cdCAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuXHQgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuXHQgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcblx0ICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuXHQgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG5cdCAgfTtcblx0ICBhcmdzWzFdID0gcmVwbGFjZXI7XG5cdCAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuXHR9O1xuXHR2YXIgYnVnZ3lKU09OID0gJGZhaWxzKGZ1bmN0aW9uKCl7XG5cdCAgdmFyIFMgPSAkU3ltYm9sKCk7XG5cdCAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cblx0ICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGxcblx0ICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuXHQgIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7YTogU30pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG5cdH0pO1xuXG5cdC8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuXHRpZighdXNlTmF0aXZlKXtcblx0ICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCl7XG5cdCAgICBpZihpc1N5bWJvbCh0aGlzKSl0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuXHQgICAgcmV0dXJuIHdyYXAodWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKSk7XG5cdCAgfTtcblx0ICByZWRlZmluZSgkU3ltYm9sLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcblx0ICAgIHJldHVybiB0aGlzLl9rO1xuXHQgIH0pO1xuXG5cdCAgaXNTeW1ib2wgPSBmdW5jdGlvbihpdCl7XG5cdCAgICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xuXHQgIH07XG5cblx0ICAkLmNyZWF0ZSAgICAgPSAkY3JlYXRlO1xuXHQgICQuaXNFbnVtICAgICA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0ICAkLmdldERlc2MgICAgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXHQgICQuc2V0RGVzYyAgICA9ICRkZWZpbmVQcm9wZXJ0eTtcblx0ICAkLnNldERlc2NzICAgPSAkZGVmaW5lUHJvcGVydGllcztcblx0ICAkLmdldE5hbWVzICAgPSAkbmFtZXMuZ2V0ID0gJGdldE93blByb3BlcnR5TmFtZXM7XG5cdCAgJC5nZXRTeW1ib2xzID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuXHQgIGlmKERFU0NSSVBUT1JTICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKSl7XG5cdCAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcblx0ICB9XG5cdH1cblxuXHR2YXIgc3ltYm9sU3RhdGljcyA9IHtcblx0ICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcblx0ICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcblx0ICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcblx0ICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG5cdCAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcblx0ICB9LFxuXHQgIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuXHQgIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG5cdCAgICByZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG5cdCAgfSxcblx0ICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG5cdCAgdXNlU2ltcGxlOiBmdW5jdGlvbigpeyBzZXR0ZXIgPSBmYWxzZTsgfVxuXHR9O1xuXHQvLyAxOS40LjIuMiBTeW1ib2wuaGFzSW5zdGFuY2Vcblx0Ly8gMTkuNC4yLjMgU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZVxuXHQvLyAxOS40LjIuNCBTeW1ib2wuaXRlcmF0b3Jcblx0Ly8gMTkuNC4yLjYgU3ltYm9sLm1hdGNoXG5cdC8vIDE5LjQuMi44IFN5bWJvbC5yZXBsYWNlXG5cdC8vIDE5LjQuMi45IFN5bWJvbC5zZWFyY2hcblx0Ly8gMTkuNC4yLjEwIFN5bWJvbC5zcGVjaWVzXG5cdC8vIDE5LjQuMi4xMSBTeW1ib2wuc3BsaXRcblx0Ly8gMTkuNC4yLjEyIFN5bWJvbC50b1ByaW1pdGl2ZVxuXHQvLyAxOS40LjIuMTMgU3ltYm9sLnRvU3RyaW5nVGFnXG5cdC8vIDE5LjQuMi4xNCBTeW1ib2wudW5zY29wYWJsZXNcblx0JC5lYWNoLmNhbGwoKFxuXHQgICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsJyArXG5cdCAgJ3NwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG5cdCkuc3BsaXQoJywnKSwgZnVuY3Rpb24oaXQpe1xuXHQgIHZhciBzeW0gPSB3a3MoaXQpO1xuXHQgIHN5bWJvbFN0YXRpY3NbaXRdID0gdXNlTmF0aXZlID8gc3ltIDogd3JhcChzeW0pO1xuXHR9KTtcblxuXHRzZXR0ZXIgPSB0cnVlO1xuXG5cdCRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XLCB7U3ltYm9sOiAkU3ltYm9sfSk7XG5cblx0JGV4cG9ydCgkZXhwb3J0LlMsICdTeW1ib2wnLCBzeW1ib2xTdGF0aWNzKTtcblxuXHQkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICF1c2VOYXRpdmUsICdPYmplY3QnLCB7XG5cdCAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuXHQgIGNyZWF0ZTogJGNyZWF0ZSxcblx0ICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcblx0ICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuXHQgIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG5cdCAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG5cdCAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuXHQgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcblx0ICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuXHQgIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuXHQgIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcblx0ICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0fSk7XG5cblx0Ly8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG5cdCRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCF1c2VOYXRpdmUgfHwgYnVnZ3lKU09OKSwgJ0pTT04nLCB7c3RyaW5naWZ5OiAkc3RyaW5naWZ5fSk7XG5cblx0Ly8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuXHRzZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG5cdC8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcblx0Ly8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cblx0c2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG5cbi8qKiovIH0sXG4vKiA2MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0XG5cbi8qKiovIH0sXG4vKiA2NCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMS4yLjYnfTtcblx0aWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbi8qKiovIH0sXG4vKiA2NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcblx0JGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IF9fd2VicGFja19yZXF1aXJlX18oOTEpLnNldH0pO1xuXG4vKioqLyB9LFxuLyogNjYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXHRtb2R1bGUuZXhwb3J0cyA9IHtcblx0ICBjcmVhdGU6ICAgICAkT2JqZWN0LmNyZWF0ZSxcblx0ICBnZXRQcm90bzogICAkT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuXHQgIGlzRW51bTogICAgIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuXHQgIGdldERlc2M6ICAgICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuXHQgIHNldERlc2M6ICAgICRPYmplY3QuZGVmaW5lUHJvcGVydHksXG5cdCAgc2V0RGVzY3M6ICAgJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzLFxuXHQgIGdldEtleXM6ICAgICRPYmplY3Qua2V5cyxcblx0ICBnZXROYW1lczogICAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG5cdCAgZ2V0U3ltYm9sczogJE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG5cdCAgZWFjaDogICAgICAgW10uZm9yRWFjaFxuXHR9O1xuXG4vKioqLyB9LFxuLyogNjcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxuXHR2YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcblxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDkzKSgna2V5cycsIGZ1bmN0aW9uKCRrZXlzKXtcblx0ICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG5cdCAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcblx0ICB9O1xuXHR9KTtcblxuLyoqKi8gfSxcbi8qIDY4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxuXHR2YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xuXG5cdCRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2Fzc2lnbjogX193ZWJwYWNrX3JlcXVpcmVfXyg5NCl9KTtcblxuLyoqKi8gfSxcbi8qIDY5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdHZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSlcblx0ICAsIHN0ZXAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk2KVxuXHQgICwgSXRlcmF0b3JzICAgICAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzApXG5cdCAgLCB0b0lPYmplY3QgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4OCk7XG5cblx0Ly8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuXHQvLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmtleXMoKVxuXHQvLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG5cdC8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG5cdCAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuXHQgIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG5cdCAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcblx0Ly8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG5cdH0sIGZ1bmN0aW9uKCl7XG5cdCAgdmFyIE8gICAgID0gdGhpcy5fdFxuXHQgICAgLCBraW5kICA9IHRoaXMuX2tcblx0ICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG5cdCAgaWYoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpe1xuXHQgICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiBzdGVwKDEpO1xuXHQgIH1cblx0ICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcblx0ICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcblx0ICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG5cdH0sICd2YWx1ZXMnKTtcblxuXHQvLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5cdEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cblx0YWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuXHRhZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcblx0YWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vKioqLyB9LFxuLyogNzAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0sXG4vKiA3MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTcpXG5cdCAgLCBkZWZpbmVkICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4KTtcblx0Ly8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG5cdC8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG5cdCAgcmV0dXJuIGZ1bmN0aW9uKHRoYXQsIHBvcyl7XG5cdCAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKVxuXHQgICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuXHQgICAgICAsIGwgPSBzLmxlbmd0aFxuXHQgICAgICAsIGEsIGI7XG5cdCAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuXHQgICAgYSA9IHMuY2hhckNvZGVBdChpKTtcblx0ICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG5cdCAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG5cdCAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0sXG4vKiA3MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgTElCUkFSWSAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwKVxuXHQgICwgJGV4cG9ydCAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKVxuXHQgICwgcmVkZWZpbmUgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKVxuXHQgICwgaGlkZSAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KVxuXHQgICwgaGFzICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc4KVxuXHQgICwgSXRlcmF0b3JzICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKVxuXHQgICwgJGl0ZXJDcmVhdGUgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMClcblx0ICAsIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mylcblx0ICAsIGdldFByb3RvICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NikuZ2V0UHJvdG9cblx0ICAsIElURVJBVE9SICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSkoJ2l0ZXJhdG9yJylcblx0ICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcblx0ICAsIEZGX0lURVJBVE9SICAgID0gJ0BAaXRlcmF0b3InXG5cdCAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuXHQgICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxuXHR2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcblx0ICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cdCAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGtpbmQpe1xuXHQgICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuXHQgICAgc3dpdGNoKGtpbmQpe1xuXHQgICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG5cdCAgfTtcblx0ICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuXHQgICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcblx0ICAgICwgVkFMVUVTX0JVRyA9IGZhbHNlXG5cdCAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuXHQgICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG5cdCAgICAsICRkZWZhdWx0ICAgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKVxuXHQgICAgLCBtZXRob2RzLCBrZXk7XG5cdCAgLy8gRml4IG5hdGl2ZVxuXHQgIGlmKCRuYXRpdmUpe1xuXHQgICAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8oJGRlZmF1bHQuY2FsbChuZXcgQmFzZSkpO1xuXHQgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuXHQgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG5cdCAgICAvLyBGRiBmaXhcblx0ICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcblx0ICAgIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcblx0ICAgIGlmKERFRl9WQUxVRVMgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuXHQgICAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcblx0ICAgICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8gRGVmaW5lIGl0ZXJhdG9yXG5cdCAgaWYoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpe1xuXHQgICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcblx0ICB9XG5cdCAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuXHQgIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuXHQgIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG5cdCAgaWYoREVGQVVMVCl7XG5cdCAgICBtZXRob2RzID0ge1xuXHQgICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTICA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG5cdCAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG5cdCAgICAgIGVudHJpZXM6ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuXHQgICAgfTtcblx0ICAgIGlmKEZPUkNFRClmb3Ioa2V5IGluIG1ldGhvZHMpe1xuXHQgICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcblx0ICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG5cdCAgfVxuXHQgIHJldHVybiBtZXRob2RzO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNzMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoIWlzT2JqZWN0KGl0KSl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG5cdCAgcmV0dXJuIGl0O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNzQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBjbGFzc29mICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMilcblx0ICAsIElURVJBVE9SICA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpKCdpdGVyYXRvcicpXG5cdCAgLCBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZihpdCAhPSB1bmRlZmluZWQpcmV0dXJuIGl0W0lURVJBVE9SXVxuXHQgICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuXHQgICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDc1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nylcblx0ICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG5cdCAgLCBzdG9yZSAgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDc2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgaWQgPSAwXG5cdCAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcblx0ICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogNzcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5cdHZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuXHQgID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0aWYodHlwZW9mIF9fZyA9PSAnbnVtYmVyJylfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuLyoqKi8gfSxcbi8qIDc4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDc5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5cdG1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oODIpKGZ1bmN0aW9uKCl7XG5cdCAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcblx0fSk7XG5cbi8qKiovIH0sXG4vKiA4MCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGdsb2JhbCAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpXG5cdCAgLCBjb3JlICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KVxuXHQgICwgY3R4ICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpXG5cdCAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuXHR2YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG5cdCAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcblx0ICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuXHQgICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG5cdCAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcblx0ICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuXHQgICAgLCBJU19XUkFQICAgPSB0eXBlICYgJGV4cG9ydC5XXG5cdCAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG5cdCAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cblx0ICAgICwga2V5LCBvd24sIG91dDtcblx0ICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcblx0ICBmb3Ioa2V5IGluIHNvdXJjZSl7XG5cdCAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcblx0ICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIGtleSBpbiB0YXJnZXQ7XG5cdCAgICBpZihvd24gJiYga2V5IGluIGV4cG9ydHMpY29udGludWU7XG5cdCAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuXHQgICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcblx0ICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuXHQgICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cblx0ICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG5cdCAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuXHQgICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcblx0ICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24oQyl7XG5cdCAgICAgIHZhciBGID0gZnVuY3Rpb24ocGFyYW0pe1xuXHQgICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgQyA/IG5ldyBDKHBhcmFtKSA6IEMocGFyYW0pO1xuXHQgICAgICB9O1xuXHQgICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG5cdCAgICAgIHJldHVybiBGO1xuXHQgICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG5cdCAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG5cdCAgICBpZihJU19QUk9UTykoZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSkpW2tleV0gPSBvdXQ7XG5cdCAgfVxuXHR9O1xuXHQvLyB0eXBlIGJpdG1hcFxuXHQkZXhwb3J0LkYgPSAxOyAgLy8gZm9yY2VkXG5cdCRleHBvcnQuRyA9IDI7ICAvLyBnbG9iYWxcblx0JGV4cG9ydC5TID0gNDsgIC8vIHN0YXRpY1xuXHQkZXhwb3J0LlAgPSA4OyAgLy8gcHJvdG9cblx0JGV4cG9ydC5CID0gMTY7IC8vIGJpbmRcblx0JGV4cG9ydC5XID0gMzI7IC8vIHdyYXBcblx0bW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG4vKioqLyB9LFxuLyogODEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OSk7XG5cbi8qKiovIH0sXG4vKiA4MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcblx0ICB0cnkge1xuXHQgICAgcmV0dXJuICEhZXhlYygpO1xuXHQgIH0gY2F0Y2goZSl7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0ICB9XG5cdH07XG5cbi8qKiovIH0sXG4vKiA4MyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyIGRlZiA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpLnNldERlc2Ncblx0ICAsIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpXG5cdCAgLCBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSgndG9TdHJpbmdUYWcnKTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuXHQgIGlmKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpZGVmKGl0LCBUQUcsIHtjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWd9KTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDg0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgJCAgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nilcblx0ICAsIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgZWwpe1xuXHQgIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuXHQgICAgLCBrZXlzICAgPSAkLmdldEtleXMoTylcblx0ICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcblx0ICAgICwgaW5kZXggID0gMFxuXHQgICAgLCBrZXk7XG5cdCAgd2hpbGUobGVuZ3RoID4gaW5kZXgpaWYoT1trZXkgPSBrZXlzW2luZGV4KytdXSA9PT0gZWwpcmV0dXJuIGtleTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDg1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5cdHZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KVxuXHQgICwgZ2V0TmFtZXMgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NikuZ2V0TmFtZXNcblx0ICAsIHRvU3RyaW5nICA9IHt9LnRvU3RyaW5nO1xuXG5cdHZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcblx0ICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxuXHR2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbihpdCl7XG5cdCAgdHJ5IHtcblx0ICAgIHJldHVybiBnZXROYW1lcyhpdCk7XG5cdCAgfSBjYXRjaChlKXtcblx0ICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuXHQgIH1cblx0fTtcblxuXHRtb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcblx0ICBpZih3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJylyZXR1cm4gZ2V0V2luZG93TmFtZXMoaXQpO1xuXHQgIHJldHVybiBnZXROYW1lcyh0b0lPYmplY3QoaXQpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDg2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xuXHR2YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICB2YXIga2V5cyAgICAgICA9ICQuZ2V0S2V5cyhpdClcblx0ICAgICwgZ2V0U3ltYm9scyA9ICQuZ2V0U3ltYm9scztcblx0ICBpZihnZXRTeW1ib2xzKXtcblx0ICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdClcblx0ICAgICAgLCBpc0VudW0gID0gJC5pc0VudW1cblx0ICAgICAgLCBpICAgICAgID0gMFxuXHQgICAgICAsIGtleTtcblx0ICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlrZXlzLnB1c2goa2V5KTtcblx0ICB9XG5cdCAgcmV0dXJuIGtleXM7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA4NyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA0KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZyl7XG5cdCAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA4OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG5cdHZhciBJT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpXG5cdCAgLCBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDg5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuXHQgIHJldHVybiB7XG5cdCAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG5cdCAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG5cdCAgICB3cml0YWJsZSAgICA6ICEoYml0bWFwICYgNCksXG5cdCAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG5cdCAgfTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDkwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cbi8qKiovIH0sXG4vKiA5MSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdHZhciBnZXREZXNjICA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpLmdldERlc2Ncblx0ICAsIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDEpXG5cdCAgLCBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNzMpO1xuXHR2YXIgY2hlY2sgPSBmdW5jdGlvbihPLCBwcm90byl7XG5cdCAgYW5PYmplY3QoTyk7XG5cdCAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0ge1xuXHQgIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0ICAgIGZ1bmN0aW9uKHRlc3QsIGJ1Z2d5LCBzZXQpe1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKShGdW5jdGlvbi5jYWxsLCBnZXREZXNjKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuXHQgICAgICAgIHNldCh0ZXN0LCBbXSk7XG5cdCAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG5cdCAgICAgIH0gY2F0Y2goZSl7IGJ1Z2d5ID0gdHJ1ZTsgfVxuXHQgICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuXHQgICAgICAgIGNoZWNrKE8sIHByb3RvKTtcblx0ICAgICAgICBpZihidWdneSlPLl9fcHJvdG9fXyA9IHByb3RvO1xuXHQgICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcblx0ICAgICAgICByZXR1cm4gTztcblx0ICAgICAgfTtcblx0ICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG5cdCAgY2hlY2s6IGNoZWNrXG5cdH07XG5cbi8qKiovIH0sXG4vKiA5MiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxuXHR2YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDkzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcblx0dmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKVxuXHQgICwgY29yZSAgICA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpXG5cdCAgLCBmYWlscyAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4Mik7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcblx0ICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG5cdCAgICAsIGV4cCA9IHt9O1xuXHQgIGV4cFtLRVldID0gZXhlYyhmbik7XG5cdCAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogOTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcblx0dmFyICQgICAgICAgID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nilcblx0ICAsIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Milcblx0ICAsIElPYmplY3QgID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuXG5cdC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oODIpKGZ1bmN0aW9uKCl7XG5cdCAgdmFyIGEgPSBPYmplY3QuYXNzaWduXG5cdCAgICAsIEEgPSB7fVxuXHQgICAgLCBCID0ge31cblx0ICAgICwgUyA9IFN5bWJvbCgpXG5cdCAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuXHQgIEFbU10gPSA3O1xuXHQgIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24oayl7IEJba10gPSBrOyB9KTtcblx0ICByZXR1cm4gYSh7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cyhhKHt9LCBCKSkuam9pbignJykgIT0gSztcblx0fSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cdCAgdmFyIFQgICAgID0gdG9PYmplY3QodGFyZ2V0KVxuXHQgICAgLCAkJCAgICA9IGFyZ3VtZW50c1xuXHQgICAgLCAkJGxlbiA9ICQkLmxlbmd0aFxuXHQgICAgLCBpbmRleCA9IDFcblx0ICAgICwgZ2V0S2V5cyAgICA9ICQuZ2V0S2V5c1xuXHQgICAgLCBnZXRTeW1ib2xzID0gJC5nZXRTeW1ib2xzXG5cdCAgICAsIGlzRW51bSAgICAgPSAkLmlzRW51bTtcblx0ICB3aGlsZSgkJGxlbiA+IGluZGV4KXtcblx0ICAgIHZhciBTICAgICAgPSBJT2JqZWN0KCQkW2luZGV4KytdKVxuXHQgICAgICAsIGtleXMgICA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUylcblx0ICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuXHQgICAgICAsIGogICAgICA9IDBcblx0ICAgICAgLCBrZXk7XG5cdCAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuXHQgIH1cblx0ICByZXR1cm4gVDtcblx0fSA6IE9iamVjdC5hc3NpZ247XG5cbi8qKiovIH0sXG4vKiA5NSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9O1xuXG4vKioqLyB9LFxuLyogOTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuXHQgIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xuXHR9O1xuXG4vKioqLyB9LFxuLyogOTcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIDcuMS40IFRvSW50ZWdlclxuXHR2YXIgY2VpbCAgPSBNYXRoLmNlaWxcblx0ICAsIGZsb29yID0gTWF0aC5mbG9vcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA5OCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcblx0ICByZXR1cm4gaXQ7XG5cdH07XG5cbi8qKiovIH0sXG4vKiA5OSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0dmFyICQgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KVxuXHQgICwgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oODkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNzkpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcblx0ICByZXR1cm4gJC5zZXREZXNjKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG5cdH0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuXHQgIG9iamVjdFtrZXldID0gdmFsdWU7XG5cdCAgcmV0dXJuIG9iamVjdDtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEwMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgJCAgICAgICAgICAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KVxuXHQgICwgZGVzY3JpcHRvciAgICAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5KVxuXHQgICwgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzKVxuXHQgICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuXHQvLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxuXHRfX3dlYnBhY2tfcmVxdWlyZV9fKDk5KShJdGVyYXRvclByb3RvdHlwZSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MSkoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcblx0ICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSAkLmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge25leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCl9KTtcblx0ICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEwMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuLyoqKi8gfSxcbi8qIDEwMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0Ly8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcblx0dmFyIGNvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA0KVxuXHQgICwgVEFHID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MSkoJ3RvU3RyaW5nVGFnJylcblx0ICAvLyBFUzMgd3JvbmcgaGVyZVxuXHQgICwgQVJHID0gY29mKGZ1bmN0aW9uKCl7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG5cdCAgdmFyIE8sIFQsIEI7XG5cdCAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG5cdCAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2Vcblx0ICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFRcblx0ICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuXHQgICAgOiBBUkcgPyBjb2YoTylcblx0ICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcblx0ICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTAzICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcblx0dmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTA2KTtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihmbiwgdGhhdCwgbGVuZ3RoKXtcblx0ICBhRnVuY3Rpb24oZm4pO1xuXHQgIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG5cdCAgc3dpdGNoKGxlbmd0aCl7XG5cdCAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcblx0ICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG5cdCAgICB9O1xuXHQgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG5cdCAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuXHQgICAgfTtcblx0ICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuXHQgICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXHQgIH07XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuXHQgIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG5cdH07XG5cbi8qKiovIH0sXG4vKiAxMDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdC8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5cdHZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNCk7XG5cdG1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG5cdCAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xuXHR9O1xuXG4vKioqLyB9LFxuLyogMTA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcblx0ICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuXHQgIHJldHVybiBpdDtcblx0fTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vbW8tanMvYnVpbGQvbW8uanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");
},/*!*********************************!*\
  !*** ./components/download.vue ***!
  \*********************************/
function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(/*! !vue-style-loader!css-loader?sourceMap!./../../~/vue-loader/lib/style-rewriter?id=data-v-0daf62e7!./../../~/vue-loader/lib/selector?type=styles&index=0!./../../~/eslint-loader!./download.vue */ 23)\n\nvar Component = __webpack_require__(/*! ./../../~/vue-loader/lib/component-normalizer */ 0)(\n  /* script */\n  __webpack_require__(/*! !babel-loader!eslint-loader!./../../~/vue-loader/lib/selector?type=script&index=0!./../../~/eslint-loader!./download.vue */ 6),\n  /* template */\n  __webpack_require__(/*! !./../../~/vue-loader/lib/template-compiler?id=data-v-0daf62e7!./../../~/vue-loader/lib/selector?type=template&index=0!./../../~/eslint-loader!./download.vue */ 18),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = "/media/ext_disk/CODEARMADA/http/experiments/vue/app/src/components/download.vue"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}\nif (Component.options.functional) {console.error("[vue-loader] download.vue: functional components are not supported with templates, they should use render functions.")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require("vue-hot-reload-api")\n  hotAPI.install(require("vue"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord("data-v-0daf62e7", Component.options)\n  } else {\n    hotAPI.reload("data-v-0daf62e7", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZT9iOGRkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyP2lkPWRhdGEtdi0wZGFmNjJlNyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9kb3dubG9hZC52dWVcIilcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhZXNsaW50LWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9kb3dubG9hZC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi0wZGFmNjJlNyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL2Rvd25sb2FkLnZ1ZVwiKSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBjc3NNb2R1bGVzICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL21lZGlhL2V4dF9kaXNrL0NPREVBUk1BREEvaHR0cC9leHBlcmltZW50cy92dWUvYXBwL3NyYy9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGRvd25sb2FkLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0wZGFmNjJlN1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTBkYWY2MmU3XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvZG93bmxvYWQudnVlXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9')},/*!*****************************!*\
  !*** ./components/main.vue ***!
  \*****************************/
function(module,exports,__webpack_require__){eval('\n/* styles */\n__webpack_require__(/*! !vue-style-loader!css-loader?sourceMap!./../../~/vue-loader/lib/style-rewriter?id=data-v-7fb69b18!./../../~/vue-loader/lib/selector?type=styles&index=0!./../../~/eslint-loader!./main.vue */ 24)\n\nvar Component = __webpack_require__(/*! ./../../~/vue-loader/lib/component-normalizer */ 0)(\n  /* script */\n  __webpack_require__(/*! !babel-loader!eslint-loader!./../../~/vue-loader/lib/selector?type=script&index=0!./../../~/eslint-loader!./main.vue */ 7),\n  /* template */\n  __webpack_require__(/*! !./../../~/vue-loader/lib/template-compiler?id=data-v-7fb69b18!./../../~/vue-loader/lib/selector?type=template&index=0!./../../~/eslint-loader!./main.vue */ 22),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = "/media/ext_disk/CODEARMADA/http/experiments/vue/app/src/components/main.vue"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}\nif (Component.options.functional) {console.error("[vue-loader] main.vue: functional components are not supported with templates, they should use render functions.")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require("vue-hot-reload-api")\n  hotAPI.install(require("vue"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord("data-v-7fb69b18", Component.options)\n  } else {\n    hotAPI.reload("data-v-7fb69b18", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlP2UwZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiBzdHlsZXMgKi9cbnJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXI/aWQ9ZGF0YS12LTdmYjY5YjE4IS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL21haW4udnVlXCIpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIWVzbGludC1sb2FkZXIhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuLy4uLy4uL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS4vbWFpbi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi03ZmI2OWIxOCEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL21haW4udnVlXCIpLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIGNzc01vZHVsZXMgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvbWVkaWEvZXh0X2Rpc2svQ09ERUFSTUFEQS9odHRwL2V4cGVyaW1lbnRzL3Z1ZS9hcHAvc3JjL2NvbXBvbmVudHMvbWFpbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBtYWluLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03ZmI2OWIxOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTdmYjY5YjE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvbWFpbi52dWVcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},/*!*****************************!*\
  !*** ./components/menu.vue ***!
  \*****************************/
function(module,exports,__webpack_require__){eval('var Component = __webpack_require__(/*! ./../../~/vue-loader/lib/component-normalizer */ 0)(\n  /* script */\n  __webpack_require__(/*! !babel-loader!eslint-loader!./../../~/vue-loader/lib/selector?type=script&index=0!./../../~/eslint-loader!./menu.vue */ 8),\n  /* template */\n  __webpack_require__(/*! !./../../~/vue-loader/lib/template-compiler?id=data-v-5c3a67be!./../../~/vue-loader/lib/selector?type=template&index=0!./../../~/eslint-loader!./menu.vue */ 20),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = "/media/ext_disk/CODEARMADA/http/experiments/vue/app/src/components/menu.vue"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}\nif (Component.options.functional) {console.error("[vue-loader] menu.vue: functional components are not supported with templates, they should use render functions.")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require("vue-hot-reload-api")\n  hotAPI.install(require("vue"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord("data-v-5c3a67be", Component.options)\n  } else {\n    hotAPI.reload("data-v-5c3a67be", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21lbnUudnVlP2U4NzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhZXNsaW50LWxvYWRlciEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9tZW51LnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/aWQ9ZGF0YS12LTVjM2E2N2JlIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLy4uLy4uL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS4vbWVudS52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9tZWRpYS9leHRfZGlzay9DT0RFQVJNQURBL2h0dHAvZXhwZXJpbWVudHMvdnVlL2FwcC9zcmMvY29tcG9uZW50cy9tZW51LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5ICE9PSBcIl9fZXNNb2R1bGVcIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG1lbnUudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTVjM2E2N2JlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNWMzYTY3YmVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY29tcG9uZW50cy9tZW51LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},/*!*******************************!*\
  !*** ./components/topbar.vue ***!
  \*******************************/
function(module,exports,__webpack_require__){eval('var Component = __webpack_require__(/*! ./../../~/vue-loader/lib/component-normalizer */ 0)(\n  /* script */\n  __webpack_require__(/*! !babel-loader!eslint-loader!./../../~/vue-loader/lib/selector?type=script&index=0!./../../~/eslint-loader!./topbar.vue */ 10),\n  /* template */\n  __webpack_require__(/*! !./../../~/vue-loader/lib/template-compiler?id=data-v-2d6eb886!./../../~/vue-loader/lib/selector?type=template&index=0!./../../~/eslint-loader!./topbar.vue */ 19),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\nComponent.options.__file = "/media/ext_disk/CODEARMADA/http/experiments/vue/app/src/components/topbar.vue"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key !== "__esModule"})) {console.error("named exports are not supported in *.vue files.")}\nif (Component.options.functional) {console.error("[vue-loader] topbar.vue: functional components are not supported with templates, they should use render functions.")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require("vue-hot-reload-api")\n  hotAPI.install(require("vue"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord("data-v-2d6eb886", Component.options)\n  } else {\n    hotAPI.reload("data-v-2d6eb886", Component.options)\n  }\n})()}\n\nmodule.exports = Component.exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3RvcGJhci52dWU/N2FhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciFlc2xpbnQtbG9hZGVyIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL3RvcGJhci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP2lkPWRhdGEtdi0yZDZlYjg4NiEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL3RvcGJhci52dWVcIiksXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogY3NzTW9kdWxlcyAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9tZWRpYS9leHRfZGlzay9DT0RFQVJNQURBL2h0dHAvZXhwZXJpbWVudHMvdnVlL2FwcC9zcmMvY29tcG9uZW50cy90b3BiYXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkgIT09IFwiX19lc01vZHVsZVwifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gdG9wYmFyLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yZDZlYjg4NlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJkNmViODg2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NvbXBvbmVudHMvdG9wYmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},/*!**********************************************************************************************************************************************************************!*\
  !*** ../~/vue-loader/lib/template-compiler.js?id=data-v-0daf62e7!../~/vue-loader/lib/selector.js?type=template&index=0!../~/eslint-loader!./components/download.vue ***!
  \**********************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'section\', {\n    staticClass: "Download",\n    style: ({\n      backgroundImage: ("url(" + _vm.backGround + ")"),\n    })\n  })\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require("vue-hot-reload-api").rerender("data-v-0daf62e7", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZT8zZDE5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnc2VjdGlvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJEb3dubG9hZFwiLFxuICAgIHN0eWxlOiAoe1xuICAgICAgYmFja2dyb3VuZEltYWdlOiAoXCJ1cmwoXCIgKyBfdm0uYmFja0dyb3VuZCArIFwiKVwiKSxcbiAgICB9KVxuICB9KVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0wZGFmNjJlN1wiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTBkYWY2MmU3IS4uL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4uL34vZXNsaW50LWxvYWRlciEuL2NvbXBvbmVudHMvZG93bmxvYWQudnVlXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},/*!********************************************************************************************************************************************************************!*\
  !*** ../~/vue-loader/lib/template-compiler.js?id=data-v-2d6eb886!../~/vue-loader/lib/selector.js?type=template&index=0!../~/eslint-loader!./components/topbar.vue ***!
  \********************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "Topbar"\n  }, [_c(\'div\', {\n    staticClass: "wrapper"\n  }, [_c(\'div\', {\n    staticClass: "logo"\n  }, [_c(\'svg\', {\n    attrs: {\n      "xmlns": "http://www.w3.org/2000/svg",\n      "viewBox": "0 0 168.24046 166.66701"\n    }\n  }, [_c(\'path\', {\n    attrs: {\n      "fill": "#211c1d",\n      "d": "M140.8508 80.52542c-.212-1.02267-.61066-1.83333-.42666-2.75067 1.28266.24534 2.50533.50534 3.84933.73467-.73333.672-1.64933 1.60267-3.42267 2.016zm-1.36933-22.528c-.83867-.29467-1.62-.99733-1.99067-1.78933 3.45067-.876 6.948-1.556 10.40667-2.3467.40267-.092.81867-.0774.204.2413-2.336 1.216-8.008 4.108-8.62 3.8946zm-4.19067 37.62c-1.09866-2.26134-.18266-5.43867-1.28266-7.76.79466-1.956.73333-4.27733 1.772-6.17067 1.46666 4.276 3.66533 10.204-.48934 13.93067zm-6.598 19.67333c-.1984-1.64933-.48906-3.05467-.2448-4.52133 1.34427-3.176 3.636-6.216 4.94947-9.104l1.46667 6.72133c-1.89467 2.38267-2.62707 6.23333-6.17134 6.904zm-5.1328-6.72133c-4.88746-.36534-9.65306-1.09867-14.48013-1.64934-.13387-1.11333-.16987-2.292-.34533-3.43866-.06507-.428-.3704-.548-.39227-.14934-.06093 1.09467-.16347 2.31467-.16347 3.43467-2.44426-.05867-4.71986-.51733-7.1636-.152 2.19894 1.16267 4.7656 1.40533 7.148 2.07867v2.932c-2.9324-.83067-5.9152-2.06134-8.85786-2.64934-.3068-.06133-.36614.23467-.08174.41734 2.72654 1.76133 6.00827 2.74266 8.9396 4.12533 0 2.99467 0 7.45467-.42706 10.99867-1.26094.26666-2.83134 1.17866-4.21987 1.288-.83333.06666-2.99067-1.96-3.54013-2.02134-.102 1.17067 1.83133 2.808.92666 4.028-.18186.24534-1.736.87467-2.69906.676-4.6176-3.37466-9.2348-6.92-14.01974-9.86133-.1532-.09333-.23693.28933-.0328.48133 4.12134 3.836 8.66667 7.10534 12.1588 11.70267-.6568.85467-1.34426 1.588-2.0776 2.38267-2.07653-1.03867-4.5364-1.29867-6.84266-1.64934-2.97814-4.35733-4.66254-9.312-7.1188-13.92-.26507-.49733-.60147-.45333-.47494.05734 1.1812 4.77333 3.17027 9.42133 4.6604 14.168-2.3828.61066-4.45986 2.13866-6.1708 3.84933-2.01613-1.528-3.6052-3.3-5.31613-5.13333.1124-5.98667.788-11.92134.99467-17.75867.0188-.53733-.23174-.632-.38067-.08133-1.6172 5.99466-3.974 16.496-3.974 16.496-3.23853.24533-7.1484.91733-10.264 1.58933-.55053-1.58933-1.4516-2.85733-3.10107-4.26267 3.77294-4.47066 7.89067-10.08 10.95054-15.02666.28493-.46134.1276-.652-.21827-.28534-3.93227 4.17067-7.59427 9.29334-12.0312 13.28134-3.17707-.54934-5.6208-3.116-9.3484-2.32134l.2448-4.4c4.36347-4.952 9.0676-8.596 13.3452-13.12933.1548-.164.14693-.55867-.19787-.34933-2.75 1.68-12.75 7.796-15.19946 9.08533-1.82867-2.21467-3.98654-4.1-5.96987-6.16 2.70053-.232 9.91307-.45467 13.7652-.56133 2.3896-.06667 2-.728.84013-.90667-2.0808-.32133-11.98493-1.64-16.4204-1.908.85054-3.028.98027-7.00133-.1224-9.96 5.49587-2.308 11.93227-2.34267 18.15107-2.904.69373-.064.63173-.356-.09427-.41867-6.37706-.556-13.01933-.71066-19.21773-1.26-1.5276-2.50533-2.87187-5.07066-5.0104-7.332.85627-2.628 1.58853-5.988 4.7052-7.02666 6.68027-2.22667 14.05467-2.8 20.7756-4.96.47133-.15067.3624-.39067-.1636-.35067-7.21307.53734-15.03693.484-22.3844.484-1.28227-.79466-2.07653-2.32133-2.62653-3.66533 1.28226-2.56667 3.1156-4.828 5.13173-7.028 1.43133-1.32533 3.5516-1.96 5.44427-1.50667.24853.06 10.29426 3.42667 17.15106 5.53734 1.1276.348 1.24374.056.33027-.3894-6.01933-2.9267-12.1048-6.2-18.09853-9.384 2.02666-2.1827 2.08906-5.732 3.45426-8.2547.68014-1.256 4.64-3.0174 5.2156-3.148 5.66147-1.296 8.85254-1.328 11.43227-6.1947 5.3156.9173 4.2792 15.6053 4.45253 17.8093.05.6426.46467.5786.50267-.0787.29693-5.1374.33547-10.812 1.09373-15.9574 6.69014.3814 13.99174-4.1546 16.37454-5.0106-.3584 7.0106-1.44534 13.8493-2.2912 20.588-.164 1.308.26253 1.3213.5896.012 1.55106-6.1934 2.67186-12.5747 4.0844-18.828 1.35773-.64 2.4016.2346 3.52493.968 1.45947.9533 4.96773 1.3533 4.96773 1.3533 1.3208 7.1813 2.75054 14.3627 4.39014 21.3907.2484 1.0693.63906.7706.5536-.4587-.26974-3.8734-1.264-18.5014-1.07654-21.052 1.7308-.5054 3.67814-1.1774 5.05307-1.9427 1.57773 2.2653 4.286 4.7946 4.3996 7.684-.862 6.3026-2.62667 12.4146-3.91053 18.504-.1724.8173.12453.9266.41626.1573 2.09467-5.5387 3.71454-11.28 6.1828-16.6454.51094-.6574 1.26347-.6374 2.0208-.476.50827.108 5.1276 2.6146 7.3276 2.8586.36667 3.6667 2.19894 7.516 5.74267 9.0427 0 0-6.67653 9.4546-10.2916 14.8293-.7276 1.0826-.5104 1.144.43013.2666 4.55894-4.2507 7.66667-9.0667 12.79427-12.7134-.79427 1.5293-.67187 3.6667-.91667 5.256-4.48386 3.2813-9.06613 6.6093-13.52653 9.7707-.52347.3706-.35773.592.2448.3226 4.5312-2.0227 9.08027-4.4867 13.77133-6.4267.36614 1.48.85467 2.1373 1.588 3.1146-1.588.6106-3.42133.5493-5.0104 1.1613 1.89427.8547 4.15467.672 6.17187 1.1613-.30627 1.8933 1.28227 3.2213 2.19893 4.2773-.8556 2.6866-2.5052 5.0093-2.5052 8.06392-5.51453-.772-11.2296-2.04266-16.60413-3.4053-.5792-.148-.63747.1093-.08533.372 4.94786 2.34663 10.3504 3.9573 15.40666 6.212 2.19947 2.3213.79427 6.108 2.01614 8.7973-5.0604-2.9413-9.44-7.75467-13.9588-12.09067-.174-.1667-.414.0506-.26507.2613 3.8276 5.41065 9.15 10.096 12.20773 15.8zm.30574 16.98533c-3.4672 2.98-7.88174 3.54533-7.88174 3.54533l1.89427-4.156 3.6656-3.17733c.55.06267 1.65-.18267 2.5052-.304.1224 1.648-.06093 2.64267-.18333 4.092zm-14.48014-16.556l13.19734 3.23733c1.03906.91734 1.03906 2.81067.54946 3.91067h-2.0156l-11.48693-3.91067zm2.4432 16.252c-.73226-.36533-1.58746-.91733-1.58746-1.89467l-.61147-9.22666 7.20933 2.628c.90787 1.17866.45267 1.896-.35 2.51733-.81773.63467-3.88066 4.14267-4.6604 5.976zm-3.28173 10.18267c-.32347.08266-3.9272.32666-5.0276 1.12133l-3.97147-1.04c.91667-2.444 4.33814-2.26 5.56054-4.704l3.66506-.97867c1.162.30667 2.2312.688 3.5448.97867-1.46466 1.464-1.72133 4.09067-3.77133 4.62267zm-17.06413 3.32c-3.05414.856-6.35467 1.956-9.71454 1.344.85574-1.588 2.688-2.81067 4.39894-3.23734l5.43853.85467zm-17.1312 1.90666c-.438-.21733-7.24747-2.02933-10.42454-2.212l-2.38333-2.62666c2.6276-.55067 5.3776-.672 8.0656-1.04 1.64947 2.2 3.91 3.60666 5.86573 5.44-.32613.68-.71.64266-1.12346.43866zm-23.07134-6.428c-2.38293-1.64933-4.0948-4.15466-5.43853-6.476 2.5052-1.16133 5.59053.32 6.5984 1.89467l2.2 3.54267zm-19.9188-18.08533c.97654-2.31467.52494-5.14667.24894-7.76933-.05254-.496.12186-.572.34173-.116 1.79053 3.72266 7.42333 7.92266 7.6348 8.13733 2.03493 2.08133-.14947 5.24133.99947 7.81333-4.15414-.73333-8.24787-3.788-9.22494-8.06533zm-6.7828-20.04133c.55054-2.872.85574-6.16934.30574-9.10267l.91667-1.344c1.3407 1.932 3.2407 3.812 4.2719 5.97067 1.8692 3.91066 1.575 6.58133.5552 11.80933-1.039-2.99467-3.3-5.744-6.0494-7.33333zm-1.58853-24.19467l2.0776-3.66666c.79427 1.6493 1.46613 3.4213 2.9328 4.828-1.038 1.648-2.19946 3.2986-2.5052 5.2546-1.22186-1.8334-2.13853-4.0947-2.5052-6.416zm5.43853-21.56933c3.5432-.73333 6.29267-3.36 9.34787-5.31467-.2448 2.872-2.87187 5.376-3.17707 8.55334-3.17706 1.6493-6.10986 5.0106-7.9432 8.0653-1.09946-4.1534 1.28334-7.5147 1.7724-11.304zM52.34707 33.0001c.2296.044 2.0484.784 2.90467.60132-1.15574 2.27333-3.28907 2.68267-5.4844 3.00133-2.6136.38267-6.04067 2.08134-8.18747 3.64267l-.13707-.59467c3.6068-2.38533 6.3276-7.48533 10.90427-6.65066zm10.0072-3.90535c3.97613-6.49466 12.04173-6.484 17.1844-.84-6.5692 5.34667-14.45 4.184-14.45 4.184-1.46667-1.03733-3.1776-1.588-5.0104-1.76933.42707-.49067 1.54213-1.208 2.276-1.57467zm34.60427-1.53733c.47546.33867 3.0176 2.37867 3.0176 2.37867-3.17707 3.6653-12.52814 1.5373-15.0916-2.2014 6.93066-2.8747 10.64786-1.196 12.074-.1774zm20.3088 10.32133l.73333 3.23734c-2.07813-1.1-4.15467-2.1987-6.59893-2.3827-1.46614-2.872-4.09374-5.5614-6.17094-8.3707 2.87147-.8547 7.072-.1974 12.03654 7.516zm7.02653 9.22667l2.9328.12c1.40467 1.77333 1.8792 3.788 2.19893 6.04933-1.34373-.85466-5.43746-1.95466-5.13173-6.16933zm8.5536 11.852c1.28333 1.344 2.56733 3.36133 4.39933 3.84933.18267 3.29867-.244 7.08667-1.344 10.26534-1.34533-.2454-2.74426-5.5694-3.33133-6.8-1.59733-3.356.276-7.3147.276-7.3147zm34.78466 25.272c-4.612-1.83733-19.14266-6.45467-19.14266-6.45467 2.152-1.95333 4.59467-3.65866 6.64933-5.69066.45067-.448.276-.7027-.232-.3547-2.716 1.864-5.40933 3.736-8.18933 5.436-2.016-.7334-3.48267-1.4827-5.988-2.628 2.13867-4.216.916-9.4094 2.50533-13.624l12.036-8.9814s4.66-1.208 6.52533-1.5947c1.904-.3934 2.04534-.732.06534-.584-1.45734.108-3.43067.3733-4.2.412 1.032-.8187 2.30533-1.744 3.23466-2.644.252-.244.34267-.544-.17733-.26-2.04 1.1133-7.06533 3.8546-7.16666 3.8706-6.27867.9493-18.05067 3.1266-18.94267 1.1333-1.04533-2.3307-1.414-4.9907-2.3724-7.3614 5.68307-6.9787 13.18307-12.4014 19.4884-17.9427.54-.4733.43467-.8413-.7-.0813-5.65733 3.7893-22.13 15-22.52747 15.0266-1.20306.0866-3.3484.236-3.51866.2293-1.37654-.0547-2.01614-.8707-2.0656-1.9827-.07147-1.588-.13187-3.1494-.81987-4.3534 3.76253-6.7374 8.14427-13.476 11.81693-20.0747.324-.58.168-.7413-.22533-.2427-4.64467 5.8787-9.44107 11.8654-14.34107 17.3854-.7792-.52-1.37546-1.24-1.9484-1.9974-.90986-1.2054-5.0932-4.6774-6.3912-5.06.076-1.68 3.8-13.8494 5.05934-18.248.29226-1.0214-.01707-.7334-.25614-.276-2.93333 5.6-5.50626 11.56-7.93493 17.3786-1.5276-.2293-3.55893-.3507-5.08653.8707-1.03907-.3067-2.01614-1.2827-2.5052-2.2.9844-5.6974 2.61986-13.8294 3.6204-19.4454.1796-1.0067.16346-1.8573-.3928-.132-1.6348 5.068-5.464 17.4613-6.514 19.0093-3.41614-1.288-7.52867-.76-11.07134-.2867-.65413-.5453-4.51253-13.18-7.074-20.6787-.31093-.9134-.676-1.4894-.37973.088 1.1532 6.1187 3.87973 21.0947 3.05427 21.62932-1.46667-1.528-7.25574-4.20137-9.28707-4.584-2.96187-5.8673-4.7916-12.278-7.21147-18.4327-.276-.70266-.53426-.656-.36613.06 1.41827 6.024 3.20107 11.91867 3.91147 18.252-1.25254 1.17867-2.7484 1.69067-4.22134 2.288-1.18493.47867-3.82866 2.03467-5.4328 4.12667-3.37493-4.888-6.42973-10.2853-9.54693-15.304-.37333-.604-.64573-.4813-.36507.2227 2.46934 6.2 6.24694 18.19864 6.24694 18.19864-6.75987-3.116-11.59694 2.5894-16.30627 6.672-1.0604.92-1.5828.684-2.27507.3-4.4984-2.5026-8.2452-6.8213-12.32653-10.3653-.3464-.3-.58533-.1746-.31306.212 3.2683 4.6427 10.1595 12.0307 10.4204 12.2787.8479.7973 1.523 1.7933 1.6146 2.756-4.0322 1.772-7.1489 6.1707-12.0364 5.316-4.0469-2.5227-7.4609-6.8533-10.8255-10.1947-.5468-.5426-1.1619-.8866-.3994.156 2.7328 3.7414 9.1428 12.544 10.4917 14.6827-1.5276 4.0933-2.9937 9.0413-1.3437 13.5026-1.3448 1.2813-2.139 2.704-2.9333 4.276-6.0167-.764-12.2313-1.188-18.3776-1.708-.7182-.06-.8619.168-.2213.3386 5.7135 1.532 11.2296 2.8347 17.4385 4.7307-.1224 4.1546 1.8015 7.8973 3.6656 11.4253-.1724.3106-.7177 1.0533-1.3286 1.2066-3.3598.2853-13.5755.68-18.8646.9933-1.8052.1067-1.5885.4787-.4515.528 7.4625.324 18.3235 1.244 18.3235 1.244 1.527 3.2387.9161 7.7587-.6115 10.8747-5.5319 2.2027-11.4173 3.7787-17.0897 5.5134-1.4073.4293-1.6391.9413.9744.3987 6.7901-1.4106 18.536-3.736 20.6787-2.0586.8219.6413 6.6058 10.5413 1.7298 14.9053-5.3693 1.872-14.2719 4.412-19.5391 6.384-1.2651.472-1.1922.8813.262.5506 7.5589-1.7173 21.049-4.736 21.049-4.736 1.7109 5.0107 6.2317 8.92 11.12027 10.5707-4.0629 6.004-7.6292 13.2827-11.1661 19.7494-.6005 1.0987-.4197 1.6253.59178.064 4.2952-6.6333 8.84378-13.1267 13.69058-19.5693 1.34426 3.29864 4.0937 6.232 6.7213 8.676-3.526 5.74264-8.4629 10.944-12.92903 16.324-.95264 1.148-1.50944 2.2613.45576.44264 5.8672-5.4307 17.9749-16.2787 21.2713-16.46.64267.84265 1.84787 2.844 2.50467 3.5733.2292 1.14663-3.03022 15.964-4.9609 23.90663-.2667 1.1.0136 1.164.4036.08268 2.699-7.4626 5.1958-15.0493 8.3463-22.3093 0 0 9.04217.97736 10.7527 2.628-2.2111 5.80936-5.5032 11.1427-8.4939 16.584-.5629 1.02536-.2462 1.3067.4339.408 4.6547-6.148 8.7152-12.51864 13.1928-18.70264 0 0 1.16097.38 1.32857.6867.3147.57333-2.3604 10.87066-3.8946 16.80266-.5595 2.1627-.11 2.1134.3394.9014 2.21-5.956 3.8563-12.104 7.35893-17.536 3.66612.7947 6.53745-1.284 9.95932-1.588 3.8636 3.968 6.2136 8.808 8.75893 13.48537.3932.724.68372.544.3916-.2493-2.04428-5.56137-5.0645-10.8067-6.40108-16.4747 2.74948.184 5.43748.4267 7.33175 2.628 2.3532 4.552 5.0053 9.01735 7.7073 13.4347.52503.8587.8693.8587.43703-.128-2.4579-5.608-6.2772-13.4346-6.3235-13.6266-.3797-1.536.6162-1.9507 1.9178-2.1614 3.2244-.5173 6.3124-2.53866 7.5651-5.4613 1.0995-.3067 2.4443-1.2227 3.5437-.24535 4.5678 4.0653 8.6807 8.832 12.8156 13.0133.8984.908 1.7699 1.41865.3776-.3707-3.4781-4.47466-9.815-12.5733-11.5666-14.4613 3.338-.46 5.80105-4.044 9.4885-3.6307.1823.02137 11.4175 3.688 16.8815 5.47337 1.75866.5733 1.0493.0186.112-.4387-6.0027-2.9427-12.068-5.748-17.72214-9.6067.1839-1.45068.26-2.672-.0452-4.352 4.582-.42668 7.49937-5.484 10.0047-8.6613 7.5973-.536 14.7253 1.412 22 2.6027 1.0333.1693 1.128-.1227.1013-.4334-6.872-2.08-14.7133-4.784-21.49064-6.64536-.152-2.5213-.1827-4.56667-1.16-7.43867 4.276-4.216 5.74267-10.8747 3.4813-16.5587 1.72668-1.74 3.3-3.0547 5.01068-4.3987 0 0 15.51336 4.552 20.556 5.6627.972.2147 1.052-.14264.176-.492"\n    }\n  })])]), _vm._v(" "), _c(\'div\', {\n    staticClass: "info"\n  }), _vm._v(" "), _c(\'div\', {\n    staticClass: "actions"\n  }, [_c(\'span\', {\n    ref: "settings",\n    staticClass: "settings",\n    on: {\n      "click": _vm.toggleMenu\n    }\n  }, [_c(\'svg\', {\n    ref: "dots",\n    attrs: {\n      "width": "24",\n      "height": "24"\n    }\n  }, [_c(\'path\', {\n    attrs: {\n      "fill": "none",\n      "d": "M0 0h24v24H0z"\n    }\n  }), _c(\'path\', {\n    attrs: {\n      "d": "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"\n    }\n  })])]), _vm._v(" "), _c(\'menu-items\')], 1)])])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require("vue-hot-reload-api").rerender("data-v-2d6eb886", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3RvcGJhci52dWU/ZGVjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJUb3BiYXJcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ3cmFwcGVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibG9nb1wiXG4gIH0sIFtfYygnc3ZnJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIFwidmlld0JveFwiOiBcIjAgMCAxNjguMjQwNDYgMTY2LjY2NzAxXCJcbiAgICB9XG4gIH0sIFtfYygncGF0aCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJmaWxsXCI6IFwiIzIxMWMxZFwiLFxuICAgICAgXCJkXCI6IFwiTTE0MC44NTA4IDgwLjUyNTQyYy0uMjEyLTEuMDIyNjctLjYxMDY2LTEuODMzMzMtLjQyNjY2LTIuNzUwNjcgMS4yODI2Ni4yNDUzNCAyLjUwNTMzLjUwNTM0IDMuODQ5MzMuNzM0NjctLjczMzMzLjY3Mi0xLjY0OTMzIDEuNjAyNjctMy40MjI2NyAyLjAxNnptLTEuMzY5MzMtMjIuNTI4Yy0uODM4NjctLjI5NDY3LTEuNjItLjk5NzMzLTEuOTkwNjctMS43ODkzMyAzLjQ1MDY3LS44NzYgNi45NDgtMS41NTYgMTAuNDA2NjctMi4zNDY3LjQwMjY3LS4wOTIuODE4NjctLjA3NzQuMjA0LjI0MTMtMi4zMzYgMS4yMTYtOC4wMDggNC4xMDgtOC42MiAzLjg5NDZ6bS00LjE5MDY3IDM3LjYyYy0xLjA5ODY2LTIuMjYxMzQtLjE4MjY2LTUuNDM4NjctMS4yODI2Ni03Ljc2Ljc5NDY2LTEuOTU2LjczMzMzLTQuMjc3MzMgMS43NzItNi4xNzA2NyAxLjQ2NjY2IDQuMjc2IDMuNjY1MzMgMTAuMjA0LS40ODkzNCAxMy45MzA2N3ptLTYuNTk4IDE5LjY3MzMzYy0uMTk4NC0xLjY0OTMzLS40ODkwNi0zLjA1NDY3LS4yNDQ4LTQuNTIxMzMgMS4zNDQyNy0zLjE3NiAzLjYzNi02LjIxNiA0Ljk0OTQ3LTkuMTA0bDEuNDY2NjcgNi43MjEzM2MtMS44OTQ2NyAyLjM4MjY3LTIuNjI3MDcgNi4yMzMzMy02LjE3MTM0IDYuOTA0em0tNS4xMzI4LTYuNzIxMzNjLTQuODg3NDYtLjM2NTM0LTkuNjUzMDYtMS4wOTg2Ny0xNC40ODAxMy0xLjY0OTM0LS4xMzM4Ny0xLjExMzMzLS4xNjk4Ny0yLjI5Mi0uMzQ1MzMtMy40Mzg2Ni0uMDY1MDctLjQyOC0uMzcwNC0uNTQ4LS4zOTIyNy0uMTQ5MzQtLjA2MDkzIDEuMDk0NjctLjE2MzQ3IDIuMzE0NjctLjE2MzQ3IDMuNDM0NjctMi40NDQyNi0uMDU4NjctNC43MTk4Ni0uNTE3MzMtNy4xNjM2LS4xNTIgMi4xOTg5NCAxLjE2MjY3IDQuNzY1NiAxLjQwNTMzIDcuMTQ4IDIuMDc4Njd2Mi45MzJjLTIuOTMyNC0uODMwNjctNS45MTUyLTIuMDYxMzQtOC44NTc4Ni0yLjY0OTM0LS4zMDY4LS4wNjEzMy0uMzY2MTQuMjM0NjctLjA4MTc0LjQxNzM0IDIuNzI2NTQgMS43NjEzMyA2LjAwODI3IDIuNzQyNjYgOC45Mzk2IDQuMTI1MzMgMCAyLjk5NDY3IDAgNy40NTQ2Ny0uNDI3MDYgMTAuOTk4NjctMS4yNjA5NC4yNjY2Ni0yLjgzMTM0IDEuMTc4NjYtNC4yMTk4NyAxLjI4OC0uODMzMzMuMDY2NjYtMi45OTA2Ny0xLjk2LTMuNTQwMTMtMi4wMjEzNC0uMTAyIDEuMTcwNjcgMS44MzEzMyAyLjgwOC45MjY2NiA0LjAyOC0uMTgxODYuMjQ1MzQtMS43MzYuODc0NjctMi42OTkwNi42NzYtNC42MTc2LTMuMzc0NjYtOS4yMzQ4LTYuOTItMTQuMDE5NzQtOS44NjEzMy0uMTUzMi0uMDkzMzMtLjIzNjkzLjI4OTMzLS4wMzI4LjQ4MTMzIDQuMTIxMzQgMy44MzYgOC42NjY2NyA3LjEwNTM0IDEyLjE1ODggMTEuNzAyNjctLjY1NjguODU0NjctMS4zNDQyNiAxLjU4OC0yLjA3NzYgMi4zODI2Ny0yLjA3NjUzLTEuMDM4NjctNC41MzY0LTEuMjk4NjctNi44NDI2Ni0xLjY0OTM0LTIuOTc4MTQtNC4zNTczMy00LjY2MjU0LTkuMzEyLTcuMTE4OC0xMy45Mi0uMjY1MDctLjQ5NzMzLS42MDE0Ny0uNDUzMzMtLjQ3NDk0LjA1NzM0IDEuMTgxMiA0Ljc3MzMzIDMuMTcwMjcgOS40MjEzMyA0LjY2MDQgMTQuMTY4LTIuMzgyOC42MTA2Ni00LjQ1OTg2IDIuMTM4NjYtNi4xNzA4IDMuODQ5MzMtMi4wMTYxMy0xLjUyOC0zLjYwNTItMy4zLTUuMzE2MTMtNS4xMzMzMy4xMTI0LTUuOTg2NjcuNzg4LTExLjkyMTM0Ljk5NDY3LTE3Ljc1ODY3LjAxODgtLjUzNzMzLS4yMzE3NC0uNjMyLS4zODA2Ny0uMDgxMzMtMS42MTcyIDUuOTk0NjYtMy45NzQgMTYuNDk2LTMuOTc0IDE2LjQ5Ni0zLjIzODUzLjI0NTMzLTcuMTQ4NC45MTczMy0xMC4yNjQgMS41ODkzMy0uNTUwNTMtMS41ODkzMy0xLjQ1MTYtMi44NTczMy0zLjEwMTA3LTQuMjYyNjcgMy43NzI5NC00LjQ3MDY2IDcuODkwNjctMTAuMDggMTAuOTUwNTQtMTUuMDI2NjYuMjg0OTMtLjQ2MTM0LjEyNzYtLjY1Mi0uMjE4MjctLjI4NTM0LTMuOTMyMjcgNC4xNzA2Ny03LjU5NDI3IDkuMjkzMzQtMTIuMDMxMiAxMy4yODEzNC0zLjE3NzA3LS41NDkzNC01LjYyMDgtMy4xMTYtOS4zNDg0LTIuMzIxMzRsLjI0NDgtNC40YzQuMzYzNDctNC45NTIgOS4wNjc2LTguNTk2IDEzLjM0NTItMTMuMTI5MzMuMTU0OC0uMTY0LjE0NjkzLS41NTg2Ny0uMTk3ODctLjM0OTMzLTIuNzUgMS42OC0xMi43NSA3Ljc5Ni0xNS4xOTk0NiA5LjA4NTMzLTEuODI4NjctMi4yMTQ2Ny0zLjk4NjU0LTQuMS01Ljk2OTg3LTYuMTYgMi43MDA1My0uMjMyIDkuOTEzMDctLjQ1NDY3IDEzLjc2NTItLjU2MTMzIDIuMzg5Ni0uMDY2NjcgMi0uNzI4Ljg0MDEzLS45MDY2Ny0yLjA4MDgtLjMyMTMzLTExLjk4NDkzLTEuNjQtMTYuNDIwNC0xLjkwOC44NTA1NC0zLjAyOC45ODAyNy03LjAwMTMzLS4xMjI0LTkuOTYgNS40OTU4Ny0yLjMwOCAxMS45MzIyNy0yLjM0MjY3IDE4LjE1MTA3LTIuOTA0LjY5MzczLS4wNjQuNjMxNzMtLjM1Ni0uMDk0MjctLjQxODY3LTYuMzc3MDYtLjU1Ni0xMy4wMTkzMy0uNzEwNjYtMTkuMjE3NzMtMS4yNi0xLjUyNzYtMi41MDUzMy0yLjg3MTg3LTUuMDcwNjYtNS4wMTA0LTcuMzMyLjg1NjI3LTIuNjI4IDEuNTg4NTMtNS45ODggNC43MDUyLTcuMDI2NjYgNi42ODAyNy0yLjIyNjY3IDE0LjA1NDY3LTIuOCAyMC43NzU2LTQuOTYuNDcxMzMtLjE1MDY3LjM2MjQtLjM5MDY3LS4xNjM2LS4zNTA2Ny03LjIxMzA3LjUzNzM0LTE1LjAzNjkzLjQ4NC0yMi4zODQ0LjQ4NC0xLjI4MjI3LS43OTQ2Ni0yLjA3NjUzLTIuMzIxMzMtMi42MjY1My0zLjY2NTMzIDEuMjgyMjYtMi41NjY2NyAzLjExNTYtNC44MjggNS4xMzE3My03LjAyOCAxLjQzMTMzLTEuMzI1MzMgMy41NTE2LTEuOTYgNS40NDQyNy0xLjUwNjY3LjI0ODUzLjA2IDEwLjI5NDI2IDMuNDI2NjcgMTcuMTUxMDYgNS41MzczNCAxLjEyNzYuMzQ4IDEuMjQzNzQuMDU2LjMzMDI3LS4zODk0LTYuMDE5MzMtMi45MjY3LTEyLjEwNDgtNi4yLTE4LjA5ODUzLTkuMzg0IDIuMDI2NjYtMi4xODI3IDIuMDg5MDYtNS43MzIgMy40NTQyNi04LjI1NDcuNjgwMTQtMS4yNTYgNC42NC0zLjAxNzQgNS4yMTU2LTMuMTQ4IDUuNjYxNDctMS4yOTYgOC44NTI1NC0xLjMyOCAxMS40MzIyNy02LjE5NDcgNS4zMTU2LjkxNzMgNC4yNzkyIDE1LjYwNTMgNC40NTI1MyAxNy44MDkzLjA1LjY0MjYuNDY0NjcuNTc4Ni41MDI2Ny0uMDc4Ny4yOTY5My01LjEzNzQuMzM1NDctMTAuODEyIDEuMDkzNzMtMTUuOTU3NCA2LjY5MDE0LjM4MTQgMTMuOTkxNzQtNC4xNTQ2IDE2LjM3NDU0LTUuMDEwNi0uMzU4NCA3LjAxMDYtMS40NDUzNCAxMy44NDkzLTIuMjkxMiAyMC41ODgtLjE2NCAxLjMwOC4yNjI1MyAxLjMyMTMuNTg5Ni4wMTIgMS41NTEwNi02LjE5MzQgMi42NzE4Ni0xMi41NzQ3IDQuMDg0NC0xOC44MjggMS4zNTc3My0uNjQgMi40MDE2LjIzNDYgMy41MjQ5My45NjggMS40NTk0Ny45NTMzIDQuOTY3NzMgMS4zNTMzIDQuOTY3NzMgMS4zNTMzIDEuMzIwOCA3LjE4MTMgMi43NTA1NCAxNC4zNjI3IDQuMzkwMTQgMjEuMzkwNy4yNDg0IDEuMDY5My42MzkwNi43NzA2LjU1MzYtLjQ1ODctLjI2OTc0LTMuODczNC0xLjI2NC0xOC41MDE0LTEuMDc2NTQtMjEuMDUyIDEuNzMwOC0uNTA1NCAzLjY3ODE0LTEuMTc3NCA1LjA1MzA3LTEuOTQyNyAxLjU3NzczIDIuMjY1MyA0LjI4NiA0Ljc5NDYgNC4zOTk2IDcuNjg0LS44NjIgNi4zMDI2LTIuNjI2NjcgMTIuNDE0Ni0zLjkxMDUzIDE4LjUwNC0uMTcyNC44MTczLjEyNDUzLjkyNjYuNDE2MjYuMTU3MyAyLjA5NDY3LTUuNTM4NyAzLjcxNDU0LTExLjI4IDYuMTgyOC0xNi42NDU0LjUxMDk0LS42NTc0IDEuMjYzNDctLjYzNzQgMi4wMjA4LS40NzYuNTA4MjcuMTA4IDUuMTI3NiAyLjYxNDYgNy4zMjc2IDIuODU4Ni4zNjY2NyAzLjY2NjcgMi4xOTg5NCA3LjUxNiA1Ljc0MjY3IDkuMDQyNyAwIDAtNi42NzY1MyA5LjQ1NDYtMTAuMjkxNiAxNC44MjkzLS43Mjc2IDEuMDgyNi0uNTEwNCAxLjE0NC40MzAxMy4yNjY2IDQuNTU4OTQtNC4yNTA3IDcuNjY2NjctOS4wNjY3IDEyLjc5NDI3LTEyLjcxMzQtLjc5NDI3IDEuNTI5My0uNjcxODcgMy42NjY3LS45MTY2NyA1LjI1Ni00LjQ4Mzg2IDMuMjgxMy05LjA2NjEzIDYuNjA5My0xMy41MjY1MyA5Ljc3MDctLjUyMzQ3LjM3MDYtLjM1NzczLjU5Mi4yNDQ4LjMyMjYgNC41MzEyLTIuMDIyNyA5LjA4MDI3LTQuNDg2NyAxMy43NzEzMy02LjQyNjcuMzY2MTQgMS40OC44NTQ2NyAyLjEzNzMgMS41ODggMy4xMTQ2LTEuNTg4LjYxMDYtMy40MjEzMy41NDkzLTUuMDEwNCAxLjE2MTMgMS44OTQyNy44NTQ3IDQuMTU0NjcuNjcyIDYuMTcxODcgMS4xNjEzLS4zMDYyNyAxLjg5MzMgMS4yODIyNyAzLjIyMTMgMi4xOTg5MyA0LjI3NzMtLjg1NTYgMi42ODY2LTIuNTA1MiA1LjAwOTMtMi41MDUyIDguMDYzOTItNS41MTQ1My0uNzcyLTExLjIyOTYtMi4wNDI2Ni0xNi42MDQxMy0zLjQwNTMtLjU3OTItLjE0OC0uNjM3NDcuMTA5My0uMDg1MzMuMzcyIDQuOTQ3ODYgMi4zNDY2MyAxMC4zNTA0IDMuOTU3MyAxNS40MDY2NiA2LjIxMiAyLjE5OTQ3IDIuMzIxMy43OTQyNyA2LjEwOCAyLjAxNjE0IDguNzk3My01LjA2MDQtMi45NDEzLTkuNDQtNy43NTQ2Ny0xMy45NTg4LTEyLjA5MDY3LS4xNzQtLjE2NjctLjQxNC4wNTA2LS4yNjUwNy4yNjEzIDMuODI3NiA1LjQxMDY1IDkuMTUgMTAuMDk2IDEyLjIwNzczIDE1Ljh6bS4zMDU3NCAxNi45ODUzM2MtMy40NjcyIDIuOTgtNy44ODE3NCAzLjU0NTMzLTcuODgxNzQgMy41NDUzM2wxLjg5NDI3LTQuMTU2IDMuNjY1Ni0zLjE3NzMzYy41NS4wNjI2NyAxLjY1LS4xODI2NyAyLjUwNTItLjMwNC4xMjI0IDEuNjQ4LS4wNjA5MyAyLjY0MjY3LS4xODMzMyA0LjA5MnptLTE0LjQ4MDE0LTE2LjU1NmwxMy4xOTczNCAzLjIzNzMzYzEuMDM5MDYuOTE3MzQgMS4wMzkwNiAyLjgxMDY3LjU0OTQ2IDMuOTEwNjdoLTIuMDE1NmwtMTEuNDg2OTMtMy45MTA2N3ptMi40NDMyIDE2LjI1MmMtLjczMjI2LS4zNjUzMy0xLjU4NzQ2LS45MTczMy0xLjU4NzQ2LTEuODk0NjdsLS42MTE0Ny05LjIyNjY2IDcuMjA5MzMgMi42MjhjLjkwNzg3IDEuMTc4NjYuNDUyNjcgMS44OTYtLjM1IDIuNTE3MzMtLjgxNzczLjYzNDY3LTMuODgwNjYgNC4xNDI2Ny00LjY2MDQgNS45NzZ6bS0zLjI4MTczIDEwLjE4MjY3Yy0uMzIzNDcuMDgyNjYtMy45MjcyLjMyNjY2LTUuMDI3NiAxLjEyMTMzbC0zLjk3MTQ3LTEuMDRjLjkxNjY3LTIuNDQ0IDQuMzM4MTQtMi4yNiA1LjU2MDU0LTQuNzA0bDMuNjY1MDYtLjk3ODY3YzEuMTYyLjMwNjY3IDIuMjMxMi42ODggMy41NDQ4Ljk3ODY3LTEuNDY0NjYgMS40NjQtMS43MjEzMyA0LjA5MDY3LTMuNzcxMzMgNC42MjI2N3ptLTE3LjA2NDEzIDMuMzJjLTMuMDU0MTQuODU2LTYuMzU0NjcgMS45NTYtOS43MTQ1NCAxLjM0NC44NTU3NC0xLjU4OCAyLjY4OC0yLjgxMDY3IDQuMzk4OTQtMy4yMzczNGw1LjQzODUzLjg1NDY3em0tMTcuMTMxMiAxLjkwNjY2Yy0uNDM4LS4yMTczMy03LjI0NzQ3LTIuMDI5MzMtMTAuNDI0NTQtMi4yMTJsLTIuMzgzMzMtMi42MjY2NmMyLjYyNzYtLjU1MDY3IDUuMzc3Ni0uNjcyIDguMDY1Ni0xLjA0IDEuNjQ5NDcgMi4yIDMuOTEgMy42MDY2NiA1Ljg2NTczIDUuNDQtLjMyNjEzLjY4LS43MS42NDI2Ni0xLjEyMzQ2LjQzODY2em0tMjMuMDcxMzQtNi40MjhjLTIuMzgyOTMtMS42NDkzMy00LjA5NDgtNC4xNTQ2Ni01LjQzODUzLTYuNDc2IDIuNTA1Mi0xLjE2MTMzIDUuNTkwNTMuMzIgNi41OTg0IDEuODk0NjdsMi4yIDMuNTQyNjd6bS0xOS45MTg4LTE4LjA4NTMzYy45NzY1NC0yLjMxNDY3LjUyNDk0LTUuMTQ2NjcuMjQ4OTQtNy43NjkzMy0uMDUyNTQtLjQ5Ni4xMjE4Ni0uNTcyLjM0MTczLS4xMTYgMS43OTA1MyAzLjcyMjY2IDcuNDIzMzMgNy45MjI2NiA3LjYzNDggOC4xMzczMyAyLjAzNDkzIDIuMDgxMzMtLjE0OTQ3IDUuMjQxMzMuOTk5NDcgNy44MTMzMy00LjE1NDE0LS43MzMzMy04LjI0Nzg3LTMuNzg4LTkuMjI0OTQtOC4wNjUzM3ptLTYuNzgyOC0yMC4wNDEzM2MuNTUwNTQtMi44NzIuODU1NzQtNi4xNjkzNC4zMDU3NC05LjEwMjY3bC45MTY2Ny0xLjM0NGMxLjM0MDcgMS45MzIgMy4yNDA3IDMuODEyIDQuMjcxOSA1Ljk3MDY3IDEuODY5MiAzLjkxMDY2IDEuNTc1IDYuNTgxMzMuNTU1MiAxMS44MDkzMy0xLjAzOS0yLjk5NDY3LTMuMy01Ljc0NC02LjA0OTQtNy4zMzMzM3ptLTEuNTg4NTMtMjQuMTk0NjdsMi4wNzc2LTMuNjY2NjZjLjc5NDI3IDEuNjQ5MyAxLjQ2NjEzIDMuNDIxMyAyLjkzMjggNC44MjgtMS4wMzggMS42NDgtMi4xOTk0NiAzLjI5ODYtMi41MDUyIDUuMjU0Ni0xLjIyMTg2LTEuODMzNC0yLjEzODUzLTQuMDk0Ny0yLjUwNTItNi40MTZ6bTUuNDM4NTMtMjEuNTY5MzNjMy41NDMyLS43MzMzMyA2LjI5MjY3LTMuMzYgOS4zNDc4Ny01LjMxNDY3LS4yNDQ4IDIuODcyLTIuODcxODcgNS4zNzYtMy4xNzcwNyA4LjU1MzM0LTMuMTc3MDYgMS42NDkzLTYuMTA5ODYgNS4wMTA2LTcuOTQzMiA4LjA2NTMtMS4wOTk0Ni00LjE1MzQgMS4yODMzNC03LjUxNDcgMS43NzI0LTExLjMwNHpNNTIuMzQ3MDcgMzMuMDAwMWMuMjI5Ni4wNDQgMi4wNDg0Ljc4NCAyLjkwNDY3LjYwMTMyLTEuMTU1NzQgMi4yNzMzMy0zLjI4OTA3IDIuNjgyNjctNS40ODQ0IDMuMDAxMzMtMi42MTM2LjM4MjY3LTYuMDQwNjcgMi4wODEzNC04LjE4NzQ3IDMuNjQyNjdsLS4xMzcwNy0uNTk0NjdjMy42MDY4LTIuMzg1MzMgNi4zMjc2LTcuNDg1MzMgMTAuOTA0MjctNi42NTA2NnptMTAuMDA3Mi0zLjkwNTM1YzMuOTc2MTMtNi40OTQ2NiAxMi4wNDE3My02LjQ4NCAxNy4xODQ0LS44NC02LjU2OTIgNS4zNDY2Ny0xNC40NSA0LjE4NC0xNC40NSA0LjE4NC0xLjQ2NjY3LTEuMDM3MzMtMy4xNzc2LTEuNTg4LTUuMDEwNC0xLjc2OTMzLjQyNzA3LS40OTA2NyAxLjU0MjEzLTEuMjA4IDIuMjc2LTEuNTc0Njd6bTM0LjYwNDI3LTEuNTM3MzNjLjQ3NTQ2LjMzODY3IDMuMDE3NiAyLjM3ODY3IDMuMDE3NiAyLjM3ODY3LTMuMTc3MDcgMy42NjUzLTEyLjUyODE0IDEuNTM3My0xNS4wOTE2LTIuMjAxNCA2LjkzMDY2LTIuODc0NyAxMC42NDc4Ni0xLjE5NiAxMi4wNzQtLjE3NzR6bTIwLjMwODggMTAuMzIxMzNsLjczMzMzIDMuMjM3MzRjLTIuMDc4MTMtMS4xLTQuMTU0NjctMi4xOTg3LTYuNTk4OTMtMi4zODI3LTEuNDY2MTQtMi44NzItNC4wOTM3NC01LjU2MTQtNi4xNzA5NC04LjM3MDcgMi44NzE0Ny0uODU0NyA3LjA3Mi0uMTk3NCAxMi4wMzY1NCA3LjUxNnptNy4wMjY1MyA5LjIyNjY3bDIuOTMyOC4xMmMxLjQwNDY3IDEuNzczMzMgMS44NzkyIDMuNzg4IDIuMTk4OTMgNi4wNDkzMy0xLjM0MzczLS44NTQ2Ni01LjQzNzQ2LTEuOTU0NjYtNS4xMzE3My02LjE2OTMzem04LjU1MzYgMTEuODUyYzEuMjgzMzMgMS4zNDQgMi41NjczMyAzLjM2MTMzIDQuMzk5MzMgMy44NDkzMy4xODI2NyAzLjI5ODY3LS4yNDQgNy4wODY2Ny0xLjM0NCAxMC4yNjUzNC0xLjM0NTMzLS4yNDU0LTIuNzQ0MjYtNS41Njk0LTMuMzMxMzMtNi44LTEuNTk3MzMtMy4zNTYuMjc2LTcuMzE0Ny4yNzYtNy4zMTQ3em0zNC43ODQ2NiAyNS4yNzJjLTQuNjEyLTEuODM3MzMtMTkuMTQyNjYtNi40NTQ2Ny0xOS4xNDI2Ni02LjQ1NDY3IDIuMTUyLTEuOTUzMzMgNC41OTQ2Ny0zLjY1ODY2IDYuNjQ5MzMtNS42OTA2Ni40NTA2Ny0uNDQ4LjI3Ni0uNzAyNy0uMjMyLS4zNTQ3LTIuNzE2IDEuODY0LTUuNDA5MzMgMy43MzYtOC4xODkzMyA1LjQzNi0yLjAxNi0uNzMzNC0zLjQ4MjY3LTEuNDgyNy01Ljk4OC0yLjYyOCAyLjEzODY3LTQuMjE2LjkxNi05LjQwOTQgMi41MDUzMy0xMy42MjRsMTIuMDM2LTguOTgxNHM0LjY2LTEuMjA4IDYuNTI1MzMtMS41OTQ3YzEuOTA0LS4zOTM0IDIuMDQ1MzQtLjczMi4wNjUzNC0uNTg0LTEuNDU3MzQuMTA4LTMuNDMwNjcuMzczMy00LjIuNDEyIDEuMDMyLS44MTg3IDIuMzA1MzMtMS43NDQgMy4yMzQ2Ni0yLjY0NC4yNTItLjI0NC4zNDI2Ny0uNTQ0LS4xNzczMy0uMjYtMi4wNCAxLjExMzMtNy4wNjUzMyAzLjg1NDYtNy4xNjY2NiAzLjg3MDYtNi4yNzg2Ny45NDkzLTE4LjA1MDY3IDMuMTI2Ni0xOC45NDI2NyAxLjEzMzMtMS4wNDUzMy0yLjMzMDctMS40MTQtNC45OTA3LTIuMzcyNC03LjM2MTQgNS42ODMwNy02Ljk3ODcgMTMuMTgzMDctMTIuNDAxNCAxOS40ODg0LTE3Ljk0MjcuNTQtLjQ3MzMuNDM0NjctLjg0MTMtLjctLjA4MTMtNS42NTczMyAzLjc4OTMtMjIuMTMgMTUtMjIuNTI3NDcgMTUuMDI2Ni0xLjIwMzA2LjA4NjYtMy4zNDg0LjIzNi0zLjUxODY2LjIyOTMtMS4zNzY1NC0uMDU0Ny0yLjAxNjE0LS44NzA3LTIuMDY1Ni0xLjk4MjctLjA3MTQ3LTEuNTg4LS4xMzE4Ny0zLjE0OTQtLjgxOTg3LTQuMzUzNCAzLjc2MjUzLTYuNzM3NCA4LjE0NDI3LTEzLjQ3NiAxMS44MTY5My0yMC4wNzQ3LjMyNC0uNTguMTY4LS43NDEzLS4yMjUzMy0uMjQyNy00LjY0NDY3IDUuODc4Ny05LjQ0MTA3IDExLjg2NTQtMTQuMzQxMDcgMTcuMzg1NC0uNzc5Mi0uNTItMS4zNzU0Ni0xLjI0LTEuOTQ4NC0xLjk5NzQtLjkwOTg2LTEuMjA1NC01LjA5MzItNC42Nzc0LTYuMzkxMi01LjA2LjA3Ni0xLjY4IDMuOC0xMy44NDk0IDUuMDU5MzQtMTguMjQ4LjI5MjI2LTEuMDIxNC0uMDE3MDctLjczMzQtLjI1NjE0LS4yNzYtMi45MzMzMyA1LjYtNS41MDYyNiAxMS41Ni03LjkzNDkzIDE3LjM3ODYtMS41Mjc2LS4yMjkzLTMuNTU4OTMtLjM1MDctNS4wODY1My44NzA3LTEuMDM5MDctLjMwNjctMi4wMTYxNC0xLjI4MjctMi41MDUyLTIuMi45ODQ0LTUuNjk3NCAyLjYxOTg2LTEzLjgyOTQgMy42MjA0LTE5LjQ0NTQuMTc5Ni0xLjAwNjcuMTYzNDYtMS44NTczLS4zOTI4LS4xMzItMS42MzQ4IDUuMDY4LTUuNDY0IDE3LjQ2MTMtNi41MTQgMTkuMDA5My0zLjQxNjE0LTEuMjg4LTcuNTI4NjctLjc2LTExLjA3MTM0LS4yODY3LS42NTQxMy0uNTQ1My00LjUxMjUzLTEzLjE4LTcuMDc0LTIwLjY3ODctLjMxMDkzLS45MTM0LS42NzYtMS40ODk0LS4zNzk3My4wODggMS4xNTMyIDYuMTE4NyAzLjg3OTczIDIxLjA5NDcgMy4wNTQyNyAyMS42MjkzMi0xLjQ2NjY3LTEuNTI4LTcuMjU1NzQtNC4yMDEzNy05LjI4NzA3LTQuNTg0LTIuOTYxODctNS44NjczLTQuNzkxNi0xMi4yNzgtNy4yMTE0Ny0xOC40MzI3LS4yNzYtLjcwMjY2LS41MzQyNi0uNjU2LS4zNjYxMy4wNiAxLjQxODI3IDYuMDI0IDMuMjAxMDcgMTEuOTE4NjcgMy45MTE0NyAxOC4yNTItMS4yNTI1NCAxLjE3ODY3LTIuNzQ4NCAxLjY5MDY3LTQuMjIxMzQgMi4yODgtMS4xODQ5My40Nzg2Ny0zLjgyODY2IDIuMDM0NjctNS40MzI4IDQuMTI2NjctMy4zNzQ5My00Ljg4OC02LjQyOTczLTEwLjI4NTMtOS41NDY5My0xNS4zMDQtLjM3MzMzLS42MDQtLjY0NTczLS40ODEzLS4zNjUwNy4yMjI3IDIuNDY5MzQgNi4yIDYuMjQ2OTQgMTguMTk4NjQgNi4yNDY5NCAxOC4xOTg2NC02Ljc1OTg3LTMuMTE2LTExLjU5Njk0IDIuNTg5NC0xNi4zMDYyNyA2LjY3Mi0xLjA2MDQuOTItMS41ODI4LjY4NC0yLjI3NTA3LjMtNC40OTg0LTIuNTAyNi04LjI0NTItNi44MjEzLTEyLjMyNjUzLTEwLjM2NTMtLjM0NjQtLjMtLjU4NTMzLS4xNzQ2LS4zMTMwNi4yMTIgMy4yNjgzIDQuNjQyNyAxMC4xNTk1IDEyLjAzMDcgMTAuNDIwNCAxMi4yNzg3Ljg0NzkuNzk3MyAxLjUyMyAxLjc5MzMgMS42MTQ2IDIuNzU2LTQuMDMyMiAxLjc3Mi03LjE0ODkgNi4xNzA3LTEyLjAzNjQgNS4zMTYtNC4wNDY5LTIuNTIyNy03LjQ2MDktNi44NTMzLTEwLjgyNTUtMTAuMTk0Ny0uNTQ2OC0uNTQyNi0xLjE2MTktLjg4NjYtLjM5OTQuMTU2IDIuNzMyOCAzLjc0MTQgOS4xNDI4IDEyLjU0NCAxMC40OTE3IDE0LjY4MjctMS41Mjc2IDQuMDkzMy0yLjk5MzcgOS4wNDEzLTEuMzQzNyAxMy41MDI2LTEuMzQ0OCAxLjI4MTMtMi4xMzkgMi43MDQtMi45MzMzIDQuMjc2LTYuMDE2Ny0uNzY0LTEyLjIzMTMtMS4xODgtMTguMzc3Ni0xLjcwOC0uNzE4Mi0uMDYtLjg2MTkuMTY4LS4yMjEzLjMzODYgNS43MTM1IDEuNTMyIDExLjIyOTYgMi44MzQ3IDE3LjQzODUgNC43MzA3LS4xMjI0IDQuMTU0NiAxLjgwMTUgNy44OTczIDMuNjY1NiAxMS40MjUzLS4xNzI0LjMxMDYtLjcxNzcgMS4wNTMzLTEuMzI4NiAxLjIwNjYtMy4zNTk4LjI4NTMtMTMuNTc1NS42OC0xOC44NjQ2Ljk5MzMtMS44MDUyLjEwNjctMS41ODg1LjQ3ODctLjQ1MTUuNTI4IDcuNDYyNS4zMjQgMTguMzIzNSAxLjI0NCAxOC4zMjM1IDEuMjQ0IDEuNTI3IDMuMjM4Ny45MTYxIDcuNzU4Ny0uNjExNSAxMC44NzQ3LTUuNTMxOSAyLjIwMjctMTEuNDE3MyAzLjc3ODctMTcuMDg5NyA1LjUxMzQtMS40MDczLjQyOTMtMS42MzkxLjk0MTMuOTc0NC4zOTg3IDYuNzkwMS0xLjQxMDYgMTguNTM2LTMuNzM2IDIwLjY3ODctMi4wNTg2LjgyMTkuNjQxMyA2LjYwNTggMTAuNTQxMyAxLjcyOTggMTQuOTA1My01LjM2OTMgMS44NzItMTQuMjcxOSA0LjQxMi0xOS41MzkxIDYuMzg0LTEuMjY1MS40NzItMS4xOTIyLjg4MTMuMjYyLjU1MDYgNy41NTg5LTEuNzE3MyAyMS4wNDktNC43MzYgMjEuMDQ5LTQuNzM2IDEuNzEwOSA1LjAxMDcgNi4yMzE3IDguOTIgMTEuMTIwMjcgMTAuNTcwNy00LjA2MjkgNi4wMDQtNy42MjkyIDEzLjI4MjctMTEuMTY2MSAxOS43NDk0LS42MDA1IDEuMDk4Ny0uNDE5NyAxLjYyNTMuNTkxNzguMDY0IDQuMjk1Mi02LjYzMzMgOC44NDM3OC0xMy4xMjY3IDEzLjY5MDU4LTE5LjU2OTMgMS4zNDQyNiAzLjI5ODY0IDQuMDkzNyA2LjIzMiA2LjcyMTMgOC42NzYtMy41MjYgNS43NDI2NC04LjQ2MjkgMTAuOTQ0LTEyLjkyOTAzIDE2LjMyNC0uOTUyNjQgMS4xNDgtMS41MDk0NCAyLjI2MTMuNDU1NzYuNDQyNjQgNS44NjcyLTUuNDMwNyAxNy45NzQ5LTE2LjI3ODcgMjEuMjcxMy0xNi40Ni42NDI2Ny44NDI2NSAxLjg0Nzg3IDIuODQ0IDIuNTA0NjcgMy41NzMzLjIyOTIgMS4xNDY2My0zLjAzMDIyIDE1Ljk2NC00Ljk2MDkgMjMuOTA2NjMtLjI2NjcgMS4xLjAxMzYgMS4xNjQuNDAzNi4wODI2OCAyLjY5OS03LjQ2MjYgNS4xOTU4LTE1LjA0OTMgOC4zNDYzLTIyLjMwOTMgMCAwIDkuMDQyMTcuOTc3MzYgMTAuNzUyNyAyLjYyOC0yLjIxMTEgNS44MDkzNi01LjUwMzIgMTEuMTQyNy04LjQ5MzkgMTYuNTg0LS41NjI5IDEuMDI1MzYtLjI0NjIgMS4zMDY3LjQzMzkuNDA4IDQuNjU0Ny02LjE0OCA4LjcxNTItMTIuNTE4NjQgMTMuMTkyOC0xOC43MDI2NCAwIDAgMS4xNjA5Ny4zOCAxLjMyODU3LjY4NjcuMzE0Ny41NzMzMy0yLjM2MDQgMTAuODcwNjYtMy44OTQ2IDE2LjgwMjY2LS41NTk1IDIuMTYyNy0uMTEgMi4xMTM0LjMzOTQuOTAxNCAyLjIxLTUuOTU2IDMuODU2My0xMi4xMDQgNy4zNTg5My0xNy41MzYgMy42NjYxMi43OTQ3IDYuNTM3NDUtMS4yODQgOS45NTkzMi0xLjU4OCAzLjg2MzYgMy45NjggNi4yMTM2IDguODA4IDguNzU4OTMgMTMuNDg1MzcuMzkzMi43MjQuNjgzNzIuNTQ0LjM5MTYtLjI0OTMtMi4wNDQyOC01LjU2MTM3LTUuMDY0NS0xMC44MDY3LTYuNDAxMDgtMTYuNDc0NyAyLjc0OTQ4LjE4NCA1LjQzNzQ4LjQyNjcgNy4zMzE3NSAyLjYyOCAyLjM1MzIgNC41NTIgNS4wMDUzIDkuMDE3MzUgNy43MDczIDEzLjQzNDcuNTI1MDMuODU4Ny44NjkzLjg1ODcuNDM3MDMtLjEyOC0yLjQ1NzktNS42MDgtNi4yNzcyLTEzLjQzNDYtNi4zMjM1LTEzLjYyNjYtLjM3OTctMS41MzYuNjE2Mi0xLjk1MDcgMS45MTc4LTIuMTYxNCAzLjIyNDQtLjUxNzMgNi4zMTI0LTIuNTM4NjYgNy41NjUxLTUuNDYxMyAxLjA5OTUtLjMwNjcgMi40NDQzLTEuMjIyNyAzLjU0MzctLjI0NTM1IDQuNTY3OCA0LjA2NTMgOC42ODA3IDguODMyIDEyLjgxNTYgMTMuMDEzMy44OTg0LjkwOCAxLjc2OTkgMS40MTg2NS4zNzc2LS4zNzA3LTMuNDc4MS00LjQ3NDY2LTkuODE1LTEyLjU3MzMtMTEuNTY2Ni0xNC40NjEzIDMuMzM4LS40NiA1LjgwMTA1LTQuMDQ0IDkuNDg4NS0zLjYzMDcuMTgyMy4wMjEzNyAxMS40MTc1IDMuNjg4IDE2Ljg4MTUgNS40NzMzNyAxLjc1ODY2LjU3MzMgMS4wNDkzLjAxODYuMTEyLS40Mzg3LTYuMDAyNy0yLjk0MjctMTIuMDY4LTUuNzQ4LTE3LjcyMjE0LTkuNjA2Ny4xODM5LTEuNDUwNjguMjYtMi42NzItLjA0NTItNC4zNTIgNC41ODItLjQyNjY4IDcuNDk5MzctNS40ODQgMTAuMDA0Ny04LjY2MTMgNy41OTczLS41MzYgMTQuNzI1MyAxLjQxMiAyMiAyLjYwMjcgMS4wMzMzLjE2OTMgMS4xMjgtLjEyMjcuMTAxMy0uNDMzNC02Ljg3Mi0yLjA4LTE0LjcxMzMtNC43ODQtMjEuNDkwNjQtNi42NDUzNi0uMTUyLTIuNTIxMy0uMTgyNy00LjU2NjY3LTEuMTYtNy40Mzg2NyA0LjI3Ni00LjIxNiA1Ljc0MjY3LTEwLjg3NDcgMy40ODEzLTE2LjU1ODcgMS43MjY2OC0xLjc0IDMuMy0zLjA1NDcgNS4wMTA2OC00LjM5ODcgMCAwIDE1LjUxMzM2IDQuNTUyIDIwLjU1NiA1LjY2MjcuOTcyLjIxNDcgMS4wNTItLjE0MjY0LjE3Ni0uNDkyXCJcbiAgICB9XG4gIH0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpbmZvXCJcbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYWN0aW9uc1wiXG4gIH0sIFtfYygnc3BhbicsIHtcbiAgICByZWY6IFwic2V0dGluZ3NcIixcbiAgICBzdGF0aWNDbGFzczogXCJzZXR0aW5nc1wiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS50b2dnbGVNZW51XG4gICAgfVxuICB9LCBbX2MoJ3N2ZycsIHtcbiAgICByZWY6IFwiZG90c1wiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcIndpZHRoXCI6IFwiMjRcIixcbiAgICAgIFwiaGVpZ2h0XCI6IFwiMjRcIlxuICAgIH1cbiAgfSwgW19jKCdwYXRoJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImZpbGxcIjogXCJub25lXCIsXG4gICAgICBcImRcIjogXCJNMCAwaDI0djI0SDB6XCJcbiAgICB9XG4gIH0pLCBfYygncGF0aCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJkXCI6IFwiTTEyIDhjMS4xIDAgMi0uOSAyLTJzLS45LTItMi0yLTIgLjktMiAyIC45IDIgMiAyem0wIDJjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem0wIDZjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yelwiXG4gICAgfVxuICB9KV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdtZW51LWl0ZW1zJyldLCAxKV0pXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMmQ2ZWI4ODZcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP2lkPWRhdGEtdi0yZDZlYjg4NiEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9+L2VzbGludC1sb2FkZXIhLi9jb21wb25lbnRzL3RvcGJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9');
},/*!******************************************************************************************************************************************************************!*\
  !*** ../~/vue-loader/lib/template-compiler.js?id=data-v-5c3a67be!../~/vue-loader/lib/selector.js?type=template&index=0!../~/eslint-loader!./components/menu.vue ***!
  \******************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "Menu",\n    class: {\n      \'show\': _vm.menuActivity\n    }\n  }, [_c(\'ul\', _vm._l((_vm.menu_items), function(item, index) {\n    return _c(\'li\', {\n      staticClass: "menu_item",\n      class: {\n        \'active\': _vm.itemActivity === index\n      },\n      on: {\n        "click": function($event) {\n          _vm.setActivity(index)\n        }\n      }\n    }, [_vm._v("\\n\\t\\t\\t" + _vm._s(item.title) + "\\n\\t\\t")])\n  }))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require("vue-hot-reload-api").rerender("data-v-5c3a67be", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21lbnUudnVlP2Q1OTUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiTWVudVwiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnc2hvdyc6IF92bS5tZW51QWN0aXZpdHlcbiAgICB9XG4gIH0sIFtfYygndWwnLCBfdm0uX2woKF92bS5tZW51X2l0ZW1zKSwgZnVuY3Rpb24oaXRlbSwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ2xpJywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibWVudV9pdGVtXCIsXG4gICAgICBjbGFzczoge1xuICAgICAgICAnYWN0aXZlJzogX3ZtLml0ZW1BY3Rpdml0eSA9PT0gaW5kZXhcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS5zZXRBY3Rpdml0eShpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoXCJcXG5cXHRcXHRcXHRcIiArIF92bS5fcyhpdGVtLnRpdGxlKSArIFwiXFxuXFx0XFx0XCIpXSlcbiAgfSkpXSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNWMzYTY3YmVcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP2lkPWRhdGEtdi01YzNhNjdiZSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9+L2VzbGludC1sb2FkZXIhLi9jb21wb25lbnRzL21lbnUudnVlXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},/*!******************************************************************************************************************************************************************!*\
  !*** ../~/vue-loader/lib/template-compiler.js?id=data-v-764559c1!../~/vue-loader/lib/selector.js?type=template&index=0!../~/eslint-loader!./components/root.vue ***!
  \******************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "App"\n  }, [_c(\'topbar\'), _vm._v(" "), _c(\'main-area\')], 1)\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require("vue-hot-reload-api").rerender("data-v-764559c1", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3Jvb3QudnVlP2RhNDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiQXBwXCJcbiAgfSwgW19jKCd0b3BiYXInKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ21haW4tYXJlYScpXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNzY0NTU5YzFcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyLmpzP2lkPWRhdGEtdi03NjQ1NTljMSEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuLi9+L2VzbGludC1sb2FkZXIhLi9jb21wb25lbnRzL3Jvb3QudnVlXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==')},/*!******************************************************************************************************************************************************************!*\
  !*** ../~/vue-loader/lib/template-compiler.js?id=data-v-7fb69b18!../~/vue-loader/lib/selector.js?type=template&index=0!../~/eslint-loader!./components/main.vue ***!
  \******************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval('module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c(\'div\', {\n    staticClass: "Main"\n  }, [_c(\'div\', {\n    staticClass: "wrapper"\n  }, [_c(\'download\')], 1)])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require("vue-hot-reload-api").rerender("data-v-7fb69b18", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlPzdmMzEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiTWFpblwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIndyYXBwZXJcIlxuICB9LCBbX2MoJ2Rvd25sb2FkJyldLCAxKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTdmYjY5YjE4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci5qcz9pZD1kYXRhLXYtN2ZiNjliMTghLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi4vfi9lc2xpbnQtbG9hZGVyIS4vY29tcG9uZW50cy9tYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9')},/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ../~/vue-style-loader!../~/css-loader?sourceMap!../~/vue-loader/lib/style-rewriter.js?id=data-v-0daf62e7!../~/vue-loader/lib/selector.js?type=styles&index=0!../~/eslint-loader!./components/download.vue ***!
  \*****************************************************************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !./../../~/css-loader?sourceMap!./../../~/vue-loader/lib/style-rewriter.js?id=data-v-0daf62e7!./../../~/vue-loader/lib/selector.js?type=styles&index=0!./../../~/eslint-loader!./download.vue */ 11);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ./../../~/vue-style-loader/lib/addStylesClient.js */ 4)(\"5132a4ad\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-0daf62e7!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./../../node_modules/eslint-loader/index.js!./download.vue\", function() {\n     var newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-0daf62e7!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./../../node_modules/eslint-loader/index.js!./download.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Rvd25sb2FkLnZ1ZT84MzlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtMGRhZjYyZTchLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLy4uLy4uL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS4vZG93bmxvYWQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjUxMzJhNGFkXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi0wZGFmNjJlNyEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9kb3dubG9hZC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTBkYWY2MmU3IS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL2Rvd25sb2FkLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi92dWUtc3R5bGUtbG9hZGVyIS4uL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtMGRhZjYyZTchLi4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4uL34vZXNsaW50LWxvYWRlciEuL2NvbXBvbmVudHMvZG93bmxvYWQudnVlXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==")},/*!*************************************************************************************************************************************************************************************************************!*\
  !*** ../~/vue-style-loader!../~/css-loader?sourceMap!../~/vue-loader/lib/style-rewriter.js?id=data-v-7fb69b18!../~/vue-loader/lib/selector.js?type=styles&index=0!../~/eslint-loader!./components/main.vue ***!
  \*************************************************************************************************************************************************************************************************************/
function(module,exports,__webpack_require__){eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(/*! !./../../~/css-loader?sourceMap!./../../~/vue-loader/lib/style-rewriter.js?id=data-v-7fb69b18!./../../~/vue-loader/lib/selector.js?type=styles&index=0!./../../~/eslint-loader!./main.vue */ 12);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(/*! ./../../~/vue-style-loader/lib/addStylesClient.js */ 4)(\"05acdda8\", content, false);\n// Hot Module Replacement\nif(false) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-7fb69b18!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./../../node_modules/eslint-loader/index.js!./main.vue\", function() {\n     var newContent = require(\"!!./../../node_modules/css-loader/index.js?sourceMap!./../../node_modules/vue-loader/lib/style-rewriter.js?id=data-v-7fb69b18!./../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./../../node_modules/eslint-loader/index.js!./main.vue\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL21haW4udnVlPzJjOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi03ZmI2OWIxOCEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2VzbGludC1sb2FkZXIvaW5kZXguanMhLi9tYWluLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIwNWFjZGRhOFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtN2ZiNjliMTghLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuLy4uLy4uL25vZGVfbW9kdWxlcy9lc2xpbnQtbG9hZGVyL2luZGV4LmpzIS4vbWFpbi52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTdmYjY5YjE4IS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi8uLi8uLi9ub2RlX21vZHVsZXMvZXNsaW50LWxvYWRlci9pbmRleC5qcyEuL21haW4udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi03ZmI2OWIxOCEuLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi4vfi9lc2xpbnQtbG9hZGVyIS4vY29tcG9uZW50cy9tYWluLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=")},/*!*************************************************!*\
  !*** ../~/vue-style-loader/lib/listToStyles.js ***!
  \*************************************************/
function(module,exports){eval("/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanM/ODFlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRyYW5zbGF0ZXMgdGhlIGxpc3QgZm9ybWF0IHByb2R1Y2VkIGJ5IGNzcy1sb2FkZXIgaW50byBzb21ldGhpbmdcbiAqIGVhc2llciB0byBtYW5pcHVsYXRlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAocGFyZW50SWQsIGxpc3QpIHtcbiAgdmFyIHN0eWxlcyA9IFtdXG4gIHZhciBuZXdTdHlsZXMgPSB7fVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICB2YXIgaWQgPSBpdGVtWzBdXG4gICAgdmFyIGNzcyA9IGl0ZW1bMV1cbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdXG4gICAgdmFyIHNvdXJjZU1hcCA9IGl0ZW1bM11cbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGlkOiBwYXJlbnRJZCArICc6JyArIGksXG4gICAgICBjc3M6IGNzcyxcbiAgICAgIG1lZGlhOiBtZWRpYSxcbiAgICAgIHNvdXJjZU1hcDogc291cmNlTWFwXG4gICAgfVxuICAgIGlmICghbmV3U3R5bGVzW2lkXSkge1xuICAgICAgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHsgaWQ6IGlkLCBwYXJ0czogW3BhcnRdIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9")},/*!******************************!*\
  !*** ../~/vuex/dist/vuex.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("/**\n * vuex v2.1.1\n * (c) 2016 Evan You\n * @license MIT\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vuex = factory());\n}(this, (function () { 'use strict';\n\nvar devtoolHook =\n  typeof window !== 'undefined' &&\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\nfunction devtoolPlugin (store) {\n  if (!devtoolHook) { return }\n\n  store._devtoolHook = devtoolHook\n\n  devtoolHook.emit('vuex:init', store)\n\n  devtoolHook.on('vuex:travel-to-state', function (targetState) {\n    store.replaceState(targetState)\n  })\n\n  store.subscribe(function (mutation, state) {\n    devtoolHook.emit('vuex:mutation', mutation, state)\n  })\n}\n\nfunction applyMixin (Vue) {\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    var _init = Vue.prototype._init\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    var options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n\nvar mapState = normalizeNamespace(function (namespace, states) {\n  var res = {}\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedState () {\n      var state = this.$store.state\n      var getters = this.$store.getters\n      if (namespace) {\n        var module = this.$store._modulesNamespaceMap[namespace]\n        if (!module) {\n          warnNamespace('mapState', namespace)\n          return\n        }\n        state = module.state\n        getters = module.context.getters\n      }\n      return typeof val === 'function'\n        ? val.call(this, state, getters)\n        : state[val]\n    }\n  })\n  return res\n})\n\nvar mapMutations = normalizeNamespace(function (namespace, mutations) {\n  var res = {}\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\n\nvar mapGetters = normalizeNamespace(function (namespace, getters) {\n  var res = {}\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedGetter () {\n      if (!(val in this.$store.getters)) {\n        console.error((\"[vuex] unknown getter: \" + val))\n      }\n      return this.$store.getters[val]\n    }\n  })\n  return res\n})\n\nvar mapActions = normalizeNamespace(function (namespace, actions) {\n  var res = {}\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    val = namespace + val\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\n\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\n\nfunction normalizeNamespace (fn) {\n  return function (namespace, map) {\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    } else if (namespace.charAt(namespace.length - 1) !== '/') {\n      namespace += '/'\n    }\n    return fn(namespace, map)\n  }\n}\n\nfunction warnNamespace (helper, namespace) {\n  console.error((\"[vuex] module namespace not found in \" + helper + \"(): \" + namespace))\n}\n\n/**\n * forEach for object\n */\nfunction forEachValue (obj, fn) {\n  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); })\n}\n\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nfunction isPromise (val) {\n  return val && typeof val.then === 'function'\n}\n\nfunction assert (condition, msg) {\n  if (!condition) { throw new Error((\"[vuex] \" + msg)) }\n}\n\nvar Module = function Module (rawModule, runtime) {\n  this.runtime = runtime\n  this._children = Object.create(null)\n  this._rawModule = rawModule\n};\n\nvar prototypeAccessors$1 = { state: {},namespaced: {} };\n\nprototypeAccessors$1.state.get = function () {\n  return this._rawModule.state || {}\n};\n\nprototypeAccessors$1.namespaced.get = function () {\n  return !!this._rawModule.namespaced\n};\n\nModule.prototype.addChild = function addChild (key, module) {\n  this._children[key] = module\n};\n\nModule.prototype.removeChild = function removeChild (key) {\n  delete this._children[key]\n};\n\nModule.prototype.getChild = function getChild (key) {\n  return this._children[key]\n};\n\nModule.prototype.update = function update (rawModule) {\n  this._rawModule.namespaced = rawModule.namespaced\n  if (rawModule.actions) {\n    this._rawModule.actions = rawModule.actions\n  }\n  if (rawModule.mutations) {\n    this._rawModule.mutations = rawModule.mutations\n  }\n  if (rawModule.getters) {\n    this._rawModule.getters = rawModule.getters\n  }\n};\n\nModule.prototype.forEachChild = function forEachChild (fn) {\n  forEachValue(this._children, fn)\n};\n\nModule.prototype.forEachGetter = function forEachGetter (fn) {\n  if (this._rawModule.getters) {\n    forEachValue(this._rawModule.getters, fn)\n  }\n};\n\nModule.prototype.forEachAction = function forEachAction (fn) {\n  if (this._rawModule.actions) {\n    forEachValue(this._rawModule.actions, fn)\n  }\n};\n\nModule.prototype.forEachMutation = function forEachMutation (fn) {\n  if (this._rawModule.mutations) {\n    forEachValue(this._rawModule.mutations, fn)\n  }\n};\n\nObject.defineProperties( Module.prototype, prototypeAccessors$1 );\n\nvar ModuleCollection = function ModuleCollection (rawRootModule) {\n  var this$1 = this;\n\n  // register root module (Vuex.Store options)\n  this.root = new Module(rawRootModule, false)\n\n  // register all nested modules\n  if (rawRootModule.modules) {\n    forEachValue(rawRootModule.modules, function (rawModule, key) {\n      this$1.register([key], rawModule, false)\n    })\n  }\n};\n\nModuleCollection.prototype.get = function get (path) {\n  return path.reduce(function (module, key) {\n    return module.getChild(key)\n  }, this.root)\n};\n\nModuleCollection.prototype.getNamespace = function getNamespace (path) {\n  var module = this.root\n  return path.reduce(function (namespace, key) {\n    module = module.getChild(key)\n    return namespace + (module.namespaced ? key + '/' : '')\n  }, '')\n};\n\nModuleCollection.prototype.update = function update$1 (rawRootModule) {\n  update(this.root, rawRootModule)\n};\n\nModuleCollection.prototype.register = function register (path, rawModule, runtime) {\n    var this$1 = this;\n    if ( runtime === void 0 ) runtime = true;\n\n  var parent = this.get(path.slice(0, -1))\n  var newModule = new Module(rawModule, runtime)\n  parent.addChild(path[path.length - 1], newModule)\n\n  // register nested modules\n  if (rawModule.modules) {\n    forEachValue(rawModule.modules, function (rawChildModule, key) {\n      this$1.register(path.concat(key), rawChildModule, runtime)\n    })\n  }\n};\n\nModuleCollection.prototype.unregister = function unregister (path) {\n  var parent = this.get(path.slice(0, -1))\n  var key = path[path.length - 1]\n  if (!parent.getChild(key).runtime) { return }\n\n  parent.removeChild(key)\n};\n\nfunction update (targetModule, newModule) {\n  // update target module\n  targetModule.update(newModule)\n\n  // update nested modules\n  if (newModule.modules) {\n    for (var key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        console.warn(\n          \"[vuex] trying to add a new module '\" + key + \"' on hot reloading, \" +\n          'manual reload is needed'\n        )\n        return\n      }\n      update(targetModule.getChild(key), newModule.modules[key])\n    }\n  }\n}\n\nvar Vue // bind on install\n\nvar Store = function Store (options) {\n  var this$1 = this;\n  if ( options === void 0 ) options = {};\n\n  assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\")\n  assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\")\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  // store internal state\n  this._committing = false\n  this._actions = Object.create(null)\n  this._mutations = Object.create(null)\n  this._wrappedGetters = Object.create(null)\n  this._modules = new ModuleCollection(options)\n  this._modulesNamespaceMap = Object.create(null)\n  this._subscribers = []\n  this._watcherVM = new Vue()\n\n  // bind commit and dispatch to self\n  var store = this\n  var ref = this;\n  var dispatch = ref.dispatch;\n  var commit = ref.commit;\n    this.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n  }\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n  this.strict = strict\n\n  // init root module.\n  // this also recursively registers all sub-modules\n  // and collects all module getters inside this._wrappedGetters\n  installModule(this, state, [], this._modules.root)\n\n  // initialize the store vm, which is responsible for the reactivity\n  // (also registers _wrappedGetters as computed properties)\n  resetStoreVM(this, state)\n\n  // apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); })\n};\n\nvar prototypeAccessors = { state: {} };\n\nprototypeAccessors.state.get = function () {\n  return this._vm.$data.state\n};\n\nprototypeAccessors.state.set = function (v) {\n  assert(false, \"Use store.replaceState() to explicit replace store state.\")\n};\n\nStore.prototype.commit = function commit (_type, _payload, _options) {\n    var this$1 = this;\n\n  // check object-style commit\n  var ref = unifyObjectStyle(_type, _payload, _options);\n    var type = ref.type;\n    var payload = ref.payload;\n    var options = ref.options;\n\n  var mutation = { type: type, payload: payload }\n  var entry = this._mutations[type]\n  if (!entry) {\n    console.error((\"[vuex] unknown mutation type: \" + type))\n    return\n  }\n  this._withCommit(function () {\n    entry.forEach(function commitIterator (handler) {\n      handler(payload)\n    })\n  })\n  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); })\n\n  if (options && options.silent) {\n    console.warn(\n      \"[vuex] mutation type: \" + type + \". Silent option has been removed. \" +\n      'Use the filter functionality in the vue-devtools'\n    )\n  }\n};\n\nStore.prototype.dispatch = function dispatch (_type, _payload) {\n  // check object-style dispatch\n  var ref = unifyObjectStyle(_type, _payload);\n    var type = ref.type;\n    var payload = ref.payload;\n\n  var entry = this._actions[type]\n  if (!entry) {\n    console.error((\"[vuex] unknown action type: \" + type))\n    return\n  }\n  return entry.length > 1\n    ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n    : entry[0](payload)\n};\n\nStore.prototype.subscribe = function subscribe (fn) {\n  var subs = this._subscribers\n  if (subs.indexOf(fn) < 0) {\n    subs.push(fn)\n  }\n  return function () {\n    var i = subs.indexOf(fn)\n    if (i > -1) {\n      subs.splice(i, 1)\n    }\n  }\n};\n\nStore.prototype.watch = function watch (getter, cb, options) {\n    var this$1 = this;\n\n  assert(typeof getter === 'function', \"store.watch only accepts a function.\")\n  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)\n};\n\nStore.prototype.replaceState = function replaceState (state) {\n    var this$1 = this;\n\n  this._withCommit(function () {\n    this$1._vm.state = state\n  })\n};\n\nStore.prototype.registerModule = function registerModule (path, rawModule) {\n  if (typeof path === 'string') { path = [path] }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n  this._modules.register(path, rawModule)\n  installModule(this, this.state, path, this._modules.get(path))\n  // reset store to update getters...\n  resetStoreVM(this, this.state)\n};\n\nStore.prototype.unregisterModule = function unregisterModule (path) {\n    var this$1 = this;\n\n  if (typeof path === 'string') { path = [path] }\n  assert(Array.isArray(path), \"module path must be a string or an Array.\")\n    this._modules.unregister(path)\n  this._withCommit(function () {\n    var parentState = getNestedState(this$1.state, path.slice(0, -1))\n    Vue.delete(parentState, path[path.length - 1])\n  })\n  resetStore(this)\n};\n\nStore.prototype.hotUpdate = function hotUpdate (newOptions) {\n  this._modules.update(newOptions)\n  resetStore(this)\n};\n\nStore.prototype._withCommit = function _withCommit (fn) {\n  var committing = this._committing\n  this._committing = true\n  fn()\n  this._committing = committing\n};\n\nObject.defineProperties( Store.prototype, prototypeAccessors );\n\nfunction resetStore (store) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  store._modulesNamespaceMap = Object.create(null)\n  var state = store.state\n  // init all modules\n  installModule(store, state, [], store._modules.root, true)\n  // reset vm\n  resetStoreVM(store, state)\n}\n\nfunction resetStoreVM (store, state) {\n  var oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  var wrappedGetters = store._wrappedGetters\n  var computed = {}\n  forEachValue(wrappedGetters, function (fn, key) {\n    // use computed to leverage its lazy-caching mechanism\n    computed[key] = function () { return fn(store); }\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; },\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  var silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: { state: state },\n    computed: computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    // dispatch changes in all subscribed watchers\n    // to force getter re-evaluation.\n    store._withCommit(function () {\n      oldVm.state = null\n    })\n    Vue.nextTick(function () { return oldVm.$destroy(); })\n  }\n}\n\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length\n  var namespace = store._modules.getNamespace(path)\n\n  // register in namespace map\n  if (namespace) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  // set state\n  if (!isRoot && !hot) {\n    var parentState = getNestedState(rootState, path.slice(0, -1))\n    var moduleName = path[path.length - 1]\n    store._withCommit(function () {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n\n  var local = module.context = makeLocalContext(store, namespace)\n\n  module.forEachMutation(function (mutation, key) {\n    var namespacedType = namespace + key\n    registerMutation(store, namespacedType, mutation, path)\n  })\n\n  module.forEachAction(function (action, key) {\n    var namespacedType = namespace + key\n    registerAction(store, namespacedType, action, local, path)\n  })\n\n  module.forEachGetter(function (getter, key) {\n    var namespacedType = namespace + key\n    registerGetter(store, namespacedType, getter, local, path)\n  })\n\n  module.forEachChild(function (child, key) {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\n\n/**\n * make localized dispatch, commit and getters\n * if there is no namespace, just use root ones\n */\nfunction makeLocalContext (store, namespace) {\n  var noNamespace = namespace === ''\n\n  var local = {\n    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options)\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._actions[type]) {\n          console.error((\"[vuex] unknown local action type: \" + (args.type) + \", global type: \" + type))\n          return\n        }\n      }\n\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : function (_type, _payload, _options) {\n      var args = unifyObjectStyle(_type, _payload, _options)\n      var payload = args.payload;\n      var options = args.options;\n      var type = args.type;\n\n      if (!options || !options.root) {\n        type = namespace + type\n        if (!store._mutations[type]) {\n          console.error((\"[vuex] unknown local mutation type: \" + (args.type) + \", global type: \" + type))\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  // getters object must be gotten lazily\n  // because store.getters will be changed by vm update\n  Object.defineProperty(local, 'getters', {\n    get: noNamespace ? function () { return store.getters; } : function () { return makeLocalGetters(store, namespace); }\n  })\n\n  return local\n}\n\nfunction makeLocalGetters (store, namespace) {\n  var gettersProxy = {}\n\n  var splitPos = namespace.length\n  Object.keys(store.getters).forEach(function (type) {\n    // skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) { return }\n\n    // extract local getter type\n    var localType = type.slice(splitPos)\n\n    // Add a port to the getters proxy.\n    // Define as getter property because\n    // we do not want to evaluate the getters in this time.\n    Object.defineProperty(gettersProxy, localType, {\n      get: function () { return store.getters[type]; },\n      enumerable: true\n    })\n  })\n\n  return gettersProxy\n}\n\nfunction registerMutation (store, type, handler, path) {\n  var entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(getNestedState(store.state, path), payload)\n  })\n}\n\nfunction registerAction (store, type, handler, local, path) {\n  var entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: getNestedState(store.state, path),\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit('vuex:error', err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\n\nfunction registerGetter (store, type, rawGetter, local, path) {\n  if (store._wrappedGetters[type]) {\n    console.error((\"[vuex] duplicate getter key: \" + type))\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    return rawGetter(\n      getNestedState(store.state, path), // local state\n      local.getters, // local getters\n      store.state, // root state\n      store.getters // root getters\n    )\n  }\n}\n\nfunction enableStrictMode (store) {\n  store._vm.$watch('state', function () {\n    assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\")\n  }, { deep: true, sync: true })\n}\n\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\n\nfunction unifyObjectStyle (type, payload, options) {\n  if (isObject(type) && type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n  return { type: type, payload: payload, options: options }\n}\n\nfunction install (_Vue) {\n  if (Vue) {\n    console.error(\n      '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n// auto install in dist mode\nif (typeof window !== 'undefined' && window.Vue) {\n  install(window.Vue)\n}\n\nvar index = {\n  Store: Store,\n  install: install,\n  version: '2.1.1',\n  mapState: mapState,\n  mapMutations: mapMutations,\n  mapGetters: mapGetters,\n  mapActions: mapActions\n}\n\nreturn index;\n\n})));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi92dWV4L2Rpc3QvdnVleC5qcz8yZGQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdnVleCB2Mi4xLjFcbiAqIChjKSAyMDE2IEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsLlZ1ZXggPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBkZXZ0b29sSG9vayA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fXG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9va1xuXG4gIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6aW5pdCcsIHN0b3JlKVxuXG4gIGRldnRvb2xIb29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSlcbiAgfSlcblxuICBzdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKG11dGF0aW9uLCBzdGF0ZSkge1xuICAgIGRldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6bXV0YXRpb24nLCBtdXRhdGlvbiwgc3RhdGUpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFwcGx5TWl4aW4gKFZ1ZSkge1xuICB2YXIgdmVyc2lvbiA9IE51bWJlcihWdWUudmVyc2lvbi5zcGxpdCgnLicpWzBdKVxuXG4gIGlmICh2ZXJzaW9uID49IDIpIHtcbiAgICB2YXIgdXNlc0luaXQgPSBWdWUuY29uZmlnLl9saWZlY3ljbGVIb29rcy5pbmRleE9mKCdpbml0JykgPiAtMVxuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KVxuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAgICAgb3B0aW9ucy5pbml0ID0gb3B0aW9ucy5pbml0XG4gICAgICAgID8gW3Z1ZXhJbml0XS5jb25jYXQob3B0aW9ucy5pbml0KVxuICAgICAgICA6IHZ1ZXhJbml0XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZ1ZXggaW5pdCBob29rLCBpbmplY3RlZCBpbnRvIGVhY2ggaW5zdGFuY2VzIGluaXQgaG9va3MgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gdnVleEluaXQgKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9uc1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmVcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMucGFyZW50ICYmIG9wdGlvbnMucGFyZW50LiRzdG9yZSkge1xuICAgICAgdGhpcy4kc3RvcmUgPSBvcHRpb25zLnBhcmVudC4kc3RvcmVcbiAgICB9XG4gIH1cbn1cblxudmFyIG1hcFN0YXRlID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIHN0YXRlcykge1xuICB2YXIgcmVzID0ge31cbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlXG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnNcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IHRoaXMuJHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV1cbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICB3YXJuTmFtZXNwYWNlKCdtYXBTdGF0ZScsIG5hbWVzcGFjZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5zdGF0ZVxuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVyc1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB2YWwuY2FsbCh0aGlzLCBzdGF0ZSwgZ2V0dGVycylcbiAgICAgICAgOiBzdGF0ZVt2YWxdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59KVxuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge31cbiAgbm9ybWFsaXplTWFwKG11dGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWxcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59KVxuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fVxuICBub3JtYWxpemVNYXAoZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICB2YWwgPSBuYW1lc3BhY2UgKyB2YWxcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEdldHRlciAoKSB7XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzW3ZhbF1cbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXNcbn0pXG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9XG4gIG5vcm1hbGl6ZU1hcChhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbFxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZGlzcGF0Y2guYXBwbHkodGhpcy4kc3RvcmUsIFt2YWxdLmNvbmNhdChhcmdzKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXNcbn0pXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcCAobWFwKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG1hcClcbiAgICA/IG1hcC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDoga2V5IH0pOyB9KVxuICAgIDogT2JqZWN0LmtleXMobWFwKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHsga2V5OiBrZXksIHZhbDogbWFwW2tleV0gfSk7IH0pXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWVzcGFjZSAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1hcCkge1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgbWFwID0gbmFtZXNwYWNlXG4gICAgICBuYW1lc3BhY2UgPSAnJ1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJ1xuICAgIH1cbiAgICByZXR1cm4gZm4obmFtZXNwYWNlLCBtYXApXG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk5hbWVzcGFjZSAoaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpXG59XG5cbi8qKlxuICogZm9yRWFjaCBmb3Igb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hWYWx1ZSAob2JqLCBmbikge1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4ob2JqW2tleV0sIGtleSk7IH0pXG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiBNb2R1bGUgKHJhd01vZHVsZSwgcnVudGltZSkge1xuICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lXG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB0aGlzLl9yYXdNb2R1bGUgPSByYXdNb2R1bGVcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgc3RhdGU6IHt9LG5hbWVzcGFjZWQ6IHt9IH07XG5cbnByb3RvdHlwZUFjY2Vzc29ycyQxLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jhd01vZHVsZS5zdGF0ZSB8fCB7fVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGVcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZCAoa2V5KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gZ2V0Q2hpbGQgKGtleSkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRyZW5ba2V5XVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHJhd01vZHVsZSkge1xuICB0aGlzLl9yYXdNb2R1bGUubmFtZXNwYWNlZCA9IHJhd01vZHVsZS5uYW1lc3BhY2VkXG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnNcbiAgfVxuICBpZiAocmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5tdXRhdGlvbnMgPSByYXdNb2R1bGUubXV0YXRpb25zXG4gIH1cbiAgaWYgKHJhd01vZHVsZS5nZXR0ZXJzKSB7XG4gICAgdGhpcy5fcmF3TW9kdWxlLmdldHRlcnMgPSByYXdNb2R1bGUuZ2V0dGVyc1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbilcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEdldHRlciA9IGZ1bmN0aW9uIGZvckVhY2hHZXR0ZXIgKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycywgZm4pXG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaEFjdGlvbiA9IGZ1bmN0aW9uIGZvckVhY2hBY3Rpb24gKGZuKSB7XG4gIGlmICh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUuYWN0aW9ucywgZm4pXG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbilcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1vZHVsZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cbnZhciBNb2R1bGVDb2xsZWN0aW9uID0gZnVuY3Rpb24gTW9kdWxlQ29sbGVjdGlvbiAocmF3Um9vdE1vZHVsZSkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyByZWdpc3RlciByb290IG1vZHVsZSAoVnVleC5TdG9yZSBvcHRpb25zKVxuICB0aGlzLnJvb3QgPSBuZXcgTW9kdWxlKHJhd1Jvb3RNb2R1bGUsIGZhbHNlKVxuXG4gIC8vIHJlZ2lzdGVyIGFsbCBuZXN0ZWQgbW9kdWxlc1xuICBpZiAocmF3Um9vdE1vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd1Jvb3RNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd01vZHVsZSwga2V5KSB7XG4gICAgICB0aGlzJDEucmVnaXN0ZXIoW2tleV0sIHJhd01vZHVsZSwgZmFsc2UpXG4gICAgfSlcbiAgfVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3RcbiAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGtleSkge1xuICAgIG1vZHVsZSA9IG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpXG59O1xuXG5Nb2R1bGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyIChwYXRoLCByYXdNb2R1bGUsIHJ1bnRpbWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICBpZiAoIHJ1bnRpbWUgPT09IHZvaWQgMCApIHJ1bnRpbWUgPSB0cnVlO1xuXG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSlcbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKVxuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpXG5cbiAgLy8gcmVnaXN0ZXIgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKHJhd01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yRWFjaFZhbHVlKHJhd01vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3Q2hpbGRNb2R1bGUsIGtleSkge1xuICAgICAgdGhpcyQxLnJlZ2lzdGVyKHBhdGguY29uY2F0KGtleSksIHJhd0NoaWxkTW9kdWxlLCBydW50aW1lKVxuICAgIH0pXG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSlcbiAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICBpZiAoIXBhcmVudC5nZXRDaGlsZChrZXkpLnJ1bnRpbWUpIHsgcmV0dXJuIH1cblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoa2V5KVxufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSlcblxuICAvLyB1cGRhdGUgbmVzdGVkIG1vZHVsZXNcbiAgaWYgKG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5ld01vZHVsZS5tb2R1bGVzKSB7XG4gICAgICBpZiAoIXRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICdtYW51YWwgcmVsb2FkIGlzIG5lZWRlZCdcbiAgICAgICAgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZSh0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSwgbmV3TW9kdWxlLm1vZHVsZXNba2V5XSlcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZSAvLyBiaW5kIG9uIGluc3RhbGxcblxudmFyIFN0b3JlID0gZnVuY3Rpb24gU3RvcmUgKG9wdGlvbnMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIGFzc2VydChWdWUsIFwibXVzdCBjYWxsIFZ1ZS51c2UoVnVleCkgYmVmb3JlIGNyZWF0aW5nIGEgc3RvcmUgaW5zdGFuY2UuXCIpXG4gIGFzc2VydCh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcsIFwidnVleCByZXF1aXJlcyBhIFByb21pc2UgcG9seWZpbGwgaW4gdGhpcyBicm93c2VyLlwiKVxuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlXG4gIHRoaXMuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMuX21vZHVsZXMgPSBuZXcgTW9kdWxlQ29sbGVjdGlvbihvcHRpb25zKVxuICB0aGlzLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdXG4gIHRoaXMuX3dhdGNoZXJWTSA9IG5ldyBWdWUoKVxuXG4gIC8vIGJpbmQgY29tbWl0IGFuZCBkaXNwYXRjaCB0byBzZWxmXG4gIHZhciBzdG9yZSA9IHRoaXNcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gICAgdGhpcy5kaXNwYXRjaCA9IGZ1bmN0aW9uIGJvdW5kRGlzcGF0Y2ggKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2guY2FsbChzdG9yZSwgdHlwZSwgcGF5bG9hZClcbiAgfVxuICB0aGlzLmNvbW1pdCA9IGZ1bmN0aW9uIGJvdW5kQ29tbWl0ICh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbW1pdC5jYWxsKHN0b3JlLCB0eXBlLCBwYXlsb2FkLCBvcHRpb25zKVxuICAgIH1cblxuICAgIC8vIHN0cmljdCBtb2RlXG4gIHRoaXMuc3RyaWN0ID0gc3RyaWN0XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdClcblxuICAvLyBpbml0aWFsaXplIHRoZSBzdG9yZSB2bSwgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIHRoZSByZWFjdGl2aXR5XG4gIC8vIChhbHNvIHJlZ2lzdGVycyBfd3JhcHBlZEdldHRlcnMgYXMgY29tcHV0ZWQgcHJvcGVydGllcylcbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHN0YXRlKVxuXG4gIC8vIGFwcGx5IHBsdWdpbnNcbiAgcGx1Z2lucy5jb25jYXQoZGV2dG9vbFBsdWdpbikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7IHJldHVybiBwbHVnaW4odGhpcyQxKTsgfSlcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uJGRhdGEuc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5zZXQgPSBmdW5jdGlvbiAodikge1xuICBhc3NlcnQoZmFsc2UsIFwiVXNlIHN0b3JlLnJlcGxhY2VTdGF0ZSgpIHRvIGV4cGxpY2l0IHJlcGxhY2Ugc3RvcmUgc3RhdGUuXCIpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfVxuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV1cbiAgaWYgKCFlbnRyeSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlKSlcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpXG4gICAgfSlcbiAgfSlcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnQpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlt2dWV4XSBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUgKyBcIi4gU2lsZW50IG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLiBcIiArXG4gICAgICAnVXNlIHRoZSBmaWx0ZXIgZnVuY3Rpb25hbGl0eSBpbiB0aGUgdnVlLWRldnRvb2xzJ1xuICAgIClcbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKF90eXBlLCBfcGF5bG9hZCkge1xuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgZGlzcGF0Y2hcbiAgdmFyIHJlZiA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG5cbiAgdmFyIGVudHJ5ID0gdGhpcy5fYWN0aW9uc1t0eXBlXVxuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSlcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICB2YXIgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzXG4gIGlmIChzdWJzLmluZGV4T2YoZm4pIDwgMCkge1xuICAgIHN1YnMucHVzaChmbilcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKVxuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaCAoZ2V0dGVyLCBjYiwgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGFzc2VydCh0eXBlb2YgZ2V0dGVyID09PSAnZnVuY3Rpb24nLCBcInN0b3JlLndhdGNoIG9ubHkgYWNjZXB0cyBhIGZ1bmN0aW9uLlwiKVxuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLnN0YXRlID0gc3RhdGVcbiAgfSlcbn07XG5cblN0b3JlLnByb3RvdHlwZS5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlIChwYXRoLCByYXdNb2R1bGUpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIilcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpXG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCkpXG4gIC8vIHJlc2V0IHN0b3JlIHRvIHVwZGF0ZSBnZXR0ZXJzLi4uXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCB0aGlzLnN0YXRlKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdIH1cbiAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIilcbiAgICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aClcbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUodGhpcyQxLnN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSlcbiAgICBWdWUuZGVsZXRlKHBhcmVudFN0YXRlLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pXG4gIH0pXG4gIHJlc2V0U3RvcmUodGhpcylcbn07XG5cblN0b3JlLnByb3RvdHlwZS5ob3RVcGRhdGUgPSBmdW5jdGlvbiBob3RVcGRhdGUgKG5ld09wdGlvbnMpIHtcbiAgdGhpcy5fbW9kdWxlcy51cGRhdGUobmV3T3B0aW9ucylcbiAgcmVzZXRTdG9yZSh0aGlzKVxufTtcblxuU3RvcmUucHJvdG90eXBlLl93aXRoQ29tbWl0ID0gZnVuY3Rpb24gX3dpdGhDb21taXQgKGZuKSB7XG4gIHZhciBjb21taXR0aW5nID0gdGhpcy5fY29tbWl0dGluZ1xuICB0aGlzLl9jb21taXR0aW5nID0gdHJ1ZVxuICBmbigpXG4gIHRoaXMuX2NvbW1pdHRpbmcgPSBjb21taXR0aW5nXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RvcmUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVzZXRTdG9yZSAoc3RvcmUpIHtcbiAgc3RvcmUuX2FjdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHN0b3JlLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHZhciBzdGF0ZSA9IHN0b3JlLnN0YXRlXG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKVxuICAvLyByZXNldCB2bVxuICByZXNldFN0b3JlVk0oc3RvcmUsIHN0YXRlKVxufVxuXG5mdW5jdGlvbiByZXNldFN0b3JlVk0gKHN0b3JlLCBzdGF0ZSkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm1cblxuICAvLyBiaW5kIHN0b3JlIHB1YmxpYyBnZXR0ZXJzXG4gIHN0b3JlLmdldHRlcnMgPSB7fVxuICB2YXIgd3JhcHBlZEdldHRlcnMgPSBzdG9yZS5fd3JhcHBlZEdldHRlcnNcbiAgdmFyIGNvbXB1dGVkID0ge31cbiAgZm9yRWFjaFZhbHVlKHdyYXBwZWRHZXR0ZXJzLCBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgIC8vIHVzZSBjb21wdXRlZCB0byBsZXZlcmFnZSBpdHMgbGF6eS1jYWNoaW5nIG1lY2hhbmlzbVxuICAgIGNvbXB1dGVkW2tleV0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmbihzdG9yZSk7IH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLl92bVtrZXldOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pXG4gIH0pXG5cbiAgLy8gdXNlIGEgVnVlIGluc3RhbmNlIHRvIHN0b3JlIHRoZSBzdGF0ZSB0cmVlXG4gIC8vIHN1cHByZXNzIHdhcm5pbmdzIGp1c3QgaW4gY2FzZSB0aGUgdXNlciBoYXMgYWRkZWRcbiAgLy8gc29tZSBmdW5reSBnbG9iYWwgbWl4aW5zXG4gIHZhciBzaWxlbnQgPSBWdWUuY29uZmlnLnNpbGVudFxuICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWVcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YTogeyBzdGF0ZTogc3RhdGUgfSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRcbiAgfSlcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnRcblxuICAvLyBlbmFibGUgc3RyaWN0IG1vZGUgZm9yIG5ldyB2bVxuICBpZiAoc3RvcmUuc3RyaWN0KSB7XG4gICAgZW5hYmxlU3RyaWN0TW9kZShzdG9yZSlcbiAgfVxuXG4gIGlmIChvbGRWbSkge1xuICAgIC8vIGRpc3BhdGNoIGNoYW5nZXMgaW4gYWxsIHN1YnNjcmliZWQgd2F0Y2hlcnNcbiAgICAvLyB0byBmb3JjZSBnZXR0ZXIgcmUtZXZhbHVhdGlvbi5cbiAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBvbGRWbS5zdGF0ZSA9IG51bGxcbiAgICB9KVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGxNb2R1bGUgKHN0b3JlLCByb290U3RhdGUsIHBhdGgsIG1vZHVsZSwgaG90KSB7XG4gIHZhciBpc1Jvb3QgPSAhcGF0aC5sZW5ndGhcbiAgdmFyIG5hbWVzcGFjZSA9IHN0b3JlLl9tb2R1bGVzLmdldE5hbWVzcGFjZShwYXRoKVxuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG5hbWVzcGFjZSkge1xuICAgIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV0gPSBtb2R1bGVcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSlcbiAgICB2YXIgbW9kdWxlTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFZ1ZS5zZXQocGFyZW50U3RhdGUsIG1vZHVsZU5hbWUsIG1vZHVsZS5zdGF0ZSlcbiAgICB9KVxuICB9XG5cbiAgdmFyIGxvY2FsID0gbW9kdWxlLmNvbnRleHQgPSBtYWtlTG9jYWxDb250ZXh0KHN0b3JlLCBuYW1lc3BhY2UpXG5cbiAgbW9kdWxlLmZvckVhY2hNdXRhdGlvbihmdW5jdGlvbiAobXV0YXRpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleVxuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgcGF0aClcbiAgfSlcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXlcbiAgICByZWdpc3RlckFjdGlvbihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGFjdGlvbiwgbG9jYWwsIHBhdGgpXG4gIH0pXG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5XG4gICAgcmVnaXN0ZXJHZXR0ZXIoc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBnZXR0ZXIsIGxvY2FsLCBwYXRoKVxuICB9KVxuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpXG4gIH0pXG59XG5cbi8qKlxuICogbWFrZSBsb2NhbGl6ZWQgZGlzcGF0Y2gsIGNvbW1pdCBhbmQgZ2V0dGVyc1xuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnXG5cbiAgdmFyIGxvY2FsID0ge1xuICAgIGRpc3BhdGNoOiBub05hbWVzcGFjZSA/IHN0b3JlLmRpc3BhdGNoIDogZnVuY3Rpb24gKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKVxuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZVxuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2godHlwZSwgcGF5bG9hZClcbiAgICB9LFxuXG4gICAgY29tbWl0OiBub05hbWVzcGFjZSA/IHN0b3JlLmNvbW1pdCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucylcbiAgICAgIHZhciBwYXlsb2FkID0gYXJncy5wYXlsb2FkO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzLm9wdGlvbnM7XG4gICAgICB2YXIgdHlwZSA9IGFyZ3MudHlwZTtcblxuICAgICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnJvb3QpIHtcbiAgICAgICAgdHlwZSA9IG5hbWVzcGFjZSArIHR5cGVcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIC8vIGdldHRlcnMgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHN0b3JlLmdldHRlcnMgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobG9jYWwsICdnZXR0ZXJzJywge1xuICAgIGdldDogbm9OYW1lc3BhY2UgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICB9KVxuXG4gIHJldHVybiBsb2NhbFxufVxuXG5mdW5jdGlvbiBtYWtlTG9jYWxHZXR0ZXJzIChzdG9yZSwgbmFtZXNwYWNlKSB7XG4gIHZhciBnZXR0ZXJzUHJveHkgPSB7fVxuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGhcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcylcblxuICAgIC8vIEFkZCBhIHBvcnQgdG8gdGhlIGdldHRlcnMgcHJveHkuXG4gICAgLy8gRGVmaW5lIGFzIGdldHRlciBwcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gd2UgZG8gbm90IHdhbnQgdG8gZXZhbHVhdGUgdGhlIGdldHRlcnMgaW4gdGhpcyB0aW1lLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXR0ZXJzUHJveHksIGxvY2FsVHlwZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzW3R5cGVdOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH0pXG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgcGF0aCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fbXV0YXRpb25zW3R5cGVdIHx8IChzdG9yZS5fbXV0YXRpb25zW3R5cGVdID0gW10pXG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIoZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpLCBwYXlsb2FkKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsLCBwYXRoKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKVxuICBlbnRyeS5wdXNoKGZ1bmN0aW9uIHdyYXBwZWRBY3Rpb25IYW5kbGVyIChwYXlsb2FkLCBjYikge1xuICAgIHZhciByZXMgPSBoYW5kbGVyKHtcbiAgICAgIGRpc3BhdGNoOiBsb2NhbC5kaXNwYXRjaCxcbiAgICAgIGNvbW1pdDogbG9jYWwuY29tbWl0LFxuICAgICAgZ2V0dGVyczogbG9jYWwuZ2V0dGVycyxcbiAgICAgIHN0YXRlOiBnZXROZXN0ZWRTdGF0ZShzdG9yZS5zdGF0ZSwgcGF0aCksXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYilcbiAgICBpZiAoIWlzUHJvbWlzZShyZXMpKSB7XG4gICAgICByZXMgPSBQcm9taXNlLnJlc29sdmUocmVzKVxuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJHZXR0ZXIgKHN0b3JlLCB0eXBlLCByYXdHZXR0ZXIsIGxvY2FsLCBwYXRoKSB7XG4gIGlmIChzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0pIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBkdXBsaWNhdGUgZ2V0dGVyIGtleTogXCIgKyB0eXBlKSlcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBnZXROZXN0ZWRTdGF0ZShzdG9yZS5zdGF0ZSwgcGF0aCksIC8vIGxvY2FsIHN0YXRlXG4gICAgICBsb2NhbC5nZXR0ZXJzLCAvLyBsb2NhbCBnZXR0ZXJzXG4gICAgICBzdG9yZS5zdGF0ZSwgLy8gcm9vdCBzdGF0ZVxuICAgICAgc3RvcmUuZ2V0dGVycyAvLyByb290IGdldHRlcnNcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaCgnc3RhdGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKVxuICB9LCB7IGRlZXA6IHRydWUsIHN5bmM6IHRydWUgfSlcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWRcbiAgICBwYXlsb2FkID0gdHlwZVxuICAgIHR5cGUgPSB0eXBlLnR5cGVcbiAgfVxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgIClcbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlXG4gIGFwcGx5TWl4aW4oVnVlKVxufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpXG59XG5cbnZhciBpbmRleCA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4xLjEnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59XG5cbnJldHVybiBpbmRleDtcblxufSkpKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L3Z1ZXgvZGlzdC92dWV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");
},/*!**************************************!*\
  !*** ../~/webpack/buildin/global.js ***!
  \**************************************/
function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzPzYyYTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=')},/*!****************!*\
  !*** ./app.js ***!
  \****************/
function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _vue = __webpack_require__(/*! vue */ 2);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _root = __webpack_require__(/*! ./components/root.vue */ 5);\n\nvar _root2 = _interopRequireDefault(_root);\n\nvar _store = __webpack_require__(/*! ./store/store */ 1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nnew _vue2.default({\n\tel: '#app',\n\tstore: _store.store,\n\tcomponents: { root: _root2.default }\n}); /*=============================================>>>>>\n    = VEU APP =\n    ===============================================>>>>>*/\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9hcHAuanMiXSwibmFtZXMiOlsiZWwiLCJzdG9yZSIsImNvbXBvbmVudHMiLCJyb290Il0sIm1hcHBpbmdzIjoiOztBQUlBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLGtCQUFRO0FBQ1BBLEtBQUksTUFERztBQUVQQyxvQkFGTztBQUdQQyxhQUFZLEVBQUVDLG9CQUFGO0FBSEwsQ0FBUixFLENBUkEiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6Ii9tZWRpYS9leHRfZGlzay9DT0RFQVJNQURBL2h0dHAvZXhwZXJpbWVudHMvdnVlL2FwcCIsInNvdXJjZXNDb250ZW50IjpbIi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Pj4+Pj5cbj0gVkVVIEFQUCA9XG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT4+Pj4+Ki9cblxuaW1wb3J0IFZ1ZSBmcm9tICd2dWUnO1xuaW1wb3J0IHJvb3QgZnJvbSAnLi9jb21wb25lbnRzL3Jvb3QudnVlJztcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSAnLi9zdG9yZS9zdG9yZSc7XG5cbm5ldyBWdWUoe1xuXHRlbDogJyNhcHAnLFxuXHRzdG9yZTogc3RvcmUsXG5cdGNvbXBvbmVudHM6IHsgcm9vdCB9XG59KVxuIl19//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAuanM/ZGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfcm9vdCA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9yb290LnZ1ZScpO1xuXG52YXIgX3Jvb3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm9vdCk7XG5cbnZhciBfc3RvcmUgPSByZXF1aXJlKCcuL3N0b3JlL3N0b3JlJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm5ldyBfdnVlMi5kZWZhdWx0KHtcblx0ZWw6ICcjYXBwJyxcblx0c3RvcmU6IF9zdG9yZS5zdG9yZSxcblx0Y29tcG9uZW50czogeyByb290OiBfcm9vdDIuZGVmYXVsdCB9XG59KTsgLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0+Pj4+PlxuICAgID0gVkVVIEFQUCA9XG4gICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0+Pj4+PiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OWhjSEF1YW5NaVhTd2libUZ0WlhNaU9sc2laV3dpTENKemRHOXlaU0lzSW1OdmJYQnZibVZ1ZEhNaUxDSnliMjkwSWwwc0ltMWhjSEJwYm1keklqb2lPenRCUVVsQk96czdPMEZCUTBFN096czdRVUZEUVRzN096dEJRVVZCTEd0Q1FVRlJPMEZCUTFCQkxFdEJRVWtzVFVGRVJ6dEJRVVZRUXl4dlFrRkdUenRCUVVkUVF5eGhRVUZaTEVWQlFVVkRMRzlDUVVGR08wRkJTRXdzUTBGQlVpeEZMRU5CVWtFaUxDSm1hV3hsSWpvaVlYQndMbXB6SWl3aWMyOTFjbU5sVW05dmRDSTZJaTl0WldScFlTOWxlSFJmWkdsemF5OURUMFJGUVZKTlFVUkJMMmgwZEhBdlpYaHdaWEpwYldWdWRITXZkblZsTDJGd2NDSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJaThxUFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UGo0K1BqNWNiajBnVmtWVklFRlFVQ0E5WEc0OVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUMDlQVDA5UFQwOVBUNCtQajQrS2k5Y2JseHVhVzF3YjNKMElGWjFaU0JtY205dElDZDJkV1VuTzF4dWFXMXdiM0owSUhKdmIzUWdabkp2YlNBbkxpOWpiMjF3YjI1bGJuUnpMM0p2YjNRdWRuVmxKenRjYm1sdGNHOXlkQ0I3SUhOMGIzSmxJSDBnWm5KdmJTQW5MaTl6ZEc5eVpTOXpkRzl5WlNjN1hHNWNibTVsZHlCV2RXVW9lMXh1WEhSbGJEb2dKeU5oY0hBbkxGeHVYSFJ6ZEc5eVpUb2djM1J2Y21Vc1hHNWNkR052YlhCdmJtVnVkSE02SUhzZ2NtOXZkQ0I5WEc1OUtWeHVJbDE5XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9hcHAuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=")}]);